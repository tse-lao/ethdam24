{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.5) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * Consider any assumption about calldata validation performed by the sender may be violated if it's not especially\n * careful about sending transactions invoking {multicall}. For example, a relay address that filters function\n * selectors won't filter calls nested within a {multicall} operation.\n *\n * NOTE: Since 5.0.1 and 4.9.4, this contract identifies non-canonical contexts (i.e. `msg.sender` is not {_msgSender}).\n * If a non-canonical context is identified, the following self `delegatecall` appends the last bytes of `msg.data`\n * to the subcall. This makes it safe to use with {ERC2771Context}. Contexts that don't affect the resolution of\n * {_msgSender} are not propagated to subcalls.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall is Context {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        bytes memory context = msg.sender == _msgSender()\n            ? new bytes(0)\n            : msg.data[msg.data.length - _contextSuffixLength():];\n\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\n        }\n        return results;\n    }\n}\n"
    },
    "contracts/core/Allo.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"./libraries/Ownable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n// Interfaces\nimport \"./interfaces/IAllo.sol\";\n\n// Internal Libraries\nimport {Clone} from \"./libraries/Clone.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport \"./libraries/Native.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Allo\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This contract is used to create & manage pools as well as manage the protocol.\n/// @dev The contract must be initialized with the 'initialize()' function.\ncontract Allo is\n    IAllo,\n    Native,\n    Transfer,\n    Initializable,\n    Ownable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Errors\n{\n    // ==========================\n    // === Storage Variables ====\n    // ==========================\n\n    /// @notice Percentage that is used to calculate the fee Allo takes from each pool when funded\n    ///         and is deducted when a pool is funded. So if you want to fund a round with 1000 DAI and the fee\n    ///         percentage is 1e17 (10%), then 100 DAI will be deducted from the 1000 DAI and the pool will be\n    ///         funded with 900 DAI. The fee is then sent to the treasury address.\n    /// @dev How the percentage is represented in our contracts: 1e18 = 100%, 1e17 = 10%, 1e16 = 1%, 1e15 = 0.1%\n    uint256 private percentFee;\n\n    /// @notice Fee Allo charges for all pools on creation\n    /// @dev This is different from the 'percentFee' in that this is a flat fee and not a percentage. So if you want to create a pool\n    ///      with a base fee of 100 DAI, then you would pass 100 DAI to the 'createPool()' function and the pool would be created\n    ///      with 100 DAI less than the amount you passed to the function. The base fee is sent to the treasury address.\n    uint256 internal baseFee;\n\n    /// @notice Incremental index to track the pools created\n    uint256 private _poolIndex;\n\n    /// @notice Allo treasury\n    address payable private treasury;\n\n    /// @notice Registry contract\n    IRegistry private registry;\n\n    /// @notice Maps the `msg.sender` to a `nonce` to prevent duplicates\n    /// @dev 'msg.sender' -> 'nonce' for cloning strategies\n    mapping(address => uint256) private _nonces;\n\n    /// @notice Maps the pool ID to the pool details\n    /// @dev 'Pool.id' -> 'Pool'\n    mapping(uint256 => Pool) private pools;\n\n    /// @notice Returns a bool for whether a strategy is cloneable or not using the strategy address as the key\n    /// @dev Strategy.address -> bool\n    mapping(address => bool) private cloneableStrategies;\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer\n    /// @param _owner The owner of allo\n    /// @param _registry The address of the registry\n    /// @param _treasury The address of the treasury\n    /// @param _percentFee The percentage fee\n    /// @param _baseFee The base fee\n    function initialize(\n        address _owner,\n        address _registry,\n        address payable _treasury,\n        uint256 _percentFee,\n        uint256 _baseFee\n    ) external reinitializer(1) {\n        // Initialize the owner using Solady ownable library\n        _initializeOwner(_owner);\n\n        // Set the address of the registry\n        _updateRegistry(_registry);\n\n        // Set the address of the treasury\n        _updateTreasury(_treasury);\n\n        // Set the fee percentage\n        _updatePercentFee(_percentFee);\n\n        // Set the base fee\n        _updateBaseFee(_baseFee);\n    }\n\n    // ====================================\n    // =========== Modifier ===============\n    // ====================================\n\n    // Both modifiers below are using OpenZeppelin's AccessControl.sol with custom roles under the hood\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool manager\n    /// @param _poolId The pool id\n    modifier onlyPoolManager(uint256 _poolId) {\n        _checkOnlyPoolManager(_poolId);\n        _;\n    }\n\n    /// @notice Reverts UNAUTHORIZED() if the caller is not a pool admin\n    /// @param _poolId The pool id\n    modifier onlyPoolAdmin(uint256 _poolId) {\n        _checkOnlyPoolAdmin(_poolId);\n        _;\n    }\n\n    //  ====================================\n    //  ==== External/Public Functions =====\n    //  ====================================\n\n    /// @notice Creates a new pool (with a custom strategy)\n    /// @dev 'msg.sender' must be a member or owner of a profile to create a pool with or without a custom strategy, The encoded data\n    ///      will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'. The strategy\n    ///      address passed must not be a cloneable strategy. The strategy address passed must not be the zero address. 'msg.sender' must\n    ///      be a member or owner of the profile id passed as '_profileId'.\n    /// @param _profileId The 'profileId' of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the deployed custom strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token you want to use in your pool\n    /// @param _amount The amount of the token you want to deposit into the pool on initialization\n    /// @param _metadata The 'Metadata' of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)\n    /// @param _managers The managers of the pool, and can be added/removed later by the pool admin\n    /// @return poolId The ID of the pool\n    function createPoolWithCustomStrategy(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable returns (uint256 poolId) {\n        // Revert if the strategy address passed is the zero address with 'ZERO_ADDRESS()'\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        // Revert if we already have this strategy in our cloneable mapping with 'IS_APPROVED_STRATEGY()' (only non-cloneable strategies can be used)\n        if (_isCloneableStrategy(_strategy)) revert IS_APPROVED_STRATEGY();\n\n        // Call the internal '_createPool()' function and return the pool ID\n        return _createPool(_profileId, IStrategy(_strategy), _initStrategyData, _token, _amount, _metadata, _managers);\n    }\n\n    /// @notice Creates a new pool (by cloning a cloneable strategies).\n    /// @dev 'msg.sender' must be owner or member of the profile id passed as '_profileId'.\n    /// @param _profileId The ID of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the strategy contract the pool will use.\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token\n    /// @param _amount The amount of the token\n    /// @param _metadata The metadata of the pool\n    /// @param _managers The managers of the pool\n    /// @custom:initstrategydata The encoded data will be specific to a given strategy requirements,\n    ///    reference the strategy implementation of 'initialize()'\n    function createPool(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable nonReentrant returns (uint256 poolId) {\n        if (!_isCloneableStrategy(_strategy)) {\n            revert NOT_APPROVED_STRATEGY();\n        }\n\n        // Returns the created pool ID\n        return _createPool(\n            _profileId,\n            IStrategy(Clone.createClone(_strategy, _nonces[msg.sender]++)),\n            _initStrategyData,\n            _token,\n            _amount,\n            _metadata,\n            _managers\n        );\n    }\n\n    /// @notice Update pool metadata\n    /// @dev 'msg.sender' must be a pool manager. Emits 'PoolMetadataUpdated()' event.\n    /// @param _poolId ID of the pool\n    /// @param _metadata The new metadata of the pool\n    function updatePoolMetadata(uint256 _poolId, Metadata memory _metadata) external onlyPoolManager(_poolId) {\n        Pool storage pool = pools[_poolId];\n        pool.metadata = _metadata;\n\n        emit PoolMetadataUpdated(_poolId, _metadata);\n    }\n\n    /// @notice Updates the registry address.\n    /// @dev Use this to update the registry address. 'msg.sender' must be Allo owner.\n    /// @param _registry The new registry address\n    function updateRegistry(address _registry) external onlyOwner {\n        _updateRegistry(_registry);\n    }\n\n    /// @notice Updates the treasury address.\n    /// @dev Use this to update the treasury address. 'msg.sender' must be Allo owner.\n    /// @param _treasury The new treasury address\n    function updateTreasury(address payable _treasury) external onlyOwner {\n        _updateTreasury(_treasury);\n    }\n\n    /// @notice Updates the fee percentage.\n    /// @dev Use this to update the fee percentage. 'msg.sender' must be Allo owner.\n    /// @param _percentFee The new fee\n    function updatePercentFee(uint256 _percentFee) external onlyOwner {\n        _updatePercentFee(_percentFee);\n    }\n\n    /// @notice Updates the base fee.\n    /// @dev Use this to update the base fee. 'msg.sender' must be Allo owner.\n    /// @param _baseFee The new base fee\n    function updateBaseFee(uint256 _baseFee) external onlyOwner {\n        _updateBaseFee(_baseFee);\n    }\n\n    /// @notice Add a strategy to the allowlist.\n    /// @dev Emits the 'StrategyApproved()' event. 'msg.sender' must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function addToCloneableStrategies(address _strategy) external onlyOwner {\n        if (_strategy == address(0)) revert ZERO_ADDRESS();\n\n        cloneableStrategies[_strategy] = true;\n        emit StrategyApproved(_strategy);\n    }\n\n    /// @notice Remove a strategy from the allowlist\n    /// @dev Emits 'StrategyRemoved()' event. 'msg.sender must be Allo owner.\n    /// @param _strategy The address of the strategy\n    function removeFromCloneableStrategies(address _strategy) external onlyOwner {\n        // Set the strategy to false in the cloneableStrategies mapping\n        cloneableStrategies[_strategy] = false;\n\n        // Emit the StrategyRemoved event\n        emit StrategyRemoved(_strategy);\n    }\n\n    /// @notice Add a pool manager\n    /// @dev Emits 'RoleGranted()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to add\n    function addPoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        // Reverts if the address is the zero address with 'ZERO_ADDRESS()'\n        if (_manager == address(0)) revert ZERO_ADDRESS();\n\n        // Grants the pool manager role to the '_manager' address\n        _grantRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Remove a pool manager\n    /// @dev Emits 'RoleRevoked()' event. 'msg.sender' must be a pool admin.\n    /// @param _poolId ID of the pool\n    /// @param _manager The address to remove\n    function removePoolManager(uint256 _poolId, address _manager) external onlyPoolAdmin(_poolId) {\n        _revokeRole(pools[_poolId].managerRole, _manager);\n    }\n\n    /// @notice Transfer the funds recovered  to the recipient\n    /// @dev 'msg.sender' must be Allo owner\n    /// @param _token The token to transfer\n    /// @param _recipient The recipient\n    function recoverFunds(address _token, address _recipient) external onlyOwner {\n        // Get the amount of the token to transfer, which is always the entire balance of the contract address\n        uint256 amount = _token == NATIVE ? address(this).balance : IERC20Upgradeable(_token).balanceOf(address(this));\n\n        // Transfer the amount to the recipient (pool owner)\n        _transferAmount(_token, _recipient, amount);\n    }\n\n    // ====================================\n    // ======= Strategy Functions =========\n    // ====================================\n\n    /// @notice Passes _data through to the strategy for that pool.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of registerRecipient().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to a strategy that registerRecipient() requires\n    /// @return recipientId The recipient ID that has been registered\n    function registerRecipient(uint256 _poolId, bytes memory _data) external payable nonReentrant returns (address) {\n        // Return the recipientId (address) from the strategy\n        return pools[_poolId].strategy.registerRecipient{value: msg.value}(_data, msg.sender);\n    }\n\n    /// @notice Register multiple recipients to multiple pools.\n    /// @dev Returns the 'recipientIds' from the strategy that have been registered from calling this function.\n    ///      Encoded data unique to a strategy that registerRecipient() requires. Encoded '_data' length must match\n    ///      '_poolIds' length or this will revert with MISMATCH(). Other requirements will be determined by the strategy.\n    /// @param _poolIds ID's of the pools\n    /// @param _data An array of encoded data unique to a strategy that registerRecipient() requires.\n    /// @return recipientIds The recipient IDs that have been registered\n    function batchRegisterRecipient(uint256[] memory _poolIds, bytes[] memory _data)\n        external\n        nonReentrant\n        returns (address[] memory recipientIds)\n    {\n        uint256 poolIdLength = _poolIds.length;\n        recipientIds = new address[](poolIdLength);\n\n        if (poolIdLength != _data.length) revert MISMATCH();\n\n        // Loop through the '_poolIds' & '_data' and call the 'strategy.registerRecipient()' function\n        for (uint256 i; i < poolIdLength;) {\n            recipientIds[i] = pools[_poolIds[i]].strategy.registerRecipient(_data[i], msg.sender);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return the recipientIds that have been registered\n        return recipientIds;\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Anyone can fund a pool and call this function.\n    /// @param _poolId ID of the pool\n    /// @param _amount The amount to be deposited into the pool\n    function fundPool(uint256 _poolId, uint256 _amount) external payable nonReentrant {\n        // if amount is 0, revert with 'NOT_ENOUGH_FUNDS()' error\n        if (_amount == 0) revert NOT_ENOUGH_FUNDS();\n\n        Pool memory pool = pools[_poolId];\n        if (pool.token == NATIVE && _amount != msg.value) revert NOT_ENOUGH_FUNDS();\n\n        // Call the internal fundPool() function\n        _fundPool(_amount, _poolId, pool.strategy);\n    }\n\n    /// @notice Allocate to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate().\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function allocate(uint256 _poolId, bytes memory _data) external payable nonReentrant {\n        _allocate(_poolId, _data);\n    }\n\n    /// @notice Allocate to multiple pools\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of allocate(). Please note that this is not a 'payable' function, so if you\n    ///      want to send funds to the strategy, you must send the funds using 'fundPool()'.\n    /// @param _poolIds IDs of the pools\n    /// @param _datas encoded data unique to the strategy for that pool\n    function batchAllocate(uint256[] calldata _poolIds, bytes[] memory _datas) external nonReentrant {\n        uint256 numPools = _poolIds.length;\n\n        // Reverts if the length of _poolIds does not match the length of _datas with 'MISMATCH()' error\n        if (numPools != _datas.length) revert MISMATCH();\n\n        // Loop through the _poolIds & _datas and call the internal _allocate() function\n        for (uint256 i; i < numPools;) {\n            _allocate(_poolIds[i], _datas[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Distribute to a recipient or multiple recipients.\n    /// @dev The encoded data will be specific to a given strategy requirements, reference the strategy\n    ///      implementation of 'strategy.distribute()'.\n    /// @param _poolId ID of the pool\n    /// @param _recipientIds Ids of the recipients of the distribution\n    /// @param _data Encoded data unique to the strategy\n    function distribute(uint256 _poolId, address[] memory _recipientIds, bytes memory _data) external nonReentrant {\n        pools[_poolId].strategy.distribute(_recipientIds, _data, msg.sender);\n    }\n\n    /// ====================================\n    /// ======= Internal Functions =========\n    /// ====================================\n\n    /// @notice Internal function to check is caller is pool manager\n    /// @param _poolId The pool id\n    function _checkOnlyPoolManager(uint256 _poolId) internal view {\n        if (!_isPoolManager(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Internal function to check is caller is pool admin\n    /// @param _poolId The pool id\n    function _checkOnlyPoolAdmin(uint256 _poolId) internal view {\n        if (!_isPoolAdmin(_poolId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Creates a new pool.\n    /// @dev This is an internal function that is called by the 'createPool()' & 'createPoolWithCustomStrategy()' functions\n    ///      It is used to create a new pool and is called by both functions. The 'msg.sender' must be a member or owner of\n    ///      a profile to create a pool.\n    /// @param _profileId The ID of the profile of for pool creator in the registry\n    /// @param _strategy The address of strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token that the pool is denominated in\n    /// @param _amount The amount of the token to be deposited into the pool\n    /// @param _metadata The 'Metadata' of the pool\n    /// @param _managers The managers of the pool\n    /// @return poolId The ID of the pool\n    function _createPool(\n        bytes32 _profileId,\n        IStrategy _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) internal returns (uint256 poolId) {\n        if (!registry.isOwnerOrMemberOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n\n        poolId = ++_poolIndex;\n\n        // Generate the manager & admin roles for the pool (this is the way we do this throughout the protocol for consistency)\n        bytes32 POOL_MANAGER_ROLE = bytes32(poolId);\n        bytes32 POOL_ADMIN_ROLE = keccak256(abi.encodePacked(poolId, \"admin\"));\n\n        // Create the Pool instance\n        Pool memory pool = Pool({\n            profileId: _profileId,\n            strategy: _strategy,\n            metadata: _metadata,\n            token: _token,\n            managerRole: POOL_MANAGER_ROLE,\n            adminRole: POOL_ADMIN_ROLE\n        });\n\n        // Add the pool to the mapping of created pools\n        pools[poolId] = pool;\n\n        // Grant admin roles to the pool creator\n        _grantRole(POOL_ADMIN_ROLE, msg.sender);\n\n        // Set admin role for POOL_MANAGER_ROLE\n        _setRoleAdmin(POOL_MANAGER_ROLE, POOL_ADMIN_ROLE);\n\n        // initialize strategies\n        // Initialization is expected to revert when invoked more than once with 'ALREADY_INITIALIZED()' error\n        _strategy.initialize(poolId, _initStrategyData);\n\n        if (_strategy.getPoolId() != poolId || address(_strategy.getAllo()) != address(this)) revert MISMATCH();\n\n        // grant pool managers roles\n        uint256 managersLength = _managers.length;\n        for (uint256 i; i < managersLength;) {\n            address manager = _managers[i];\n            if (manager == address(0)) revert ZERO_ADDRESS();\n\n            _grantRole(POOL_MANAGER_ROLE, manager);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (baseFee > 0) {\n            // To prevent paying the baseFee from the Allo contract's balance\n            // If _token is NATIVE, then baseFee + _amount should be > than msg.value.\n            // If _token is not NATIVE, then baseFee should be > than msg.value.\n            if ((_token == NATIVE && (baseFee + _amount != msg.value)) || (_token != NATIVE && baseFee != msg.value)) {\n                revert NOT_ENOUGH_FUNDS();\n            }\n            _transferAmount(NATIVE, treasury, baseFee);\n            emit BaseFeePaid(poolId, baseFee);\n        }\n\n        if (_amount > 0) {\n            _fundPool(_amount, poolId, _strategy);\n        }\n\n        emit PoolCreated(poolId, _profileId, _strategy, _token, _amount, _metadata);\n    }\n\n    /// @notice Allocate to recipient(s).\n    /// @dev Passes '_data' & 'msg.sender' through to the strategy for that pool.\n    ///      This is an internal function that is called by the 'allocate()' & 'batchAllocate()' functions.\n    /// @param _poolId ID of the pool\n    /// @param _data Encoded data unique to the strategy for that pool\n    function _allocate(uint256 _poolId, bytes memory _data) internal {\n        pools[_poolId].strategy.allocate{value: msg.value}(_data, msg.sender);\n    }\n\n    /// @notice Fund a pool.\n    /// @dev Deducts the fee and transfers the amount to the distribution strategy.\n    ///      Emits a 'PoolFunded' event.\n    /// @param _amount The amount to transfer\n    /// @param _poolId The 'poolId' for the pool you are funding\n    /// @param _strategy The address of the strategy\n    function _fundPool(uint256 _amount, uint256 _poolId, IStrategy _strategy) internal {\n        uint256 feeAmount;\n        uint256 amountAfterFee = _amount;\n\n        Pool storage pool = pools[_poolId];\n        address _token = pool.token;\n\n        if (percentFee > 0) {\n            feeAmount = (_amount * percentFee) / getFeeDenominator();\n            amountAfterFee -= feeAmount;\n\n            if (feeAmount + amountAfterFee != _amount) revert INVALID();\n\n            if (_token == NATIVE) {\n                _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n            } else {\n                uint256 balanceBeforeFee = _getBalance(_token, treasury);\n                _transferAmountFrom(_token, TransferData({from: msg.sender, to: treasury, amount: feeAmount}));\n                uint256 balanceAfterFee = _getBalance(_token, treasury);\n                // Track actual fee paid to account for fee on ERC20 token transfers\n                feeAmount = balanceAfterFee - balanceBeforeFee;\n            }\n        }\n\n        if (_token == NATIVE) {\n            _transferAmountFrom(\n                _token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee})\n            );\n        } else {\n            uint256 balanceBeforeFundingPool = _getBalance(_token, address(_strategy));\n            _transferAmountFrom(\n                _token, TransferData({from: msg.sender, to: address(_strategy), amount: amountAfterFee})\n            );\n            uint256 balanceAfterFundingPool = _getBalance(_token, address(_strategy));\n            // Track actual fee paid to account for fee on ERC20 token transfers\n            amountAfterFee = balanceAfterFundingPool - balanceBeforeFundingPool;\n        }\n\n        _strategy.increasePoolAmount(amountAfterFee);\n\n        emit PoolFunded(_poolId, amountAfterFee, feeAmount);\n    }\n\n    /// @notice Checks if the strategy is an approved cloneable strategy.\n    /// @dev Internal function used by createPoolwithCustomStrategy and createPool to\n    ///      determine if a strategy is in the cloneable strategy allow list.\n    /// @param _strategy The address of the strategy\n    /// @return This will return 'true' if the strategy is cloneable, otherwise 'false'\n    function _isCloneableStrategy(address _strategy) internal view returns (bool) {\n        return cloneableStrategies[_strategy];\n    }\n\n    /// @notice Checks if the address is a pool admin\n    /// @dev Internal function used to determine if an address is a pool admin\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool admin, otherwise 'false'\n    function _isPoolAdmin(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].adminRole, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @dev Internal function used to determine if an address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return This will return 'true' if the address is a pool manager, otherwise 'false'\n    function _isPoolManager(uint256 _poolId, address _address) internal view returns (bool) {\n        return hasRole(pools[_poolId].managerRole, _address) || _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Updates the registry address\n    /// @dev Internal function used to update the registry address.\n    ///      Emits a RegistryUpdated event.\n    /// @param _registry The new registry address\n    function _updateRegistry(address _registry) internal {\n        if (_registry == address(0)) revert ZERO_ADDRESS();\n\n        registry = IRegistry(_registry);\n        emit RegistryUpdated(_registry);\n    }\n\n    /// @notice Updates the treasury address\n    /// @dev Internal function used to update the treasury address.\n    ///      Emits a TreasuryUpdated event.\n    /// @param _treasury The new treasury address\n    function _updateTreasury(address payable _treasury) internal {\n        if (_treasury == address(0)) revert ZERO_ADDRESS();\n\n        treasury = _treasury;\n        emit TreasuryUpdated(treasury);\n    }\n\n    /// @notice Updates the fee percentage\n    /// @dev Internal function used to update the percentage fee.\n    ///      Emits a PercentFeeUpdated event.\n    /// @param _percentFee The new fee\n    function _updatePercentFee(uint256 _percentFee) internal {\n        if (_percentFee > 1e18) revert INVALID_FEE();\n\n        percentFee = _percentFee;\n\n        emit PercentFeeUpdated(percentFee);\n    }\n\n    /// @notice Updates the base fee\n    /// @dev Internal function used to update the base fee.\n    ///      Emits a BaseFeeUpdated event.\n    /// @param _baseFee The new base fee\n    function _updateBaseFee(uint256 _baseFee) internal {\n        baseFee = _baseFee;\n\n        emit BaseFeeUpdated(baseFee);\n    }\n\n    // =========================\n    // ==== View Functions =====\n    // =========================\n\n    /// @notice Getter for the fee denominator\n    /// @return FEE_DENOMINATOR The fee denominator is (1e18) which represents 100%\n    function getFeeDenominator() public pure returns (uint256 FEE_DENOMINATOR) {\n        return 1e18;\n    }\n\n    /// @notice Checks if the address is a pool admin.\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool admin, otherwise 'false'\n    function isPoolAdmin(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolAdmin(_poolId, _address);\n    }\n\n    /// @notice Checks if the address is a pool manager\n    /// @param _poolId The ID of the pool\n    /// @param _address The address to check\n    /// @return 'true' if the address is a pool manager, otherwise 'false'\n    function isPoolManager(uint256 _poolId, address _address) external view returns (bool) {\n        return _isPoolManager(_poolId, _address);\n    }\n\n    /// @notice Getter for the strategy.\n    /// @param _poolId The ID of the pool\n    /// @return The address of the strategy\n    function getStrategy(uint256 _poolId) external view returns (address) {\n        return address(pools[_poolId].strategy);\n    }\n\n    /// @notice Getter for fee percentage.\n    /// @return The fee percentage (1e18 = 100%)\n    function getPercentFee() external view returns (uint256) {\n        return percentFee;\n    }\n\n    /// @notice Getter for base fee.\n    /// @return The base fee\n    function getBaseFee() external view returns (uint256) {\n        return baseFee;\n    }\n\n    /// @notice Getter for treasury address.\n    /// @return The treasury address\n    function getTreasury() external view returns (address payable) {\n        return treasury;\n    }\n\n    /// @notice Getter for registry.\n    /// @return The registry address\n    function getRegistry() external view returns (IRegistry) {\n        return registry;\n    }\n\n    /// @notice Getter for if strategy is cloneable.\n    /// @param _strategy The address of the strategy\n    /// @return 'true' if the strategy is cloneable, otherwise 'false'\n    function isCloneableStrategy(address _strategy) external view returns (bool) {\n        return _isCloneableStrategy(_strategy);\n    }\n\n    /// @notice Getter for the 'Pool'.\n    /// @param _poolId The ID of the pool\n    /// @return The 'Pool' struct\n    function getPool(uint256 _poolId) external view returns (Pool memory) {\n        return pools[_poolId];\n    }\n}\n"
    },
    "contracts/core/Anchor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\n// Core Contracts\nimport {Registry} from \"./Registry.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Anchor contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Anchors are associated with profiles and are accessible exclusively by the profile owner. This contract ensures secure\n///         and authorized interaction with external addresses, enhancing the capabilities of profiles and enabling controlled\n///         execution of operations. The contract leverages the `Registry` contract for ownership verification and access control.\ncontract Anchor is ERC721Holder, ERC1155Holder {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice The registry contract on any given network/chain\n    Registry public immutable registry;\n\n    /// @notice The profileId of the allowed profile to execute calls\n    bytes32 public immutable profileId;\n\n    /// ==========================\n    /// ======== Errors ==========\n    /// ==========================\n\n    /// @notice Throws when the caller is not the owner of the profile\n    error UNAUTHORIZED();\n\n    /// @notice Throws when the call to the target address fails\n    error CALL_FAILED();\n\n    /// ==========================\n    /// ======= Constructor ======\n    /// ==========================\n\n    /// @notice Constructor\n    /// @dev We create an instance of the 'Registry' contract using the 'msg.sender' and set the profileId.\n    /// @param _profileId The ID of the allowed profile to execute calls\n    constructor(bytes32 _profileId, address _registry) {\n        registry = Registry(_registry);\n        profileId = _profileId;\n    }\n\n    /// ==========================\n    /// ======== External ========\n    /// ==========================\n\n    /// @notice Execute a call to a target address\n    /// @dev 'msg.sender' must be profile owner\n    /// @param _target The target address to call\n    /// @param _value The amount of native token to send\n    /// @param _data The data to send to the target address\n    /// @return Data returned from the target address\n    function execute(address _target, uint256 _value, bytes memory _data) external returns (bytes memory) {\n        // Check if the caller is the owner of the profile and revert if not\n        if (!registry.isOwnerOfProfile(profileId, msg.sender)) revert UNAUTHORIZED();\n\n        // Check if the target address is the zero address and revert if it is\n        if (_target == address(0)) revert CALL_FAILED();\n\n        // Call the target address and return the data\n        (bool success, bytes memory data) = _target.call{value: _value}(_data);\n\n        // Check if the call was successful and revert if not\n        if (!success) revert CALL_FAILED();\n\n        return data;\n    }\n\n    /// @notice This contract should be able to receive native token\n    receive() external payable {}\n}\n"
    },
    "contracts/core/interfaces/IAllo.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\n// Interfaces\nimport {IRegistry} from \"./IRegistry.sol\";\nimport {IStrategy} from \"./IStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Allo Interface\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Interface for the Allo contract. It exposes all functions needed to use the Allo protocol.\ninterface IAllo {\n    /// ======================\n    /// ======= Structs ======\n    /// ======================\n\n    /// @notice the Pool struct that all strategy pools are based from\n    struct Pool {\n        bytes32 profileId;\n        IStrategy strategy;\n        address token;\n        Metadata metadata;\n        bytes32 managerRole;\n        bytes32 adminRole;\n    }\n\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Event emitted when a new pool is created\n    /// @param poolId ID of the pool created\n    /// @param profileId ID of the profile the pool is associated with\n    /// @param strategy Address of the strategy contract\n    /// @param token Address of the token pool was funded with when created\n    /// @param amount Amount pool was funded with when created\n    /// @param metadata Pool metadata\n    event PoolCreated(\n        uint256 indexed poolId,\n        bytes32 indexed profileId,\n        IStrategy strategy,\n        address token,\n        uint256 amount,\n        Metadata metadata\n    );\n\n    /// @notice Emitted when a pools metadata is updated\n    /// @param poolId ID of the pool updated\n    /// @param metadata Pool metadata that was updated\n    event PoolMetadataUpdated(uint256 indexed poolId, Metadata metadata);\n\n    /// @notice Emitted when a pool is funded\n    /// @param poolId ID of the pool funded\n    /// @param amount Amount funded to the pool\n    /// @param fee Amount of the fee paid to the treasury\n    event PoolFunded(uint256 indexed poolId, uint256 amount, uint256 fee);\n\n    /// @notice Emitted when the base fee is paid\n    /// @param poolId ID of the pool the base fee was paid for\n    /// @param amount Amount of the base fee paid\n    event BaseFeePaid(uint256 indexed poolId, uint256 amount);\n\n    /// @notice Emitted when the treasury address is updated\n    /// @param treasury Address of the new treasury\n    event TreasuryUpdated(address treasury);\n\n    /// @notice Emitted when the percent fee is updated\n    /// @param percentFee New percentage for the fee\n    event PercentFeeUpdated(uint256 percentFee);\n\n    /// @notice Emitted when the base fee is updated\n    /// @param baseFee New base fee amount\n    event BaseFeeUpdated(uint256 baseFee);\n\n    /// @notice Emitted when the registry address is updated\n    /// @param registry Address of the new registry\n    event RegistryUpdated(address registry);\n\n    /// @notice Emitted when a strategy is approved and added to the cloneable strategies\n    /// @param strategy Address of the strategy approved\n    event StrategyApproved(address strategy);\n\n    /// @notice Emitted when a strategy is removed from the cloneable strategies\n    /// @param strategy Address of the strategy removed\n    event StrategyRemoved(address strategy);\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Initialize the Allo contract\n    /// @param _owner Address of the owner\n    /// @param _registry Address of the registry contract\n    /// @param _treasury Address of the treasury\n    /// @param _percentFee Percentage for the fee\n    /// @param _baseFee Base fee amount\n    function initialize(\n        address _owner,\n        address _registry,\n        address payable _treasury,\n        uint256 _percentFee,\n        uint256 _baseFee\n    ) external;\n\n    /// @notice Creates a new pool (with a custom strategy)\n    /// @dev 'msg.sender' must be a member or owner of a profile to create a pool with or without a custom strategy, The encoded data\n    ///      will be specific to a given strategy requirements, reference the strategy implementation of 'initialize()'. The strategy\n    ///      address passed must not be a cloneable strategy. The strategy address passed must not be the zero address. 'msg.sender' must\n    ///      be a member or owner of the profile id passed as '_profileId'.\n    /// @param _profileId The 'profileId' of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the deployed custom strategy\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token you want to use in your pool\n    /// @param _amount The amount of the token you want to deposit into the pool on initialization\n    /// @param _metadata The 'Metadata' of the pool, this uses our 'Meatdata.sol' struct (consistent throughout the protocol)\n    /// @param _managers The managers of the pool, and can be added/removed later by the pool admin\n    /// @return poolId The ID of the pool\n    function createPoolWithCustomStrategy(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable returns (uint256 poolId);\n\n    /// @notice Creates a new pool (by cloning a cloneable strategies).\n    /// @dev 'msg.sender' must be owner or member of the profile id passed as '_profileId'.\n    /// @param _profileId The ID of the registry profile, used to check if 'msg.sender' is a member or owner of the profile\n    /// @param _strategy The address of the strategy contract the pool will use.\n    /// @param _initStrategyData The data to initialize the strategy\n    /// @param _token The address of the token\n    /// @param _amount The amount of the token\n    /// @param _metadata The metadata of the pool\n    /// @param _managers The managers of the pool\n    /// @custom:initstrategydata The encoded data will be specific to a given strategy requirements,\n    ///    reference the strategy implementation of 'initialize()'\n    function createPool(\n        bytes32 _profileId,\n        address _strategy,\n        bytes memory _initStrategyData,\n        address _token,\n        uint256 _amount,\n        Metadata memory _metadata,\n        address[] memory _managers\n    ) external payable returns (uint256 poolId);\n\n    /// @notice Updates a pools metadata.\n    /// @dev 'msg.sender' must be a pool admin.\n    /// @param _poolId The ID of the pool to update\n    /// @param _metadata The new metadata to set\n    function updatePoolMetadata(uint256 _poolId, Metadata memory _metadata) external;\n\n    /// @notice Update the registry address.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _registry The new registry address\n    function updateRegistry(address _registry) external;\n\n    /// @notice Updates the treasury address.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _treasury The new treasury address\n    function updateTreasury(address payable _treasury) external;\n\n    /// @notice Updates the percentage for the fee.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _percentFee The new percentage for the fee\n    function updatePercentFee(uint256 _percentFee) external;\n\n    /// @notice Updates the base fee.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _baseFee The new base fee\n    function updateBaseFee(uint256 _baseFee) external;\n\n    /// @notice Adds a strategy to the cloneable strategies.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _strategy The address of the strategy to add\n    function addToCloneableStrategies(address _strategy) external;\n\n    /// @notice Removes a strategy from the cloneable strategies.\n    /// @dev 'msg.sender' must be the Allo contract owner.\n    /// @param _strategy The address of the strategy to remove\n    function removeFromCloneableStrategies(address _strategy) external;\n\n    /// @notice Adds a pool manager to the pool.\n    /// @dev 'msg.sender' must be a pool admin.\n    /// @param _poolId The ID of the pool to add the manager to\n    /// @param _manager The address of the manager to add\n    function addPoolManager(uint256 _poolId, address _manager) external;\n\n    /// @notice Removes a pool manager from the pool.\n    /// @dev 'msg.sender' must be a pool admin.\n    /// @param _poolId The ID of the pool to remove the manager from\n    /// @param _manager The address of the manager to remove\n    function removePoolManager(uint256 _poolId, address _manager) external;\n\n    /// @notice Recovers funds from a pool.\n    /// @dev 'msg.sender' must be a pool admin.\n    /// @param _token The token to recover\n    /// @param _recipient The address to send the recovered funds to\n    function recoverFunds(address _token, address _recipient) external;\n\n    /// @notice Registers a recipient and emits {Registered} event if successful and may be handled differently by each strategy.\n    /// @param _poolId The ID of the pool to register the recipient for\n    function registerRecipient(uint256 _poolId, bytes memory _data) external payable returns (address);\n\n    /// @notice Registers a batch of recipients.\n    /// @param _poolIds The pool ID's to register the recipients for\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy\n    function batchRegisterRecipient(uint256[] memory _poolIds, bytes[] memory _data)\n        external\n        returns (address[] memory);\n\n    /// @notice Funds a pool.\n    /// @dev 'msg.value' must be greater than 0 if the token is the native token\n    ///       or '_amount' must be greater than 0 if the token is not the native token.\n    /// @param _poolId The ID of the pool to fund\n    /// @param _amount The amount to fund the pool with\n    function fundPool(uint256 _poolId, uint256 _amount) external payable;\n\n    /// @notice Allocates funds to a recipient.\n    /// @dev Each strategy will handle the allocation of funds differently.\n    /// @param _poolId The ID of the pool to allocate funds from\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy.\n    function allocate(uint256 _poolId, bytes memory _data) external payable;\n\n    /// @notice Allocates funds to multiple recipients.\n    /// @dev Each strategy will handle the allocation of funds differently\n    function batchAllocate(uint256[] calldata _poolIds, bytes[] memory _datas) external;\n\n    /// @notice Distributes funds to recipients and emits {Distributed} event if successful\n    /// @dev Each strategy will handle the distribution of funds differently\n    /// @param _poolId The ID of the pool to distribute from\n    /// @param _recipientIds The recipient ids to distribute to\n    /// @param _data The data to pass to the strategy and may be handled differently by each strategy\n    function distribute(uint256 _poolId, address[] memory _recipientIds, bytes memory _data) external;\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Checks if an address is a pool admin.\n    /// @param _poolId The ID of the pool to check\n    /// @param _address The address to check\n    /// @return 'true' if the '_address' is a pool admin, otherwise 'false'\n    function isPoolAdmin(uint256 _poolId, address _address) external view returns (bool);\n\n    /// @notice Checks if an address is a pool manager.\n    /// @param _poolId The ID of the pool to check\n    /// @param _address The address to check\n    /// @return 'true' if the '_address' is a pool manager, otherwise 'false'\n    function isPoolManager(uint256 _poolId, address _address) external view returns (bool);\n\n    /// @notice Checks if a strategy is cloneable (is in the cloneableStrategies mapping).\n    /// @param _strategy The address of the strategy to check\n    /// @return 'true' if the '_strategy' is cloneable, otherwise 'false'\n    function isCloneableStrategy(address _strategy) external view returns (bool);\n\n    /// @notice Returns the address of the strategy for a given 'poolId'\n    /// @param _poolId The ID of the pool to check\n    /// @return strategy The address of the strategy for the ID of the pool passed in\n    function getStrategy(uint256 _poolId) external view returns (address);\n\n    /// @notice Returns the current percent fee\n    /// @return percentFee The current percentage for the fee\n    function getPercentFee() external view returns (uint256);\n\n    /// @notice Returns the current base fee\n    /// @return baseFee The current base fee\n    function getBaseFee() external view returns (uint256);\n\n    /// @notice Returns the current treasury address\n    /// @return treasury The current treasury address\n    function getTreasury() external view returns (address payable);\n\n    /// @notice Returns the current registry address\n    /// @return registry The current registry address\n    function getRegistry() external view returns (IRegistry);\n\n    /// @notice Returns the 'Pool' struct for a given 'poolId'\n    /// @param _poolId The ID of the pool to check\n    /// @return pool The 'Pool' struct for the ID of the pool passed in\n    function getPool(uint256 _poolId) external view returns (Pool memory);\n\n    /// @notice Returns the current fee denominator\n    /// @dev 1e18 represents 100%\n    /// @return feeDenominator The current fee denominator\n    function getFeeDenominator() external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Internal Libraries\nimport {Metadata} from \"../libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title IRegistry Interface\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Interface for the Registry contract and exposes all functions needed to use the Registry\n///         within the Allo protocol.\n/// @dev The Registry Interface is used to interact with the Allo protocol and create profiles\n///      that can be used to interact with the Allo protocol. The Registry is the main contract\n///      that all other contracts interact with to get the 'Profile' information needed to\n///      interact with the Allo protocol. The Registry is also used to create new profiles\n///      and update existing profiles. The Registry is also used to add and remove members\n///      from a profile. The Registry will not always be used in a strategy and will depend on\n///      the strategy being used.\ninterface IRegistry {\n    /// ======================\n    /// ======= Structs ======\n    /// ======================\n\n    /// @dev The Profile struct that all profiles are based from\n    struct Profile {\n        bytes32 id;\n        uint256 nonce;\n        string name;\n        Metadata metadata;\n        address owner;\n        address anchor;\n    }\n\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @dev Emitted when a profile is created. This will return your anchor address.\n    event ProfileCreated(\n        bytes32 indexed profileId, uint256 nonce, string name, Metadata metadata, address owner, address anchor\n    );\n\n    /// @dev Emitted when a profile name is updated. This will update the anchor when the name is updated and return it.\n    event ProfileNameUpdated(bytes32 indexed profileId, string name, address anchor);\n\n    /// @dev Emitted when a profile's metadata is updated.\n    event ProfileMetadataUpdated(bytes32 indexed profileId, Metadata metadata);\n\n    /// @dev Emitted when a profile owner is updated.\n    event ProfileOwnerUpdated(bytes32 indexed profileId, address owner);\n\n    /// @dev Emitted when a profile pending owner is updated.\n    event ProfilePendingOwnerUpdated(bytes32 indexed profileId, address pendingOwner);\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @dev Returns the 'Profile' for a '_profileId' passed\n    /// @param _profileId The 'profileId' to return the 'Profile' for\n    /// @return profile The 'Profile' for the '_profileId' passed\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory profile);\n\n    /// @dev Returns the 'Profile' for an '_anchor' passed\n    /// @param _anchor The 'anchor' to return the 'Profile' for\n    /// @return profile The 'Profile' for the '_anchor' passed\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory profile);\n\n    /// @dev Returns a boolean if the '_account' is a member or owner of the '_profileId' passed in\n    /// @param _profileId The 'profileId' to check if the '_account' is a member or owner of\n    /// @param _account The 'account' to check if they are a member or owner of the '_profileId' passed in\n    /// @return isOwnerOrMemberOfProfile A boolean if the '_account' is a member or owner of the '_profileId' passed in\n    function isOwnerOrMemberOfProfile(bytes32 _profileId, address _account)\n        external\n        view\n        returns (bool isOwnerOrMemberOfProfile);\n\n    /// @dev Returns a boolean if the '_account' is an owner of the '_profileId' passed in\n    /// @param _profileId The 'profileId' to check if the '_account' is an owner of\n    /// @param _owner The 'owner' to check if they are an owner of the '_profileId' passed in\n    /// @return isOwnerOfProfile A boolean if the '_account' is an owner of the '_profileId' passed in\n    function isOwnerOfProfile(bytes32 _profileId, address _owner) external view returns (bool isOwnerOfProfile);\n\n    /// @dev Returns a boolean if the '_account' is a member of the '_profileId' passed in\n    /// @param _profileId The 'profileId' to check if the '_account' is a member of\n    /// @param _member The 'member' to check if they are a member of the '_profileId' passed in\n    /// @return isMemberOfProfile A boolean if the '_account' is a member of the '_profileId' passed in\n    function isMemberOfProfile(bytes32 _profileId, address _member) external view returns (bool isMemberOfProfile);\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @dev Creates a new 'Profile' and returns the 'profileId' of the new profile\n    ///\n    /// Note: The 'name' and 'nonce' are used to generate the 'anchor' address\n    ///\n    /// Requirements: None, anyone can create a new profile\n    ///\n    /// @param _nonce The nonce to use to generate the 'anchor' address\n    /// @param _name The name to use to generate the 'anchor' address\n    /// @param _metadata The 'Metadata' to use to generate the 'anchor' address\n    /// @param _owner The 'owner' to use to generate the 'anchor' address\n    /// @param _members The 'members' to use to generate the 'anchor' address\n    /// @return profileId The 'profileId' of the new profile\n    function createProfile(\n        uint256 _nonce,\n        string memory _name,\n        Metadata memory _metadata,\n        address _owner,\n        address[] memory _members\n    ) external returns (bytes32 profileId);\n\n    /// @dev Updates the 'name' of the '_profileId' passed in and returns the new 'anchor' address\n    ///\n    /// Requirements: Only the 'Profile' owner can update the name\n    ///\n    /// Note: The 'name' and 'nonce' are used to generate the 'anchor' address and this will update the 'anchor'\n    ///       so please use caution. You can always recreate your 'anchor' address by updating the name back\n    ///       to the original name used to create the profile.\n    ///\n    /// @param _profileId The 'profileId' to update the name for\n    /// @param _name The new 'name' value\n    /// @return anchor The new 'anchor' address\n    function updateProfileName(bytes32 _profileId, string memory _name) external returns (address anchor);\n\n    /// @dev Updates the 'Metadata' of the '_profileId' passed in\n    ///\n    /// Requirements: Only the 'Profile' owner can update the metadata\n    ///\n    /// @param _profileId The 'profileId' to update the metadata for\n    /// @param _metadata The new 'Metadata' value\n    function updateProfileMetadata(bytes32 _profileId, Metadata memory _metadata) external;\n\n    /// @dev Updates the pending 'owner' of the '_profileId' passed in\n    ///\n    /// Requirements: Only the 'Profile' owner can update the pending owner\n    ///\n    /// @param _profileId The 'profileId' to update the pending owner for\n    /// @param _pendingOwner The new pending 'owner' value\n    function updateProfilePendingOwner(bytes32 _profileId, address _pendingOwner) external;\n\n    /// @dev Accepts the pending 'owner' of the '_profileId' passed in\n    ///\n    /// Requirements: Only the pending owner can accept the ownership\n    ///\n    /// @param _profileId The 'profileId' to accept the ownership for\n    function acceptProfileOwnership(bytes32 _profileId) external;\n\n    /// @dev Adds members to the '_profileId' passed in\n    ///\n    /// Requirements: Only the 'Profile' owner can add members\n    ///\n    /// @param _profileId The 'profileId' to add members to\n    /// @param _members The members to add to the '_profileId' passed in\n    function addMembers(bytes32 _profileId, address[] memory _members) external;\n\n    /// @dev Removes members from the '_profileId' passed in\n    ///\n    /// Requirements: Only the 'Profile' owner can remove members\n    ///\n    /// @param _profileId The 'profileId' to remove members from\n    /// @param _members The members to remove from the '_profileId' passed in\n    function removeMembers(bytes32 _profileId, address[] memory _members) external;\n\n    /// @dev Recovers funds from the contract\n    ///\n    /// Requirements: Must be the Allo owner\n    ///\n    /// @param _token The token you want to use to recover funds\n    /// @param _recipient The recipient of the recovered funds\n    function recoverFunds(address _token, address _recipient) external;\n}\n"
    },
    "contracts/core/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\n// Interfaces\nimport {IAllo} from \"./IAllo.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title IStrategy Interface\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co> @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice BaseStrategy is the base contract that all strategies should inherit from and uses this interface.\n\ninterface IStrategy {\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The Status enum that all recipients are based from\n    enum Status {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed,\n        InReview,\n        Canceled\n    }\n\n    /// @notice Payout summary struct to hold the payout data\n    struct PayoutSummary {\n        address recipientAddress;\n        uint256 amount;\n    }\n\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when strategy is initialized.\n    /// @param poolId The ID of the pool\n    /// @param data The data passed to the 'initialize' function\n    event Initialized(uint256 poolId, bytes data);\n\n    /// @notice Emitted when a recipient is registered.\n    /// @param recipientId The ID of the recipient\n    /// @param data The data passed to the 'registerRecipient' function\n    /// @param sender The sender\n    event Registered(address indexed recipientId, bytes data, address sender);\n\n    /// @notice Emitted when a recipient is allocated to.\n    /// @param recipientId The ID of the recipient\n    /// @param amount The amount allocated\n    /// @param token The token allocated\n    event Allocated(address indexed recipientId, uint256 amount, address token, address sender);\n\n    /// @notice Emitted when tokens are distributed.\n    /// @param recipientId The ID of the recipient\n    /// @param recipientAddress The recipient\n    /// @param amount The amount distributed\n    /// @param sender The sender\n    event Distributed(address indexed recipientId, address recipientAddress, uint256 amount, address sender);\n\n    /// @notice Emitted when pool is set to active status.\n    /// @param active The status of the pool\n    event PoolActive(bool active);\n\n    /// ======================\n    /// ======= Views ========\n    /// ======================\n\n    /// @notice Getter for the address of the Allo contract.\n    /// @return The 'Allo' contract\n    function getAllo() external view returns (IAllo);\n\n    /// @notice Getter for the 'poolId' for this strategy.\n    /// @return The ID of the pool\n    function getPoolId() external view returns (uint256);\n\n    /// @notice Getter for the 'id' of the strategy.\n    /// @return The ID of the strategy\n    function getStrategyId() external view returns (bytes32);\n\n    /// @notice Checks whether a allocator is valid or not, will usually be true for all strategies\n    ///      and will depend on the strategy implementation.\n    /// @param _allocator The allocator to check\n    /// @return Whether the allocator is valid or not\n    function isValidAllocator(address _allocator) external view returns (bool);\n\n    /// @notice whether pool is active.\n    /// @return Whether the pool is active or not\n    function isPoolActive() external returns (bool);\n\n    /// @notice Checks the amount of tokens in the pool.\n    /// @return The balance of the pool\n    function getPoolAmount() external view returns (uint256);\n\n    /// @notice Increases the balance of the pool.\n    /// @param _amount The amount to increase the pool by\n    function increasePoolAmount(uint256 _amount) external;\n\n    /// @notice Checks the status of a recipient probably tracked in a mapping, but will depend on the implementation\n    ///      for example, the OpenSelfRegistration only maps users to bool, and then assumes Accepted for those\n    ///      since there is no need for Pending or Rejected.\n    /// @param _recipientId The ID of the recipient\n    /// @return The status of the recipient\n    function getRecipientStatus(address _recipientId) external view returns (Status);\n\n    /// @notice Checks the amount allocated to a recipient for distribution.\n    /// @dev Input the values you would send to distribute(), get the amounts each recipient in the array would receive.\n    ///      The encoded '_data' will be determined by the strategy, and will be used to determine the payout.\n    /// @param _recipientIds The IDs of the recipients\n    /// @param _data The encoded data\n    function getPayouts(address[] memory _recipientIds, bytes[] memory _data)\n        external\n        view\n        returns (PayoutSummary[] memory);\n\n    /// ======================\n    /// ===== Functions ======\n    /// ======================\n\n    /// @notice\n    /// @dev The default BaseStrategy version will not use the data  if a strategy wants to use it, they will overwrite it,\n    ///      use it, and then call super.initialize().\n    /// @param _poolId The ID of the pool\n    /// @param _data The encoded data\n    function initialize(uint256 _poolId, bytes memory _data) external;\n\n    /// @notice This will register a recipient, set their status (and any other strategy specific values), and\n    ///         return the ID of the recipient.\n    /// @dev Able to change status all the way up to 'Accepted', or to 'Pending' and if there are more steps, additional\n    ///      functions should be added to allow the owner to check this. The owner could also check attestations directly\n    ///      and then accept for instance. The '_data' will be determined by the strategy implementation.\n    /// @param _data The data to use to register the recipient\n    /// @param _sender The address of the sender\n    /// @return The ID of the recipient\n    function registerRecipient(bytes memory _data, address _sender) external payable returns (address);\n\n    /// @notice This will allocate to a recipient.\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\n    /// @param _data The data to use to allocate to the recipient\n    /// @param _sender The address of the sender\n    function allocate(bytes memory _data, address _sender) external payable;\n\n    /// @notice This will distribute funds (tokens) to recipients.\n    /// @dev most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference\n    /// this contract will need to track the amount paid already, so that it doesn't double pay.\n    function distribute(address[] memory _recipientIds, bytes memory _data, address _sender) external;\n}\n"
    },
    "contracts/core/libraries/Clone.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Clone library\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice A helper library to create deterministic clones of the strategy contracts when a pool is created\n/// @dev Handles the creation of clones for the strategy contracts and returns the address of the clone\nlibrary Clone {\n    /// @dev Create a clone of the contract\n    /// @param _contract The address of the contract to clone\n    /// @param _nonce The nonce to use for the clone\n    function createClone(address _contract, uint256 _nonce) internal returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, _nonce));\n\n        // Return the address of the contract\n        return ClonesUpgradeable.cloneDeterministic(_contract, salt);\n    }\n}\n"
    },
    "contracts/core/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Errors\n/// @author @thelostone-mc <aditya@gitcoin.co>, @KurtMerbeth <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>\n/// @notice Library containing all custom errors the protocol may revert with.\ncontract Errors {\n    /// ======================\n    /// ====== Generic =======\n    /// ======================\n\n    /// @notice Thrown as a general error when input / data is invalid\n    error INVALID();\n\n    /// @notice Thrown when mismatch in decoding data\n    error MISMATCH();\n\n    /// @notice Thrown when not enough funds are available\n    error NOT_ENOUGH_FUNDS();\n\n    /// @notice Thrown when user is not authorized\n    error UNAUTHORIZED();\n\n    /// @notice Thrown when address is the zero address\n    error ZERO_ADDRESS();\n\n    /// @notice Thrown when the function is not implemented\n    error NOT_IMPLEMENTED();\n\n    /// @notice Thrown when the value is non-zero\n    error NON_ZERO_VALUE();\n\n    /// ======================\n    /// ====== Registry ======\n    /// ======================\n\n    /// @dev Thrown when the nonce passed has been used or not available\n    error NONCE_NOT_AVAILABLE();\n\n    /// @dev Thrown when the 'msg.sender' is not the pending owner on ownership transfer\n    error NOT_PENDING_OWNER();\n\n    /// @dev Thrown if the anchor creation fails\n    error ANCHOR_ERROR();\n\n    /// ======================\n    /// ======== Allo ========\n    /// ======================\n\n    /// @notice Thrown when the strategy is not approved\n    error NOT_APPROVED_STRATEGY();\n\n    /// @notice Thrown when the strategy is approved and should be cloned\n    error IS_APPROVED_STRATEGY();\n\n    /// @notice Thrown when the fee is below 1e18 which is the fee percentage denominator\n    error INVALID_FEE();\n\n    /// ======================\n    /// ===== IStrategy ======\n    /// ======================\n\n    /// @notice Thrown when data is already intialized\n    error ALREADY_INITIALIZED();\n\n    /// @notice Thrown when data is yet to be initialized\n    error NOT_INITIALIZED();\n\n    /// @notice Thrown when an invalid address is used\n    error INVALID_ADDRESS();\n\n    /// @notice Thrown when a pool is inactive\n    error POOL_INACTIVE();\n\n    /// @notice Thrown when a pool is already active\n    error POOL_ACTIVE();\n\n    /// @notice Thrown when two arrays length are not equal\n    error ARRAY_MISMATCH();\n\n    /// @notice Thrown when the registration is invalid.\n    error INVALID_REGISTRATION();\n\n    /// @notice Thrown when the metadata is invalid.\n    error INVALID_METADATA();\n\n    /// @notice Thrown when the recipient is not accepted.\n    error RECIPIENT_NOT_ACCEPTED();\n\n    /// @notice Thrown when recipient is already accepted.\n    error RECIPIENT_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when registration is not active.\n    error REGISTRATION_NOT_ACTIVE();\n\n    /// @notice Thrown when registration is active.\n    error REGISTRATION_ACTIVE();\n\n    /// @notice Thrown when there is an error in recipient.\n    error RECIPIENT_ERROR(address recipientId);\n\n    /// @notice Thrown when the allocation is not active.\n    error ALLOCATION_NOT_ACTIVE();\n\n    /// @notice Thrown when the allocation is not ended.\n    error ALLOCATION_NOT_ENDED();\n\n    /// @notice Thrown when the allocation is active.\n    error ALLOCATION_ACTIVE();\n}\n"
    },
    "contracts/core/libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Metadata\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Metadata is used to define the metadata for the protocol that is used throughout the system.\nstruct Metadata {\n    /// @notice Protocol ID corresponding to a specific protocol (currently using IPFS = 1)\n    uint256 protocol;\n    /// @notice Pointer (hash) to fetch metadata for the specified protocol\n    string pointer;\n}\n"
    },
    "contracts/core/libraries/Native.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Native token information\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This is used to define the address of the native token for the protocol\ncontract Native {\n    /// @notice Address of the native token\n    address public constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n}\n"
    },
    "contracts/core/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "contracts/core/libraries/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// The ERC20 standard allows minting and transferring to and from the zero address,\n/// minting and transferring zero tokens, as well as self-approvals.\n/// For performance, this implementation WILL NOT revert for such actions.\n/// Please add any checks with overrides if desired.\nabstract contract ERC20 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC20                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\n    ///\n    /// Emits a {Approval} event.\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowanceBefore := sload(allowanceSlot)\n            // Add to the allowance.\n            let allowanceAfter := add(allowanceBefore, difference)\n            // Revert upon overflow.\n            if lt(allowanceAfter, allowanceBefore) {\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated allowance.\n            sstore(allowanceSlot, allowanceAfter)\n            // Emit the {Approval} event.\n            mstore(0x00, allowanceAfter)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\n    ///\n    /// Emits a {Approval} event.\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowanceBefore := sload(allowanceSlot)\n            // Revert if will underflow.\n            if lt(allowanceBefore, difference) {\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated allowance.\n            let allowanceAfter := sub(allowanceBefore, difference)\n            sstore(allowanceSlot, allowanceAfter)\n            // Emit the {Approval} event.\n            mstore(0x00, allowanceAfter)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if iszero(eq(allowance_, not(0))) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          EIP-2612                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            let m := mload(0x40)\n            // Revert if the block timestamp greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, 1))\n            // Prepare the inner hash.\n            // `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n            // forgefmt: disable-next-item\n            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            // Prepare the outer hash.\n            mstore(0, 0x1901)\n            mstore(0x20, domainSeparator)\n            mstore(0x40, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0, keccak256(0x1e, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-2612 domains separator.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n        }\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        bytes32 nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := result\n            // `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n            // forgefmt: disable-next-item\n            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)\n            mstore(add(m, 0x20), nameHash)\n            // `keccak256(\"1\")`.\n            // forgefmt: disable-next-item\n            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if iszero(eq(allowance_, not(0))) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/core/libraries/Transfer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {SafeTransferLib} from \"./utils/SafeTransferLib.sol\";\n// Internal Libraries\nimport \"./Native.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Transfer contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice A helper contract to transfer tokens within Allo protocol\n/// @dev Handles the transfer of tokens to an address\ncontract Transfer is Native {\n    /// @notice Thrown when the amount of tokens sent does not match the amount of tokens expected\n    error AMOUNT_MISMATCH();\n\n    /// @notice This holds the details for a transfer\n    struct TransferData {\n        address from;\n        address to;\n        uint256 amount;\n    }\n\n    /// @notice Transfer an amount of a token to an array of addresses\n    /// @param _token The address of the token\n    /// @param _transferData TransferData[]\n    /// @return Whether the transfer was successful or not\n    function _transferAmountsFrom(address _token, TransferData[] memory _transferData)\n        internal\n        virtual\n        returns (bool)\n    {\n        uint256 msgValue = msg.value;\n\n        for (uint256 i; i < _transferData.length;) {\n            TransferData memory transferData = _transferData[i];\n\n            if (_token == NATIVE) {\n                msgValue -= transferData.amount;\n                SafeTransferLib.safeTransferETH(transferData.to, transferData.amount);\n            } else {\n                SafeTransferLib.safeTransferFrom(_token, transferData.from, transferData.to, transferData.amount);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (msgValue != 0) revert AMOUNT_MISMATCH();\n\n        return true;\n    }\n\n    /// @notice Transfer an amount of a token to an address\n    /// @param _token The address of the token\n    /// @param _transferData Individual TransferData\n    /// @return Whether the transfer was successful or not\n    function _transferAmountFrom(address _token, TransferData memory _transferData) internal virtual returns (bool) {\n        uint256 amount = _transferData.amount;\n        if (_token == NATIVE) {\n            // Native Token\n            if (msg.value < amount) revert AMOUNT_MISMATCH();\n\n            SafeTransferLib.safeTransferETH(_transferData.to, amount);\n        } else {\n            SafeTransferLib.safeTransferFrom(_token, _transferData.from, _transferData.to, amount);\n        }\n        return true;\n    }\n\n    /// @notice Transfer an amount of a token to an address\n    /// @param _token The token to transfer\n    /// @param _to The address to transfer to\n    /// @param _amount The amount to transfer\n    function _transferAmount(address _token, address _to, uint256 _amount) internal virtual {\n        if (_token == NATIVE) {\n            SafeTransferLib.safeTransferETH(_to, _amount);\n        } else {\n            SafeTransferLib.safeTransfer(_token, _to, _amount);\n        }\n    }\n\n    /// @notice Get the balance of a token for an account\n    /// @param _token The token to get the balance of\n    /// @param _account The account to get the balance for\n    /// @return The balance of the token for the account\n    function _getBalance(address _token, address _account) internal view returns (uint256) {\n        if (_token == NATIVE) {\n            return payable(_account).balance;\n        } else {\n            return SafeTransferLib.balanceOf(_token, _account);\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/Clone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Class with helper read functions for clone with immutable args.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)\n/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\nabstract contract Clone {\n    /// @dev Reads an immutable arg with type bytes.\n    function _getArgBytes(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\n            let o := add(add(arg, 0x20), length)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Reads an immutable arg with type address.\n    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads a uint256 array stored in the immutable args.\n    function _getArgUint256Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (uint256[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }\n\n    /// @dev Reads a bytes32 array stored in the immutable args.\n    function _getArgBytes32Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes32[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }\n\n    /// @dev Reads an immutable arg with type bytes32.\n    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint256.\n    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint248.\n    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(8, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint240.\n    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(16, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint232.\n    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(24, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint224.\n    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0x20, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint216.\n    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(40, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint208.\n    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(48, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint200.\n    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(56, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint192.\n    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(64, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint184.\n    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(72, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint176.\n    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(80, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint168.\n    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(88, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint160.\n    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint152.\n    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(104, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint144.\n    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(112, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint136.\n    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(120, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint128.\n    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(128, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint120.\n    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(136, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint112.\n    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(144, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint104.\n    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(152, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint96.\n    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(160, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint88.\n    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(168, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint80.\n    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(176, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint72.\n    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(184, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint64.\n    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(192, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint56.\n    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(200, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint48.\n    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(208, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint40.\n    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(216, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint32.\n    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(224, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint24.\n    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(232, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint16.\n    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(240, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @dev Reads an immutable arg with type uint8.\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(248, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @return offset The offset of the packed immutable args in calldata.\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the contract.\n    error DeploymentFailed();\n\n    /// @dev Unable to initialize the contract.\n    error InitializationFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTECODE CONSTANTS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * -------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 36          | CALLDATASIZE     | cds          |                    |\n     * 3d          | RETURNDATASIZE   | 0 cds        |                    |\n     * 3d          | RETURNDATASIZE   | 0 0 cds      |                    |\n     * 37          | CALLDATACOPY     |              | [0..cds): calldata |\n     * 36          | CALLDATASIZE     | cds          | [0..cds): calldata |\n     * 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |\n     * 34          | CALLVALUE        | value 0 cds  | [0..cds): calldata |\n     * f0          | CREATE           | newContract  | [0..cds): calldata |\n     * -------------------------------------------------------------------|\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 67 bytecode | PUSH8 bytecode   | bytecode     |                    |\n     * 3d          | RETURNDATASIZE   | 0 bytecode   |                    |\n     * 52          | MSTORE           |              | [0..8): bytecode   |\n     * 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |\n     * 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |\n     * f3          | RETURN           |              | [0..8): bytecode   |\n     * -------------------------------------------------------------------+\n     */\n\n    /// @dev The proxy bytecode.\n    uint256 private constant _PROXY_BYTECODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_PROXY_BYTECODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 private constant _PROXY_BYTECODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      CREATE3 OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys `creationCode` deterministically with a `salt`.\n    /// The deployed contract is funded with `value` (in wei) ETH.\n    /// Returns the deterministic address of the deployed contract,\n    /// which solely depends on `salt`.\n    function deploy(bytes32 salt, bytes memory creationCode, uint256 value)\n        internal\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the `_PROXY_BYTECODE` into scratch space.\n            mstore(0x00, _PROXY_BYTECODE)\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            let proxy := create2(0, 0x10, 0x10, salt)\n\n            // If the result of `create2` is the zero address, revert.\n            if iszero(proxy) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the proxy's address.\n            mstore(0x14, proxy)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n\n            // If the `call` fails, revert.\n            if iszero(\n                call(\n                    gas(), // Gas remaining.\n                    proxy, // Proxy's address.\n                    value, // Ether value.\n                    add(creationCode, 0x20), // Start of `creationCode`.\n                    mload(creationCode), // Length of `creationCode`.\n                    0x00, // Offset of output.\n                    0x00 // Length of output.\n                )\n            ) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If the code size of `deployed` is zero, revert.\n            if iszero(extcodesize(deployed)) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the deterministic address for `salt`.\n    function getDeployed(bytes32 salt) internal view returns (address deployed) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the free memory pointer.\n            let m := mload(0x40)\n            // Store `address(this)`.\n            mstore(0x00, address())\n            // Store the prefix.\n            mstore8(0x0b, 0xff)\n            // Store the salt.\n            mstore(0x20, salt)\n            // Store the bytecode hash.\n            mstore(0x40, _PROXY_BYTECODE_HASH)\n\n            // Store the proxy's address.\n            mstore(0x14, keccak256(0x0b, 0x55))\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/DateTimeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n///\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Weekdays are 1-indexed for a traditional rustic feel.\n\n    // \"And on the seventh day God finished his work that he had done,\n    // and he rested on the seventh day from all his work that he had done.\"\n    // -- Genesis 2:2\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed for ease of use.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := sub(add(mp, 3), mul(gt(mp, 9), 12))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1F1C1F1E1F1E1F1F1E1F1E1F)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(add(month, w), 12), lt(add(day, w), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n"
    },
    "contracts/core/libraries/utils/DynamicBufferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for buffers with automatic capacity resizing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DynamicBuffer.sol)\n/// @author Modified from cozyco (https://github.com/samkingco/cozyco/blob/main/contracts/utils/DynamicBuffer.sol)\nlibrary DynamicBufferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Type to represent a dynamic buffer in memory.\n    /// You can directly assign to `data`, and the `append` function will\n    /// take care of the memory allocation.\n    struct DynamicBuffer {\n        bytes data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Appends `data` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(DynamicBuffer memory buffer, bytes memory data)\n        internal\n        pure\n        returns (DynamicBuffer memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                let w := not(0x1f)\n                let bufferData := mload(buffer)\n                let bufferDataLength := mload(bufferData)\n                let newBufferDataLength := add(mload(data), bufferDataLength)\n                // Some random prime number to multiply `capacity`, so that\n                // we know that the `capacity` is for a dynamic buffer.\n                // Selected to be larger than any memory pointer realistically.\n                let prime := 1621250193422201\n                let capacity := mload(add(bufferData, w)) // `mload(sub(bufferData, 0x20))`.\n\n                // Extract `capacity`, initializing it to zero if it is not a multiple of `prime`.\n                capacity := mul(div(capacity, prime), iszero(mod(capacity, prime)))\n\n                // Expand / Reallocate memory if required.\n                // Note that we need to allocate an extra word for the length, and\n                // and another extra word as a safety word (giving a total of 0x40 bytes).\n                // Without the safety word, the backwards copying can cause a buffer overflow.\n                for {} iszero(lt(newBufferDataLength, capacity)) {} {\n                    // Set `newCapacity` to `(2 * capacity + 0x20) / 0x20 * 0x20`,\n                    // ensuring more than enough space.\n                    let newCapacity :=\n                        and(add(capacity, add(or(capacity, newBufferDataLength), 0x20)), w)\n\n                    // If the memory is discontiguous, we have to reallocate.\n                    if iszero(eq(mload(0x40), add(bufferData, add(0x40, capacity)))) {\n                        // Set the `newBufferData` to point to the word after capacity.\n                        let newBufferData := add(mload(0x40), 0x20)\n                        // Reallocate the memory.\n                        mstore(0x40, add(newBufferData, add(0x40, newCapacity)))\n                        // Store the `newBufferData`.\n                        mstore(buffer, newBufferData)\n                        // Copy `bufferData` one word at a time, backwards.\n                        for { let o := and(add(bufferDataLength, 0x20), w) } 1 {} {\n                            mstore(add(newBufferData, o), mload(add(bufferData, o)))\n                            o := add(o, w) // `sub(o, 0x20)`.\n                            if iszero(o) { break }\n                        }\n                        // Store the `capacity * prime` in the word before the `length`.\n                        mstore(add(newBufferData, w), mul(prime, newCapacity))\n                        // Assign `newBufferData` to `bufferData`.\n                        bufferData := newBufferData\n                        break\n                    }\n                    // Otherwise, we can expand the memory.\n                    mstore(0x40, add(bufferData, add(0x40, newCapacity)))\n                    // Store the `capacity * prime` in the word before the `length`.\n                    mstore(add(bufferData, w), mul(prime, newCapacity))\n                    break\n                }\n                // Initialize `output` to the next empty position in `bufferData`.\n                let output := add(bufferData, bufferDataLength)\n                // Copy `data` one word at a time, backwards.\n                for { let o := and(add(mload(data), 0x20), w) } 1 {} {\n                    mstore(add(output, o), mload(add(data, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the word after the buffer.\n                mstore(add(add(bufferData, 0x20), newBufferDataLength), 0)\n                // Store the `newBufferDataLength`.\n                mstore(bufferData, newBufferDataLength)\n            }\n        }\n        return buffer;\n    }\n\n    /// @dev Appends `data0`, `data1` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory)\n    {\n        return append(append(buffer, data0), data1);\n    }\n\n    /// @dev Appends `data0`, `data1`, `data2` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2\n    ) internal pure returns (DynamicBuffer memory) {\n        return append(append(append(buffer, data0), data1), data2);\n    }\n\n    /// @dev Appends `data0`, `data1`, `data2`, `data3` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3\n    ) internal pure returns (DynamicBuffer memory) {\n        return append(append(append(append(buffer, data0), data1), data2), data3);\n    }\n\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory) {\n        append(append(append(append(buffer, data0), data1), data2), data3);\n        return append(buffer, data4);\n    }\n\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4`, `data5` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory) {\n        append(append(append(append(buffer, data0), data1), data2), data3);\n        return append(append(buffer, data4), data5);\n    }\n\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6` to `buffer`.\n    /// Returns the same buffer, so that it can be used for function chaining.\n    function append(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory) {\n        append(append(append(append(buffer, data0), data1), data2), data3);\n        return append(append(append(buffer, data4), data5), data6);\n    }\n}\n"
    },
    "contracts/core/libraries/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// WARNING! Do NOT use signatures as unique identifiers.\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: as of Solady version 0.0.68, these functions will\n    // revert upon recovery failure for more safety by default.\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let signatureLength := mload(signature)\n            mstore(0x00, hash)\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        eq(signatureLength, 65), // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        eq(signature.length, 65), // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let signatureLength := mload(signature)\n            mstore(0x00, hash)\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    eq(signatureLength, 65), // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    eq(signature.length, 65), // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n/// Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    address private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = address(this);\n        _cachedChainId = block.chainid;\n\n        (string memory name, string memory version) = _domainNameAndVersion();\n        bytes32 nameHash = keccak256(bytes(name));\n        bytes32 versionHash = keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    function _domainNameAndVersion()\n        internal\n        pure\n        virtual\n        returns (string memory name, string memory version);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        separator = _cachedDomainSeparator;\n        if (_cachedDomainSeparatorInvalidated()) {\n            separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        bytes32 separator = _cachedDomainSeparator;\n        if (_cachedDomainSeparatorInvalidated()) {\n            separator = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, separator) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        bytes32 nameHash = _cachedNameHash;\n        bytes32 versionHash = _cachedVersionHash;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        address cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/ERC1967Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Factory for deploying and managing ERC1967 proxy contracts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ERC1967Factory.sol)\n/// @author jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\ncontract ERC1967Factory {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The proxy deployment failed.\n    error DeploymentFailed();\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The salt does not start with the caller.\n    error SaltDoesNotStartWithCaller();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 internal constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"DeploymentFailed()\")))`.\n    uint256 internal constant _DEPLOYMENT_FAILED_ERROR_SELECTOR = 0x30116425;\n\n    /// @dev `bytes4(keccak256(bytes(\"UpgradeFailed()\")))`.\n    uint256 internal constant _UPGRADE_FAILED_ERROR_SELECTOR = 0x55299b49;\n\n    /// @dev `bytes4(keccak256(bytes(\"SaltDoesNotStartWithCaller()\")))`.\n    uint256 internal constant _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR = 0x2f634836;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The admin of a proxy contract has been changed.\n    event AdminChanged(address indexed proxy, address indexed admin);\n\n    /// @dev The implementation for a proxy has been upgraded.\n    event Upgraded(address indexed proxy, address indexed implementation);\n\n    /// @dev A proxy has been deployed.\n    event Deployed(address indexed proxy, address indexed implementation, address indexed admin);\n\n    /// @dev `keccak256(bytes(\"AdminChanged(address,address)\"))`.\n    uint256 internal constant _ADMIN_CHANGED_EVENT_SIGNATURE =\n        0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f;\n\n    /// @dev `keccak256(bytes(\"Upgraded(address,address)\"))`.\n    uint256 internal constant _UPGRADED_EVENT_SIGNATURE =\n        0x5d611f318680d00598bb735d61bacf0c514c6b50e1e5ad30040a4df2b12791c7;\n\n    /// @dev `keccak256(bytes(\"Deployed(address,address,address)\"))`.\n    uint256 internal constant _DEPLOYED_EVENT_SIGNATURE =\n        0xc95935a66d15e0da5e412aca0ad27ae891d20b2fb91cf3994b6a3bf2b8178082;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The admin slot for a `proxy` is given by:\n    // ```\n    //     mstore(0x0c, address())\n    //     mstore(0x00, proxy)\n    //     let adminSlot := keccak256(0x0c, 0x20)\n    // ```\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    uint256 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ADMIN FUNCTIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the admin of the proxy.\n    function adminOf(address proxy) public view returns (address admin) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, address())\n            mstore(0x00, proxy)\n            admin := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets the admin of the proxy.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function changeAdmin(address proxy, address admin) public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            mstore(0x0c, address())\n            mstore(0x00, proxy)\n            let adminSlot := keccak256(0x0c, 0x20)\n            if iszero(eq(sload(adminSlot), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Store the admin for the proxy.\n            sstore(adminSlot, admin)\n            // Emit the {AdminChanged} event.\n            log3(0, 0, _ADMIN_CHANGED_EVENT_SIGNATURE, proxy, admin)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     UPGRADE FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Upgrades the proxy to point to `implementation`.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function upgrade(address proxy, address implementation) public payable {\n        upgradeAndCall(proxy, implementation, _emptyData());\n    }\n\n    /// @dev Upgrades the proxy to point to `implementation`.\n    /// Then, calls the proxy with abi encoded `data`.\n    /// The caller of this function must be the admin of the proxy on this factory.\n    function upgradeAndCall(address proxy, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            mstore(0x0c, address())\n            mstore(0x00, proxy)\n            if iszero(eq(sload(keccak256(0x0c, 0x20)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set up the calldata to upgrade the proxy.\n            let m := mload(0x40)\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try upgrading the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `UpgradeFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _UPGRADE_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            // Emit the {Upgraded} event.\n            log3(0, 0, _UPGRADED_EVENT_SIGNATURE, proxy, implementation)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      DEPLOY FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`,\n    /// and returns its address.\n    /// The value passed into this function will be forwarded to the proxy.\n    function deploy(address implementation, address admin) public payable returns (address proxy) {\n        proxy = deployAndCall(implementation, admin, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`,\n    /// and returns its address.\n    /// The value passed into this function will be forwarded to the proxy.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = _deploy(implementation, admin, bytes32(0), false, data);\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    function deployDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = deployDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }\n\n    /// @dev Deploys a proxy for `implementation`, with `admin`, `salt`,\n    /// and returns its deterministic address.\n    /// The value passed into this function will be forwarded to the proxy.\n    /// Then, calls the proxy with abi encoded `data`.\n    function deployDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address proxy) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        proxy = _deploy(implementation, admin, salt, true, data);\n    }\n\n    /// @dev Deploys the proxy, with optionality to deploy deterministically with a `salt`.\n    function _deploy(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address proxy) {\n        bytes memory m = _initCode();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Create the proxy.\n            switch useSalt\n            case 0 { proxy := create(0, add(m, 0x13), 0x89) }\n            default { proxy := create2(0, add(m, 0x13), 0x89, salt) }\n            // Revert if the creation fails.\n            if iszero(proxy) {\n                mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n\n            // Set up the calldata to set the implementation of the proxy.\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try setting the implementation on the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n\n            // Store the admin for the proxy.\n            mstore(0x0c, address())\n            mstore(0x00, proxy)\n            sstore(keccak256(0x0c, 0x20), admin)\n\n            // Emit the {Deployed} event.\n            log4(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation, admin)\n        }\n    }\n\n    /// @dev Returns the address of the proxy deployed with `salt`.\n    function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\n        bytes32 hash = initCodeHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the proxy.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash() public view returns (bytes32 result) {\n        bytes memory m = _initCode();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(m, 0x13), 0x89)\n        }\n    }\n\n    /// @dev Returns the initialization code of a proxy created via this factory.\n    function _initCode() internal view returns (bytes memory m) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * -------------------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                                   |\n             * -------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\n             * 81         | DUP2            | r 0 r               |                                 |\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\n             * -------------------------------------------------------------------------------------|\n             * RUNTIME (127 bytes)                                                                  |\n             * -------------------------------------------------------------------------------------|\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             *                                                                                      |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 33          | CALLER         | c 0 0               |                                 |\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\n             * 14          | EQ             | isf 0 0             |                                 |\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\n             * 57          | JUMPI          | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 54          | SLOAD          | i cds 0 0           | [0..calldatasize): calldata     |\n             * 5a          | GAS            | g i cds 0 0         | [0..calldatasize): calldata     |\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\n             * 06 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\n             * 55          | SSTORE         | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\n             * 11          | GT             | gt 2w 0 0           |                                 |\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\n             * 57          | JUMPI          | 2w 0 0              |                                 |\n             *                                                                                      |\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\n             * 03          | SUB            | t 0 0               |                                 |\n             * 80          | DUP1           | t t 0 0             |                                 |\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\n             * 35          | CALLDATALOAD   | i t 0 0             | [0..t): extra calldata          |\n             * 5a          | GAS            | g i t 0 0           | [0..t): extra calldata          |\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             * -------------------------------------------------------------------------------------+\n             */\n\n            m := mload(0x40)\n            // forgefmt: disable-start\n            switch shr(112, address())\n            case 0 {\n                // If the factory's address has six or more leading zero bytes.\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x0e), address()) // 14\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\n            }\n            default {\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x14), address()) // 20\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\n            }\n            // forgefmt: disable-end\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          HELPERS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Helper function to return an empty bytes calldata.\n    function _emptyData() internal pure returns (bytes calldata data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data.length := 0\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/ERC1967FactoryConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice The address and bytecode of the canonical ERC1967Factory deployment.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ERC1967FactoryLib.sol)\n/// @author jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev The canonical ERC1967Factory is deployed permissionlessly via\n/// 0age's ImmutableCreate2Factory located at 0x0000000000FFe8B47B3e2130213B802212439497.\n///\n/// `ADDRESS = immutableCreate2Factory.safeCreate2(SALT, INITCODE)`\n///\n/// If the canonical ERC1967Factory has not been deployed on your EVM chain of choice,\n/// please feel free to deploy via 0age's ImmutableCreate2Factory.\n///\n/// If 0age's ImmutableCreate2Factory has not been deployed on your EVM chain of choice,\n/// please refer to 0age's ImmutableCreate2Factory deployment instructions at:\n/// https://github.com/ProjectOpenSea/seaport/blob/main/docs/Deployment.md\n///\n/// Contract verification can be done either via command line or block explorers like Etherscan.\n/// The simplest and most reliable way is via block explorer with single file input.\nlibrary ERC1967FactoryConstants {\n    /// @dev The canonical ERC1967Factory address for EVM chains.\n    address internal constant ADDRESS = 0x0000000000006396FF2a80c067f99B3d2Ab4Df24;\n\n    /// @dev The canonical ERC1967Factory bytecode for EVM chains.\n    /// Useful for forge tests:\n    /// `vm.etch(ADDRESS, BYTECODE)`.\n    bytes internal constant BYTECODE =\n        hex\"6080604052600436106100b15760003560e01c8063545e7c611161006957806399a88ec41161004e57806399a88ec41461019d578063a97b90d5146101b0578063db4c545e146101c357600080fd5b8063545e7c61146101775780639623609d1461018a57600080fd5b80633729f9221161009a5780633729f922146101315780634314f120146101445780635414dff01461015757600080fd5b80631acfd02a146100b65780632abbef15146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d1366004610604565b6101e6565b005b3480156100e457600080fd5b506101076100f3366004610637565b30600c908152600091909152602090205490565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61010761013f366004610652565b610237565b6101076101523660046106d7565b61024e565b34801561016357600080fd5b50610107610172366004610738565b610267565b610107610185366004610604565b61029a565b6100d66101983660046106d7565b6102af565b6100d66101ab366004610604565b61035f565b6101076101be366004610751565b610370565b3480156101cf57600080fd5b506101d86103a9565b604051908152602001610128565b30600c52816000526020600c2033815414610209576382b429006000526004601cfd5b81905580827f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f600080a35050565b60006102468484843685610370565b949350505050565b600061025e8585838087876103c2565b95945050505050565b6000806102726103a9565b905060ff600053806035523060601b6001528260155260556000209150600060355250919050565b60006102a88383368461024e565b9392505050565b30600c5283600052336020600c2054146102d1576382b429006000526004601cfd5b6040518381527f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc602082015281836040830137600080836040018334895af1610331573d610327576355299b496000526004601cfd5b3d6000803e3d6000fd5b5082847f5d611f318680d00598bb735d61bacf0c514c6b50e1e5ad30040a4df2b12791c7600080a350505050565b61036c82823660006102af565b5050565b60008360601c33148460601c151761039057632f6348366000526004601cfd5b61039f868686600187876103c2565b9695505050505050565b6000806103b461049c565b608960139091012092915050565b6000806103cd61049c565b90508480156103e757866089601384016000f592506103f3565b6089601383016000f092505b50816104075763301164256000526004601cfd5b8781527f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc602082015282846040830137600080846040018334865af161045a573d6103275763301164256000526004601cfd5b30600c5281600052866020600c20558688837fc95935a66d15e0da5e412aca0ad27ae891d20b2fb91cf3994b6a3bf2b8178082600080a4509695505050505050565b6040513060701c801561054257666052573d6000fd607b8301527f3d356020355560408036111560525736038060403d373d3d355af43d6000803e60748301527f3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b60548301527f14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc60348301523060148301526c607f3d8160093d39f33d3d337382525090565b66604c573d6000fd60758301527f3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e606e8301527f3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b604e8301527f14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc602e83015230600e8301526c60793d8160093d39f33d3d336d82525090565b803573ffffffffffffffffffffffffffffffffffffffff811681146105ff57600080fd5b919050565b6000806040838503121561061757600080fd5b610620836105db565b915061062e602084016105db565b90509250929050565b60006020828403121561064957600080fd5b6102a8826105db565b60008060006060848603121561066757600080fd5b610670846105db565b925061067e602085016105db565b9150604084013590509250925092565b60008083601f8401126106a057600080fd5b50813567ffffffffffffffff8111156106b857600080fd5b6020830191508360208285010111156106d057600080fd5b9250929050565b600080600080606085870312156106ed57600080fd5b6106f6856105db565b9350610704602086016105db565b9250604085013567ffffffffffffffff81111561072057600080fd5b61072c8782880161068e565b95989497509550505050565b60006020828403121561074a57600080fd5b5035919050565b60008060008060006080868803121561076957600080fd5b610772866105db565b9450610780602087016105db565b935060408601359250606086013567ffffffffffffffff8111156107a357600080fd5b6107af8882890161068e565b96999598509396509294939250505056fea26469706673582212200ac7c3ccbc2d311c48bf5465b021542e0e306fe3c462c060ba6a3d2f81ff6c5f64736f6c63430008130033\";\n\n    /// @dev The initcode used to deploy the canonical ERC1967Factory.\n    bytes internal constant INITCODE = abi.encodePacked(\n        hex\"608060405234801561001057600080fd5b506107f6806100206000396000f3fe\", BYTECODE\n    );\n\n    /// @dev For deterministic deployment via 0age's ImmutableCreate2Factory.\n    bytes32 internal constant SALT =\n        0x0000000000000000000000000000000000000000e75e4f228818c80007508f33;\n}\n"
    },
    "contracts/core/libraries/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The multiply-divide operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The output is undefined, as the input is zero.\n    error Log2Undefined();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n                if iszero(slt(x, 135305999368893231589)) {\n                    // Store the function selector of `ExpOverflow()`.\n                    mstore(0x00, 0xa37bfec9)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            /// @solidity memory-safe-assembly\n            assembly {\n                if iszero(sgt(x, 0)) {\n                    // Store the function selector of `LnWadUndefined()`.\n                    mstore(0x00, 0x1615e638)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Compute k = log2(x) - 96.\n            int256 k;\n            /// @solidity memory-safe-assembly\n            assembly {\n                let v := x\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\n\n                // For the remaining 32 bits, use a De Bruijn lookup.\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\n                v := shr(k, v)\n                v := or(v, shr(1, v))\n                v := or(v, shr(2, v))\n                v := or(v, shr(4, v))\n                v := or(v, shr(8, v))\n                v := or(v, shr(16, v))\n\n                // forgefmt: disable-next-item\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\n            }\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Calculates `floor(a * b / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            for {} 1 {} {\n                // 512-bit multiply `[prod1 prod0] = x * y`.\n                // Compute the product mod `2**256` and mod `2**256 - 1`\n                // then use the Chinese Remainder Theorem to reconstruct\n                // the 512 bit result. The result is stored in two 256\n                // variables such that `product = prod1 * 2**256 + prod0`.\n\n                // Least significant 256 bits of the product.\n                let prod0 := mul(x, y)\n                let mm := mulmod(x, y, not(0))\n                // Most significant 256 bits of the product.\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\n\n                // Handle non-overflow cases, 256 by 256 division.\n                if iszero(prod1) {\n                    if iszero(d) {\n                        // Store the function selector of `FullMulDivFailed()`.\n                        mstore(0x00, 0xae47f702)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n                    result := div(prod0, d)\n                    break       \n                }\n\n                // Make sure the result is less than `2**256`.\n                // Also prevents `d == 0`.\n                if iszero(gt(d, prod1)) {\n                    // Store the function selector of `FullMulDivFailed()`.\n                    mstore(0x00, 0xae47f702)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                ///////////////////////////////////////////////\n                // 512 by 256 division.\n                ///////////////////////////////////////////////\n\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\n                // Compute remainder using mulmod.\n                let remainder := mulmod(x, y, d)\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n                // Factor powers of two out of `d`.\n                // Compute largest power of two divisor of `d`.\n                // Always greater or equal to 1.\n                let twos := and(d, sub(0, d))\n                // Divide d by power of two.\n                d := div(d, twos)\n                // Divide [prod1 prod0] by the factors of two.\n                prod0 := div(prod0, twos)\n                // Shift in bits from `prod1` into `prod0`. For this we need\n                // to flip `twos` such that it is `2**256 / twos`.\n                // If `twos` is zero, then it becomes one.\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\n                // Invert `d mod 2**256`\n                // Now that `d` is an odd number, it has an inverse\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                // Compute the inverse by starting with a seed that is correct\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                let inv := xor(mul(3, d), 2)\n                // Now use Newton-Raphson iteration to improve the precision.\n                // Thanks to Hensel's lifting lemma, this also works in modular\n                // arithmetic, doubling the correct bits in each step.\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\n        result = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                if iszero(add(result, 1)) {\n                    // Store the function selector of `FullMulDivFailed()`.\n                    mstore(0x00, 0xae47f702)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n                result := add(result, 1)\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                // Store the function selector of `DivFailed()`.\n                mstore(0x00, 0x65244e4e)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            z := mul(b, iszero(y))\n            if x {\n                // `z = isEven(y) ? scale : x`\n                z := xor(b, mul(xor(b, x), and(y, 1)))\n                // Divide `b` by 2.\n                let half := shr(1, b)\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    // Store x squared.\n                    let xx := mul(x, x)\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n                    // Revert if `xx + half` overflowed,\n                    // or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        // Store the function selector of `RPowOverflow()`.\n                        mstore(0x00, 0x49f7642b)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n                    // Set `x` to scaled `xxRound`.\n                    x := div(xxRound, b)\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        // Compute `z * x`.\n                        let zx := mul(z, x)\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if iszero(iszero(x)) {\n                                // Store the function selector of `RPowOverflow()`.\n                                mstore(0x00, 0x49f7642b)\n                                // Revert with (offset, size).\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        // Return properly scaled `zxRound`.\n                        z := div(zxRound, b)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`.\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\n\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 58)) {\n                // Store the function selector of `FactorialOverflow()`.\n                mstore(0x00, 0xaba0f2a2)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            for { result := 1 } x {} {\n                result := mul(result, x)\n                x := sub(x, 1)\n            }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(x) {\n                // Store the function selector of `Log2Undefined()`.\n                mstore(0x00, 0x5be3aa5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // forgefmt: disable-next-item\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            uint256 isNotPo2;\n            assembly {\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\n            }\n            return log2(x) + isNotPo2;\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := sub(0, shr(255, x))\n            z := xor(mask, add(mask, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let a := sub(y, x)\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        z = min(max(x, minValue), maxValue);\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        z = min(max(x, minValue), maxValue);\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibBit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `log2(x)`, but without reverting for the zero case.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(8, iszero(x))\n\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // forgefmt: disable-next-item\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := add(iszero(x), 255)\n\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // forgefmt: disable-next-item\n            r := sub(t, or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(8, iszero(x))\n\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n\n            r := or(r, shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(shr(251, mul(shr(r, x), shl(224, 0x077cb531))), \n                0x00011c021d0e18031e16140f191104081f1b0d17151310071a0c12060b050a09))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if iszero(s) { break }\n            }\n        }\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            let m := not(0)\n            r := x\n            for { let s := 128 } 1 {} {\n                m := xor(m, shl(s, m))\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\n                s := shr(1, s)\n                if eq(s, 4) { break }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns a non-zero number if `b` is true, else 0.\n    /// If `b` is from plain Solidity, the non-zero number will be 1.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibBitmap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibBit} from \"./LibBit.sol\";\n\n/// @notice Library for storage of packed unsigned booleans.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\nlibrary LibBitmap {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when a bitmap scan does not find a result.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A bitmap in storage.\n    struct Bitmap {\n        mapping(uint256 => uint256) map;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            isSet := b\n        }\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to true.\n    function set(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to false.\n    function unset(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\n    }\n\n    /// @dev Flips the bit at `index` in `bitmap`.\n    /// Returns the boolean result of the flipped bit.\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, shr(8, index))\n            mstore(0x20, bitmap.slot)\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := sload(storageSlot)\n\n            let mask := shl(shift, 1)\n            storageValue := xor(storageValue, mask)\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := iszero(iszero(and(storageValue, mask)))\n            sstore(storageSlot, storageValue)\n        }\n    }\n\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }\n\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), max)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\n        }\n    }\n\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), 0)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\n            )\n        }\n    }\n\n    /// @dev Returns number of set bits within a range by\n    /// scanning `amount` of bits starting from the bit at `start`.\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\n        internal\n        view\n        returns (uint256 count)\n    {\n        unchecked {\n            uint256 bucket = start >> 8;\n            uint256 shift = start & 0xff;\n            if (!(amount + shift < 257)) {\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\n                amount = (amount + shift) & 0xff;\n                shift = 0;\n                for (++bucket; bucket != bucketEnd; ++bucket) {\n                    count += LibBit.popCount(bitmap.map[bucket]);\n                }\n            }\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\n        }\n    }\n\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\n    /// If no set bit is found, returns `NOT_FOUND`.\n    function findLastSet(Bitmap storage bitmap, uint256 before)\n        internal\n        view\n        returns (uint256 setBitIndex)\n    {\n        uint256 bucket;\n        uint256 bucketBits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            setBitIndex := not(0)\n            bucket := shr(8, before)\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\n            if iszero(bucketBits) {\n                for {} bucket {} {\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\n                    mstore(0x00, bucket)\n                    bucketBits := sload(keccak256(0x00, 0x40))\n                    if bucketBits { break }\n                }\n            }\n        }\n        if (bucketBits != 0) {\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibClone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or the caller.\n    error SaltDoesNotStartWithCaller();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(0, 0x0c, 0x35)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x21, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(0, 0x0c, 0x35, salt)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x21, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x21, 0)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(0, 0x0e, 0x36)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x24, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(0, 0x0e, 0x36, salt)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x24, 0)\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x24, 0)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\n    /// with `salt` by `deployer`.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal proxy with `implementation`,\n    /// using immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`,\n    /// using immutable arguments encoded in `data`, with `salt`.\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Create the instance.\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            // Write the bytecode before the data.\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\n            // Write the address of the implementation.\n            mstore(sub(data, 0x0d), implementation)\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            // Compute and store the bytecode hash.\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Reverts if `salt` does not start with either the zero address or the caller.\n    function checkStartsWithCaller(bytes32 salt) internal view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                // Store the function selector of `SaltDoesNotStartWithCaller()`.\n                mstore(0x00, 0x2f634836)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A uint8 map in storage.\n    struct Uint8Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint16 map in storage.\n    struct Uint16Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\n    struct Uint40Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint64 map in storage.\n    struct Uint64Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev A uint128 map in storage.\n    struct Uint128Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the uint8 value at `index` in `map`.\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }\n\n    /// @dev Updates the uint8 value at `index` in `map`.\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }\n\n    /// @dev Returns the uint16 value at `index` in `map`.\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\n    }\n\n    /// @dev Updates the uint16 value at `index` in `map`.\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint32 value at `index` in `map`.\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\n    }\n\n    /// @dev Updates the uint32 value at `index` in `map`.\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint40 value at `index` in `map`.\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }\n\n    /// @dev Updates the uint40 value at `index` in `map`.\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint64 value at `index` in `map`.\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\n    }\n\n    /// @dev Updates the uint64 value at `index` in `map`.\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the uint128 value at `index` in `map`.\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\n    }\n\n    /// @dev Updates the uint128 value at `index` in `map`.\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }\n\n    /// @dev Returns the value at `index` in `map`.\n    function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }\n\n    /// @dev Updates the value at `index` in `map`.\n    function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       BINARY SEARCH                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The following functions search in the range of [`start`, `end`)\n    // (i.e. `start <= index < end`).\n    // The range must be sorted in ascending order.\n    // `index` precedence: equal to > nearest before > nearest after.\n    // An invalid search range will simply return `(found = false, index = start)`.\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }\n\n    /// @dev Returns whether `map` contains `needle`, and the index of `needle`.\n    function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibPRNG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for generating psuedorandom numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\nlibrary LibPRNG {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A psuedorandom number state in memory.\n    struct PRNG {\n        uint256 state;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Seeds the `prng` with `state`.\n    function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }\n\n    /// @dev Returns the next psuedorandom uint256.\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }\n\n    /// @dev Returns a psuedorandom uint256, uniformly distributed\n    /// between 0 (inclusive) and `upper` (exclusive).\n    /// If your modulus is big, this method is recommended\n    /// for uniform sampling to avoid modulo bias.\n    /// For uniform sampling across all uint256 values,\n    /// or for small enough moduli such that the bias is neligible,\n    /// use {next} instead.\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }\n\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibRLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for computing contract addresses from their deployer and nonce.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibRLP.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\nlibrary LibRLP {\n    /// @dev Returns the address where a contract will be stored if deployed via\n    /// `deployer` with `nonce` using the `CREATE` opcode.\n    /// For the specification of the Recursive Length Prefix (RLP)\n    /// encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper\n    /// (https://ethereum.github.io/yellowpaper/paper.pdf)\n    /// and the Ethereum Wiki (https://eth.wiki/fundamentals/rlp).\n    ///\n    /// Based on the EIP-161 (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md)\n    /// specification, all contract accounts on the Ethereum mainnet are initiated with\n    /// `nonce = 1`. Thus, the first contract address created by another contract\n    /// is calculated with a non-zero nonce.\n    ///\n    /// The theoretical allowed limit, based on EIP-2681\n    /// (https://eips.ethereum.org/EIPS/eip-2681), for an account nonce is 2**64-2.\n    ///\n    /// Caution! This function will NOT check that the nonce is within the theoretical range.\n    /// This is for performance, as exceeding the range is extremely impractical.\n    /// It is the user's responsibility to ensure that the nonce is valid\n    /// (e.g. no dirty bits after packing / unpacking).\n    function computeAddress(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its\n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Optimized sorts and operations for sorted arrays.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Sort.sol)\nlibrary LibSort {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INSERTION SORT                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on small arrays (32 or lesser elements).\n    // - Faster on almost sorted arrays.\n    // - Smaller bytecode.\n    // - May be suitable for view functions intended for off-chain querying.\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let s := 0x20\n            let w := not(0x1f)\n            for { let i := add(a, s) } 1 {} {\n                i := add(i, s)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, s), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, s), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INTRO-QUICKSORT                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on larger arrays (more than 32 elements).\n    // - Robust performance.\n    // - Larger bytecode.\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let s := 0x20\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n\n            // Let the stack be the start of the free memory.\n            let stack := mload(0x40)\n\n            for {} iszero(lt(n, 2)) {} {\n                // Push `l` and `h` to the stack.\n                // The `shl` by 5 is equivalent to multiplying by `0x20`.\n                let l := add(a, s)\n                let h := add(a, shl(5, n))\n\n                let j := l\n                // forgefmt: disable-next-item\n                for {} iszero(or(eq(j, h), gt(mload(j), mload(add(j, s))))) {} {\n                    j := add(j, s)\n                }\n                // If the array is already sorted.\n                if eq(j, h) { break }\n\n                j := h\n                // forgefmt: disable-next-item\n                for {} iszero(gt(mload(j), mload(add(j, w)))) {} {\n                    j := add(j, w) // `sub(j, 0x20)`.\n                }\n                // If the array is reversed sorted.\n                if eq(j, l) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(h, w) // `sub(h, 0x20)`.\n                        l := add(l, s)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n\n                // Push `l` and `h` onto the stack.\n                mstore(stack, l)\n                mstore(add(stack, s), h)\n                stack := add(stack, 0x40)\n                break\n            }\n\n            for { let stackBottom := mload(0x40) } iszero(eq(stack, stackBottom)) {} {\n                // Pop `l` and `h` from the stack.\n                stack := sub(stack, 0x40)\n                let l := mload(stack)\n                let h := mload(add(stack, s))\n\n                // Do insertion sort if `h - l <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h, l), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i := add(l, s)\n                    if iszero(lt(mload(l), mload(i))) {\n                        let t := mload(i)\n                        mstore(i, mload(l))\n                        mstore(l, t)\n                    }\n                    for {} 1 {} {\n                        i := add(i, s)\n                        if gt(i, h) { break }\n                        let k := mload(i) // Key.\n                        let j := add(i, w) // The slot before the current slot.\n                        let v := mload(j) // The value of `j`.\n                        if iszero(gt(v, k)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j, s), v)\n                            j := add(j, w)\n                            v := mload(j)\n                            if iszero(gt(v, k)) { break }\n                        }\n                        mstore(add(j, s), k)\n                    }\n                    continue\n                }\n                // Pivot slot is the average of `l` and `h`.\n                let p := add(shl(5, shr(6, add(l, h))), and(31, l))\n                // Median of 3 with sorting.\n                {\n                    function swap(a_, b_) -> _b, _a {\n                        _b := a_\n                        _a := b_\n                    }\n                    let e0 := mload(l)\n                    let e1 := mload(h)\n                    if iszero(lt(e0, e1)) { e1, e0 := swap(e0, e1) }\n                    let e2 := mload(p)\n                    if iszero(lt(e2, e1)) { e2, e1 := swap(e1, e2) }\n                    if iszero(lt(e0, e2)) { e2, e0 := swap(e0, e2) }\n                    mstore(p, e2)\n                    mstore(h, e1)\n                    mstore(l, e0)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x := mload(p)\n                    p := h\n                    for { let i := l } 1 {} {\n                        for {} 1 {} {\n                            i := add(i, s)\n                            if iszero(gt(x, mload(i))) { break }\n                        }\n                        let j := p\n                        for {} 1 {} {\n                            j := add(j, w)\n                            if iszero(lt(x, mload(j))) { break }\n                        }\n                        p := j\n                        if iszero(lt(i, p)) { break }\n                        // Swap slots `i` and `p`.\n                        let t := mload(i)\n                        mstore(i, mload(p))\n                        mstore(p, t)\n                    }\n                }\n                // If slice on right of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, add(p, s))\n                    // Skip `mstore(add(stack, 0x20), h)`, as it is already on the stack.\n                    stack := add(stack, shl(6, lt(add(p, s), h)))\n                }\n                // If slice on left of pivot is non-empty, push onto stack.\n                {\n                    mstore(stack, l)\n                    mstore(add(stack, s), p)\n                    stack := add(stack, shl(6, gt(p, l)))\n                }\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  OTHER USEFUL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance, the `uniquifySorted` methods will not revert if the\n    // array is not sorted -- it will simply remove consecutive duplicate elements.\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(uint160(needle)), 0);\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an int array.\n    function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an address array.\n    function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Converts an array of signed integers to unsigned\n    /// integers suitable for sorting or vice versa.\n    function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := shl(255, 1)\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, add(mload(a), w))\n            }\n        }\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/LibZip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                let w := mload(p_)\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function match(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p := add(mload(0x40), shl(2, i_))\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(mload(0x40), 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := match(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\n            result := mload(0x40)\n            let t := add(result, 0x8000)\n            let n := sub(op, t)\n            mstore(result, n) // Store the length.\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let o := add(result, 0x20)\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := 0\n            let end := add(add(data, 0x20), mload(data))\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(add(op, n), mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    n := add(n, add(1, c))\n                    continue\n                }\n                let g := eq(t, 7)\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w))))))\n                for {\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1)\n                    let r := add(op, sub(n, s))\n                    let o := add(op, n)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(o, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if iszero(lt(j, l)) { break }\n                }\n                data := add(data, add(2, g))\n                n := add(n, l)\n            }\n            mstore(result, n) // Store the length.\n            let o := add(add(result, 0x20), n)\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `receive` and `fallback` functions.\n    /// ```\n    ///     receive() external payable { LibZip.cdFallback(); }\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, 0x00, 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/MerkleProofLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\nlibrary MerkleProofLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := mul(iszero(iszero(flagsLength)), add(proof, shl(5, proofLength)))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required (i.e. `proofEnd != 0`).\n                        or(iszero(proofEnd), eq(proofEnd, proof))\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd :=\n                    mul(iszero(iszero(flags.length)), add(proof.offset, shl(5, proof.length)))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required (i.e. `proofEnd != 0`).\n                        or(iszero(proofEnd), eq(proofEnd, proof.offset))\n                    )\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bool array.\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/MetadataReaderLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for reading contract metadata robustly.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\nlibrary MetadataReaderLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                METADATA READING OPERATIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Best-effort string reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Returns the empty string for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns empty string.\n    // 2. Attempts to `abi.decode` the returndata into a string.\n    // 3. With any remaining gas, scans the returndata from start to end for the\n    //    null byte '\\0', to interpret the returndata as a null-terminated string.\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit)`.\n    function readName(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), limit);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit)`.\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), limit);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit);\n    }\n\n    // Best-effort unsigned integer reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Attempts to `abi.decode` the result into a uint256\n    //    (equivalent across all Solidity uint types, downcast as needed).\n    // 2. Returns zero for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns zero.\n    //     - `abi.decode` failure.\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimal()\")))`.\n    function readDecimals(address target) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567)));\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\n        return _uint(target, _ptr(data));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Attempts to read and return a string at `target`.\n    function _string(address target, bytes32 ptr, uint256 limit)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gas(), target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }\n\n    /// @dev Attempts to read and return a uint at `target`.\n    function _uint(address target, bytes32 ptr) private view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Casts the function selector `s` into a pointer.\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }\n\n    /// @dev Casts the `data` into a pointer.\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/MinHeapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing a min-heap in storage.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MinHeapLib.sol)\nlibrary MinHeapLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The heap is empty.\n    error HeapIsEmpty();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A heap in storage.\n    struct Heap {\n        uint256[] data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Tips:\n    // - To use as a max-map, negate the values.\n    // - If use on tuples, pack the tuple values into a single integer.\n    // - To use on signed integers, convert the signed integers into\n    //   their ordered unsigned counterparts via `uint256(x) + (1 << 255)`.\n\n    /// @dev Returns the minimum value of the heap.\n    /// Reverts if the heap is empty.\n    function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // Store the function selector of `HeapIsEmpty()`.\n                revert(0x1c, 0x04) // Revert with (offset, size).\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns the number of items in the heap.\n    function length(Heap storage heap) internal view returns (uint256) {\n        return heap.data.length;\n    }\n\n    /// @dev Pushes the `value` onto the min-heap.\n    function push(Heap storage heap, uint256 value) internal {\n        _set(heap, value, 0, 4);\n    }\n\n    /// @dev Pops the minimum value from the min-heap.\n    /// Reverts if the heap is empty.\n    function pop(Heap storage heap) internal returns (uint256 popped) {\n        (,, popped) = _set(heap, 0, 0, 3);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value.\n    function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (,, popped) = _set(heap, value, 0, 2);\n    }\n\n    /// @dev Pops the minimum value, and pushes the new `value` onto the min-heap.\n    /// Reverts if the heap is empty.\n    function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (,, popped) = _set(heap, value, 0, 1);\n    }\n\n    /// @dev Pushes the `value` onto the min-heap, and pops the minimum value\n    /// if the length of the heap exceeds `maxLength`.\n    ///\n    /// Reverts if `maxLength` is zero.\n    ///\n    /// - If the queue is not full:\n    ///   (`success` = true, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is not greater than the minimum value:\n    ///   (`success` = false, `hasPopped` = false, `popped` = 0)\n    /// - If the queue is full, and `value` is greater than the minimum value:\n    ///   (`success` = true, `hasPopped` = true, `popped` = <minimum value>)\n    ///\n    /// Useful for implementing a bounded priority queue.\n    function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (success, hasPopped, popped) = _set(heap, value, maxLength, 0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Helper function for heap operations.\n    /// Designed for code conciseness, bytecode compactness, and decent performance.\n    function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            // Compute the array storage slot offset.\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // Store the function selector of `HeapIsEmpty()`.\n                revert(0x1c, 0x04) // Revert with (offset, size).\n            } {\n                // `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    if iszero(eq(n, maxLength)) {\n                        // If queue is not full.\n                        success := 1\n                        // Increment and update the length.\n                        pos := n\n                        sstore(heap.slot, add(pos, 1))\n                        childPos := add(childPos, childPos)\n                        break\n                    }\n                    let r := sload(sOffset)\n                    if iszero(lt(r, value)) { break }\n                    success := 1\n                    hasPopped := 1\n                    childPos := 1\n                    popped := r\n                    break\n                }\n                // `replace`.\n                if eq(mode, 1) {\n                    if iszero(n) { continue }\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // `pushPop`.\n                if eq(mode, 2) {\n                    popped := value\n                    if iszero(n) { break }\n                    let r := sload(sOffset)\n                    if iszero(lt(r, value)) { break }\n                    popped := r\n                    childPos := 1\n                    break\n                }\n                // `pop`.\n                if eq(mode, 3) {\n                    if iszero(n) { continue }\n                    // Decrement and update the length.\n                    n := sub(n, 1)\n                    sstore(heap.slot, n)\n                    // Set the `value` to the last item.\n                    value := sload(add(sOffset, n))\n                    popped := value\n                    if iszero(n) { break }\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // `push`.\n                {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := add(childPos, childPos)\n                    break\n                }\n            }\n\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(and(lt(rightPos, n), iszero(lt(child, right)))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n\n            // If `childPos` is not `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract that enables a single call to call multiple methods on itself.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)\nabstract contract Multicallable {\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\n    /// If any of the `DELEGATECALL`s reverts, the entire context is reverted,\n    /// and the error is bubbled up.\n    ///\n    /// This function is deliberately made non-payable to guard against double-spending.\n    /// (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n    ///\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of a function\n    /// that returns `(bytes[] memory)`.\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory) {\n        assembly {\n            mstore(0x00, 0x20)\n            mstore(0x20, data.length) // Store `data.length` into `results`.\n            // Early return if no data.\n            if iszero(data.length) { return(0x00, 0x40) }\n\n            let results := 0x40\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := shl(5, data.length)\n            // Copy the offsets from calldata into memory.\n            calldatacopy(0x40, data.offset, end)\n            // Offset into `results`.\n            let resultsOffset := end\n            // Pointer to the end of `results`.\n            end := add(results, end)\n\n            for {} 1 {} {\n                // The offset of the current bytes in the calldata.\n                let o := add(data.offset, mload(results))\n                let memPtr := add(resultsOffset, 0x40)\n                // Copy the current bytes from calldata to the memory.\n                calldatacopy(\n                    memPtr,\n                    add(o, 0x20), // The offset of the current bytes' bytes.\n                    calldataload(o) // The length of the current bytes.\n                )\n                if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\n                    // Bubble up the revert if the delegatecall reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                // Append the current `resultsOffset` into `results`.\n                mstore(results, resultsOffset)\n                results := add(results, 0x20)\n                // Append the `returndatasize()`, and the return data.\n                mstore(memPtr, returndatasize())\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\n                // rounded up to the next multiple of 32.\n                resultsOffset :=\n                    and(add(add(resultsOffset, returndatasize()), 0x3f), 0xffffffffffffffe0)\n                if iszero(lt(results, end)) { break }\n            }\n            return(0x00, add(resultsOffset, 0x40))\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/RedBlackTreeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing a red-black-tree in storage.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/RedBlackTreeLib.sol)\n/// @author Modified from BokkyPooBahsRedBlackTreeLibrary\n/// (https://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary)\n/// @dev This red-black-tree does not support the zero (i.e. empty) value.\nlibrary RedBlackTreeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The value cannot be zero.\n    error ValueIsEmpty();\n\n    /// @dev Cannot insert a value that already exists.\n    error ValueAlreadyExists();\n\n    /// @dev Cannot remove a value that does not exist.\n    error ValueDoesNotExist();\n\n    /// @dev The pointer is out of bounds.\n    error PointerOutOfBounds();\n\n    /// @dev The tree is full.\n    error TreeIsFull();\n\n    /// @dev `bytes4(keccak256(bytes(\"ValueAlreadyExists()\")))`.\n    uint256 internal constant ERROR_VALUE_ALREADY_EXISTS = 0xbb33e6ac;\n\n    /// @dev `bytes4(keccak256(bytes(\"ValueDoesNotExist()\")))`.\n    uint256 internal constant ERROR_VALUE_DOES_NOT_EXISTS = 0xb113638a;\n\n    /// @dev `bytes4(keccak256(bytes(\"PointerOutOfBounds()\")))`.\n    uint256 internal constant ERROR_POINTER_OUT_OF_BOUNDS = 0xccd52fbc;\n\n    /// @dev `bytes4(keccak256(bytes(\"TreeIsFull()\")))`.\n    uint256 internal constant ERROR_TREE_IS_FULL = 0xed732d0c;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A red-black-tree in storage.\n    struct Tree {\n        uint256 _spacer;\n    }\n\n    // Custom storage:\n    // ```\n    // mstore(0x20, tree.slot)\n    // mstore(0x00, _NODES_SLOT_SEED)\n    // let nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n    //\n    // let root := shr(128, sload(nodes))\n    // let totalNodes := and(sload(nodes), _BITMASK_KEY)\n    //\n    // let nodePacked := sload(or(nodes, nodeIndex))\n    // let nodeLeft   := and(nodePacked, _BITMASK_KEY)\n    // let nodeRight  := and(shr(_BITPOS_RIGHT, nodePacked), _BITMASK_KEY)\n    // let nodeParent := and(shr(_BITPOS_PARENT, nodePacked), _BITMASK_KEY)\n    // let nodeRed    := and(shr(_BITPOS_RED, nodePacked), 1)\n    //\n    // let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)\n    // if iszero(nodeValue) {\n    //     nodeValue := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes, nodeIndex)))\n    // }\n    // ```\n\n    uint256 private constant _NODES_SLOT_SEED = 0x1dc27bb5462fdadcb;\n    uint256 private constant _NODES_SLOT_SHIFT = 32;\n    uint256 private constant _BITMASK_KEY = (1 << 31) - 1;\n    uint256 private constant _BITPOS_LEFT = 0;\n    uint256 private constant _BITPOS_RIGHT = 31;\n    uint256 private constant _BITPOS_PARENT = 31 * 2;\n    uint256 private constant _BITPOS_RED = 31 * 3;\n    uint256 private constant _BITMASK_RED = 1 << (31 * 3);\n    uint256 private constant _BITPOS_PACKED_VALUE = 96;\n    uint256 private constant _BITMASK_PACKED_VALUE = (1 << 160) - 1;\n    uint256 private constant _BIT_FULL_VALUE_SLOT = 1 << 31;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of unique values in the tree.\n    function size(Tree storage tree) internal view returns (uint256 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(sload(nodes), _BITMASK_KEY)\n        }\n    }\n\n    /// @dev Returns a pointer to the value `x`.\n    /// If the value `x` is not in the tree, the returned pointer will be empty.\n    function find(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        result = _pack(nodes, key);\n    }\n\n    /// @dev Returns a pointer to the nearest value to `x`.\n    /// In a tie-breaker, the returned pointer will point to the smaller value.\n    /// If the tree is empty, the returned pointer will be empty.\n    function nearest(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        unchecked {\n            if (cursor == 0) return result; // Nothing found -- empty tree.\n            if (key != 0) return _pack(nodes, key); // Exact match.\n            bytes32 a = _pack(nodes, cursor);\n            uint256 aValue = value(a);\n            bytes32 b = x < aValue ? prev(a) : next(a);\n            if (b == bytes32(0)) return a; // Only node found.\n            uint256 bValue = value(b);\n            uint256 aDist = x < aValue ? aValue - x : x - aValue;\n            uint256 bDist = x < bValue ? bValue - x : x - bValue;\n            if (aDist == bDist) return aValue < bValue ? a : b; // Tie-breaker.\n            return aDist < bDist ? a : b;\n        }\n    }\n\n    /// @dev Returns a pointer to the nearest value lesser or equal to `x`.\n    /// If there is no value lesser or equal to `x`, the returned pointer will be empty.\n    function nearestBefore(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == 0) return result; // Nothing found -- empty tree.\n        if (key != 0) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) < x ? a : prev(a);\n    }\n\n    /// @dev Returns a pointer to the nearest value greater or equal to `x`.\n    /// If there is no value greater or equal to `x`, the returned pointer will be empty.\n    function nearestAfter(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == 0) return result; // Nothing found -- empty tree.\n        if (key != 0) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) > x ? a : next(a);\n    }\n\n    /// @dev Returns whether the value `x` exists.\n    function exists(Tree storage tree, uint256 x) internal view returns (bool result) {\n        (,, uint256 key) = _find(tree, x);\n        result = key != 0;\n    }\n\n    /// @dev Inserts the value `x` into the tree.\n    /// Reverts if the value `x` already exists.\n    function insert(Tree storage tree, uint256 x) internal {\n        uint256 err = tryInsert(tree, x);\n        if (err != 0) _revert(err);\n    }\n\n    /// @dev Inserts the value `x` into the tree.\n    /// Returns a non-zero error code upon failure instead of reverting\n    /// (except for reverting if `x` is an empty value).\n    function tryInsert(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        err = _update(nodes, cursor, key, x, 0);\n    }\n\n    /// @dev Removes the value `x` from the tree.\n    /// Reverts if the value does not exist.\n    function remove(Tree storage tree, uint256 x) internal {\n        uint256 err = tryRemove(tree, x);\n        if (err != 0) _revert(err);\n    }\n\n    /// @dev Removes the value `x` from the tree.\n    /// Returns a non-zero error code upon failure instead of reverting\n    /// (except for reverting if `x` is an empty value).\n    function tryRemove(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        err = _update(nodes, 0, key, 0, 1);\n    }\n\n    /// @dev Removes the value at pointer `ptr` from the tree.\n    /// Reverts if `ptr` is empty (i.e. value does not exist),\n    /// or if `ptr` is out of bounds.\n    /// After removal, `ptr` may point to another existing value.\n    /// For safety, do not reuse `ptr` after calling remove on it.\n    function remove(bytes32 ptr) internal {\n        uint256 err = tryRemove(ptr);\n        if (err != 0) _revert(err);\n    }\n\n    /// @dev Removes the value at pointer `ptr` from the tree.\n    /// Returns a non-zero error code upon failure instead of reverting.\n    function tryRemove(bytes32 ptr) internal returns (uint256 err) {\n        (uint256 nodes, uint256 key) = _unpack(ptr);\n        err = _update(nodes, 0, key, 0, 1);\n    }\n\n    /// @dev Clears the entire tree. All data will be deleted from storage.\n    function clear(Tree storage tree) internal {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalNodes := and(sload(nodes), _BITMASK_KEY)\n            for { let i := 1 } iszero(gt(i, totalNodes)) { i := add(i, 1) } {\n                let ptr := or(nodes, i)\n                if iszero(shr(_BITPOS_PACKED_VALUE, sload(ptr))) {\n                    sstore(or(ptr, _BIT_FULL_VALUE_SLOT), 0)\n                }\n                sstore(ptr, 0)\n            }\n            sstore(nodes, 0)\n        }\n    }\n\n    /// @dev Returns the value at pointer `ptr`.\n    /// If `ptr` is empty, the result will be zero.\n    function value(bytes32 ptr) internal view returns (uint256 result) {\n        if (ptr == bytes32(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            result := shr(_BITPOS_PACKED_VALUE, packed)\n            if iszero(result) { result := sload(or(ptr, _BIT_FULL_VALUE_SLOT)) }\n        }\n    }\n\n    /// @dev Returns a pointer to the smallest value in the tree.\n    /// If the tree is empty, the returned pointer will be empty.\n    function first(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_LEFT);\n    }\n\n    /// @dev Returns a pointer to the largest value in the tree.\n    /// If the tree is empty, the returned pointer will be empty.\n    function last(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_RIGHT);\n    }\n\n    /// @dev Returns the pointer to the next largest value.\n    /// If there is no next value, or if `ptr` is empty,\n    /// the returned pointer will be empty.\n    function next(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_LEFT, _BITPOS_RIGHT);\n    }\n\n    /// @dev Returns the pointer to the next smallest value.\n    /// If there is no previous value, or if `ptr` is empty,\n    /// the returned pointer will be empty.\n    function prev(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_RIGHT, _BITPOS_LEFT);\n    }\n\n    /// @dev Returns whether the pointer is empty.\n    function isEmpty(bytes32 ptr) internal pure returns (bool result) {\n        result = ptr == bytes32(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unpacks the pointer `ptr` to its components.\n    function _unpack(bytes32 ptr) private pure returns (uint256 nodes, uint256 key) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            nodes := shl(_NODES_SLOT_SHIFT, shr(_NODES_SLOT_SHIFT, ptr))\n            key := and(_BITMASK_KEY, ptr)\n        }\n    }\n\n    /// @dev Packs `nodes` and `key` into a single pointer.\n    function _pack(uint256 nodes, uint256 key) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(or(nodes, key), iszero(iszero(key)))\n        }\n    }\n\n    /// @dev Returns the pointer to either end of the tree.\n    function _end(Tree storage tree, uint256 L) private view returns (bytes32 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(128, sload(nodes))\n            if result {\n                for {} 1 {} {\n                    let packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }\n\n    /// @dev Step the pointer `ptr` forwards or backwards.\n    function _step(bytes32 ptr, uint256 L, uint256 R) private view returns (bytes32 result) {\n        if (ptr == bytes32(0)) return ptr;\n        (uint256 nodes, uint256 target) = _unpack(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            for { result := and(shr(R, packed), _BITMASK_KEY) } 1 {} {\n                if iszero(result) {\n                    result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    for {} 1 {} {\n                        if iszero(result) { break }\n                        packed := sload(or(nodes, result))\n                        if iszero(eq(target, and(shr(R, packed), _BITMASK_KEY))) { break }\n                        target := result\n                        result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n                break\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }\n\n    /// @dev Inserts or delete the value `x` from the tree.\n    function _update(uint256 nodes, uint256 cursor, uint256 key, uint256 x, uint256 mode)\n        private\n        returns (uint256 err)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function getKey(packed_, bitpos_) -> index_ {\n                index_ := and(shr(bitpos_, packed_), _BITMASK_KEY)\n            }\n\n            function setKey(packed_, bitpos_, key_) -> result_ {\n                result_ := or(and(not(shl(bitpos_, _BITMASK_KEY)), packed_), shl(bitpos_, key_))\n            }\n\n            function setRed(packed_, red_) -> result_ {\n                result_ := or(and(not(_BITMASK_RED), packed_), shl(_BITPOS_RED, red_))\n            }\n\n            function isRed(packed_) -> red_ {\n                red_ := and(_BITMASK_RED, packed_)\n            }\n\n            function copyRed(packed_, fromPacked_) -> result_ {\n                result_ := or(and(not(_BITMASK_RED), packed_), and(_BITMASK_RED, fromPacked_))\n            }\n\n            function rotate(nodes_, key_, L, R) {\n                let packed_ := sload(or(nodes_, key_))\n                let cursor_ := getKey(packed_, R)\n                let parent_ := getKey(packed_, _BITPOS_PARENT)\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let cursorLeft_ := getKey(cursorPacked_, L)\n\n                if cursorLeft_ {\n                    let s_ := or(nodes_, cursorLeft_)\n                    sstore(s_, setKey(sload(s_), _BITPOS_PARENT, key_))\n                }\n\n                for {} 1 {} {\n                    if iszero(parent_) {\n                        mstore(0x00, cursor_)\n                        break\n                    }\n                    let s_ := or(nodes_, parent_)\n                    let parentPacked_ := sload(s_)\n                    if eq(key_, getKey(parentPacked_, L)) {\n                        sstore(s_, setKey(parentPacked_, L, cursor_))\n                        break\n                    }\n                    sstore(s_, setKey(parentPacked_, R, cursor_))\n                    break\n                }\n                packed_ := setKey(packed_, R, cursorLeft_)\n                sstore(or(nodes_, key_), setKey(packed_, _BITPOS_PARENT, cursor_))\n                cursorPacked_ := setKey(cursorPacked_, _BITPOS_PARENT, parent_)\n                sstore(or(nodes_, cursor_), setKey(cursorPacked_, L, key_))\n            }\n\n            function insertFixup(nodes_, key_) {\n                for {} 1 {} {\n                    if eq(key_, mload(0x00)) { break }\n                    let packed_ := sload(or(nodes_, key_))\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n                    if iszero(isRed(parentPacked_)) { break }\n\n                    let grandParent_ := getKey(parentPacked_, _BITPOS_PARENT)\n                    let grandParentPacked_ := sload(or(nodes_, grandParent_))\n\n                    let R := mul(eq(parent_, getKey(grandParentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let cursor_ := getKey(grandParentPacked_, R)\n                    let cursorPacked_ := sload(or(nodes_, cursor_))\n                    if iszero(isRed(cursorPacked_)) {\n                        if eq(key_, getKey(parentPacked_, R)) {\n                            key_ := parent_\n                            rotate(nodes_, key_, L, R)\n                        }\n                        parent_ := getKey(sload(or(nodes_, key_)), _BITPOS_PARENT)\n                        parentPacked_ := sload(or(nodes_, parent_))\n                        sstore(or(nodes_, parent_), setRed(parentPacked_, 0))\n                        grandParent_ := getKey(parentPacked_, _BITPOS_PARENT)\n                        let s_ := or(nodes_, grandParent_)\n                        sstore(s_, setRed(sload(s_), 1))\n                        rotate(nodes_, grandParent_, R, L)\n                        continue\n                    }\n                    sstore(or(nodes_, parent_), setRed(parentPacked_, 0))\n                    sstore(or(nodes_, cursor_), setRed(cursorPacked_, 0))\n                    sstore(or(nodes_, grandParent_), setRed(grandParentPacked_, 1))\n                    key_ := grandParent_\n                }\n                let root_ := mload(0x00)\n                sstore(or(nodes_, root_), setRed(sload(or(nodes_, root_)), 0))\n            }\n\n            function insert(nodes_, cursor_, key_, x_) -> err_ {\n                if key_ {\n                    err_ := ERROR_VALUE_ALREADY_EXISTS\n                    leave\n                }\n\n                let totalNodes_ := add(shr(128, mload(0x20)), 1)\n\n                if gt(totalNodes_, _BITMASK_KEY) {\n                    err_ := ERROR_TREE_IS_FULL\n                    leave\n                }\n\n                mstore(0x20, shl(128, totalNodes_))\n\n                let packed_ := or(_BITMASK_RED, shl(_BITPOS_PARENT, cursor_))\n                let nodePointer_ := or(nodes_, totalNodes_)\n\n                for {} 1 {} {\n                    if iszero(gt(x_, _BITMASK_PACKED_VALUE)) {\n                        packed_ := or(shl(_BITPOS_PACKED_VALUE, x_), packed_)\n                        break\n                    }\n                    sstore(or(nodePointer_, _BIT_FULL_VALUE_SLOT), x_)\n                    break\n                }\n                sstore(nodePointer_, packed_)\n\n                for {} 1 {} {\n                    if iszero(cursor_) {\n                        mstore(0x00, totalNodes_)\n                        break\n                    }\n                    let s_ := or(nodes_, cursor_)\n                    let cursorPacked_ := sload(s_)\n                    let cursorValue_ := shr(_BITPOS_PACKED_VALUE, cursorPacked_)\n                    if iszero(cursorValue_) { cursorValue_ := sload(or(s_, _BIT_FULL_VALUE_SLOT)) }\n                    if iszero(lt(x_, cursorValue_)) {\n                        sstore(s_, setKey(cursorPacked_, _BITPOS_RIGHT, totalNodes_))\n                        break\n                    }\n                    sstore(s_, setKey(cursorPacked_, _BITPOS_LEFT, totalNodes_))\n                    break\n                }\n                insertFixup(nodes_, totalNodes_)\n            }\n\n            function removeFixup(nodes_, key_) {\n                for {} 1 {} {\n                    if eq(key_, mload(0x00)) { break }\n                    let packed_ := sload(or(nodes_, key_))\n                    if isRed(packed_) { break }\n\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n\n                    let R := mul(eq(key_, getKey(parentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let cursor_ := getKey(parentPacked_, R)\n                    let cursorPacked_ := sload(or(nodes_, cursor_))\n\n                    if isRed(cursorPacked_) {\n                        sstore(or(nodes_, cursor_), setRed(cursorPacked_, 0))\n                        sstore(or(nodes_, parent_), setRed(parentPacked_, 1))\n                        rotate(nodes_, parent_, L, R)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                    }\n\n                    let cursorLeft_ := getKey(cursorPacked_, L)\n                    let cursorLeftPacked_ := sload(or(nodes_, cursorLeft_))\n                    let cursorRight_ := getKey(cursorPacked_, R)\n                    let cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n\n                    if iszero(or(isRed(cursorLeftPacked_), isRed(cursorRightPacked_))) {\n                        sstore(or(nodes_, cursor_), setRed(cursorPacked_, 1))\n                        key_ := parent_\n                        continue\n                    }\n\n                    if iszero(isRed(cursorRightPacked_)) {\n                        sstore(or(nodes_, cursorLeft_), setRed(cursorLeftPacked_, 0))\n                        sstore(or(nodes_, cursor_), setRed(cursorPacked_, 1))\n                        rotate(nodes_, cursor_, R, L)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                        cursorRight_ := getKey(cursorPacked_, R)\n                        cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n                    }\n\n                    parentPacked_ := sload(or(nodes_, parent_))\n                    sstore(or(nodes_, cursor_), copyRed(cursorPacked_, parentPacked_))\n                    sstore(or(nodes_, parent_), setRed(parentPacked_, 0))\n                    sstore(or(nodes_, cursorRight_), setRed(cursorRightPacked_, 0))\n                    rotate(nodes_, parent_, L, R)\n                    break\n                }\n                sstore(or(nodes_, key_), setRed(sload(or(nodes_, key_)), 0))\n            }\n\n            function removeLast(nodes_, cursor_) {\n                let last_ := shr(128, mload(0x20))\n                let lastPacked_ := sload(or(nodes_, last_))\n                let lastValue_ := shr(_BITPOS_PACKED_VALUE, lastPacked_)\n                let lastFullValue_ := 0\n                if iszero(lastValue_) {\n                    lastValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)))\n                    lastFullValue_ := lastValue_\n                }\n\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let cursorValue_ := shr(_BITPOS_PACKED_VALUE, cursorPacked_)\n                let cursorFullValue_ := 0\n                if iszero(cursorValue_) {\n                    cursorValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)))\n                    cursorFullValue_ := cursorValue_\n                }\n\n                if iszero(eq(lastValue_, cursorValue_)) {\n                    sstore(or(nodes_, cursor_), lastPacked_)\n                    if iszero(eq(lastFullValue_, cursorFullValue_)) {\n                        sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)), lastFullValue_)\n                    }\n                    for { let lastParent_ := getKey(lastPacked_, _BITPOS_PARENT) } 1 {} {\n                        if iszero(lastParent_) {\n                            mstore(0x00, cursor_)\n                            break\n                        }\n                        let s_ := or(nodes_, lastParent_)\n                        let p_ := sload(s_)\n                        let t_ := iszero(eq(last_, getKey(p_, _BITPOS_LEFT)))\n                        sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), cursor_))\n                        break\n                    }\n                    let lastRight_ := getKey(lastPacked_, _BITPOS_RIGHT)\n                    if lastRight_ {\n                        let s_ := or(nodes_, lastRight_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                    let lastLeft_ := getKey(lastPacked_, _BITPOS_LEFT)\n                    if lastLeft_ {\n                        let s_ := or(nodes_, lastLeft_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                }\n                sstore(or(nodes_, last_), 0)\n                if lastFullValue_ { sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)), 0) }\n\n                mstore(0x20, shl(128, sub(last_, 1)))\n            }\n\n            function remove(nodes_, key_) -> err_ {\n                let last_ := shr(128, mload(0x20))\n\n                if gt(key_, last_) {\n                    err_ := ERROR_POINTER_OUT_OF_BOUNDS\n                    leave\n                }\n                if iszero(key_) {\n                    err_ := ERROR_VALUE_DOES_NOT_EXISTS\n                    leave\n                }\n\n                let cursor_ := 0\n\n                for {} 1 {} {\n                    let packed_ := sload(or(nodes_, key_))\n                    let left_ := getKey(packed_, _BITPOS_LEFT)\n                    let right_ := getKey(packed_, _BITPOS_RIGHT)\n                    if iszero(mul(left_, right_)) {\n                        cursor_ := key_\n                        break\n                    }\n                    cursor_ := right_\n                    for {} 1 {} {\n                        let cursorLeft_ := getKey(sload(or(nodes_, cursor_)), _BITPOS_LEFT)\n                        if iszero(cursorLeft_) { break }\n                        cursor_ := cursorLeft_\n                    }\n                    break\n                }\n\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let probe_ := getKey(cursorPacked_, _BITPOS_LEFT)\n                if iszero(probe_) { probe_ := getKey(cursorPacked_, _BITPOS_RIGHT) }\n\n                for { let yParent_ := getKey(cursorPacked_, _BITPOS_PARENT) } 1 {} {\n                    let probeSlot_ := or(nodes_, probe_)\n                    sstore(probeSlot_, setKey(sload(probeSlot_), _BITPOS_PARENT, yParent_))\n\n                    if iszero(yParent_) {\n                        mstore(0x00, probe_)\n                        break\n                    }\n                    let s_ := or(nodes_, yParent_)\n                    let p_ := sload(s_)\n                    let t_ := iszero(eq(cursor_, getKey(p_, _BITPOS_LEFT)))\n                    sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), probe_))\n                    break\n                }\n\n                let skipFixup_ := isRed(cursorPacked_)\n\n                if iszero(eq(cursor_, key_)) {\n                    let packed_ := sload(or(nodes_, key_))\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    for {} 1 {} {\n                        if iszero(parent_) {\n                            mstore(0x00, cursor_)\n                            break\n                        }\n                        let s_ := or(nodes_, parent_)\n                        let p_ := sload(s_)\n                        let t_ := iszero(eq(key_, getKey(p_, _BITPOS_LEFT)))\n                        sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), cursor_))\n                        break\n                    }\n\n                    let left_ := getKey(packed_, _BITPOS_LEFT)\n                    let leftSlot_ := or(nodes_, left_)\n                    sstore(leftSlot_, setKey(sload(leftSlot_), _BITPOS_PARENT, cursor_))\n\n                    let right_ := getKey(packed_, _BITPOS_RIGHT)\n                    let rightSlot_ := or(nodes_, right_)\n                    sstore(rightSlot_, setKey(sload(rightSlot_), _BITPOS_PARENT, cursor_))\n\n                    let m_ := sub(shl(_BITPOS_PACKED_VALUE, 1), 1)\n                    sstore(\n                        or(nodes_, cursor_),\n                        xor(cursorPacked_, and(xor(packed_, cursorPacked_), m_))\n                    )\n\n                    let t_ := cursor_\n                    cursor_ := key_\n                    key_ := t_\n                }\n                if iszero(skipFixup_) { removeFixup(nodes_, probe_) }\n\n                removeLast(nodes_, cursor_)\n            }\n\n            mstore(0x10, sload(nodes))\n\n            for {} 1 {} {\n                if iszero(mode) {\n                    err := insert(nodes, cursor, key, x)\n                    break\n                }\n                err := remove(nodes, key)\n                break\n            }\n\n            sstore(nodes, mload(0x10))\n        }\n    }\n\n    /// @dev Returns the pointer to the `nodes` for the tree.\n    function _nodes(Tree storage tree) private pure returns (uint256 nodes) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Finds `x` in `tree`. The `key` will be zero if `x` is not found.\n    function _find(Tree storage tree, uint256 x)\n        private\n        view\n        returns (uint256 nodes, uint256 cursor, uint256 key)\n    {\n        if (x == 0) _revert(0xc94f1877); // `ValueIsEmpty()`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n\n            mstore(0x01, _BITPOS_RIGHT)\n            for { let probe := shr(128, sload(nodes)) } probe {} {\n                cursor := probe\n                let nodePacked := sload(or(nodes, probe))\n                let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)\n                if iszero(nodeValue) {\n                    nodeValue := sload(or(or(nodes, probe), _BIT_FULL_VALUE_SLOT))\n                }\n                if eq(nodeValue, x) {\n                    key := cursor\n                    break\n                }\n                probe := and(shr(mload(gt(x, nodeValue)), nodePacked), _BITMASK_KEY)\n            }\n        }\n    }\n\n    /// @dev Helper to revert `err` efficiently.\n    function _revert(uint256 err) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, err)\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error Overflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt8(int256 x) internal pure returns (int8) {\n        int8 y = int8(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt16(int256 x) internal pure returns (int16) {\n        int16 y = int16(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt24(int256 x) internal pure returns (int24) {\n        int24 y = int24(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt32(int256 x) internal pure returns (int32) {\n        int32 y = int32(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt40(int256 x) internal pure returns (int40) {\n        int40 y = int40(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt48(int256 x) internal pure returns (int48) {\n        int48 y = int48(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt56(int256 x) internal pure returns (int56) {\n        int56 y = int56(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt64(int256 x) internal pure returns (int64) {\n        int64 y = int64(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt72(int256 x) internal pure returns (int72) {\n        int72 y = int72(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt80(int256 x) internal pure returns (int80) {\n        int80 y = int80(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt88(int256 x) internal pure returns (int88) {\n        int88 y = int88(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt96(int256 x) internal pure returns (int96) {\n        int96 y = int96(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt104(int256 x) internal pure returns (int104) {\n        int104 y = int104(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt112(int256 x) internal pure returns (int112) {\n        int112 y = int112(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt120(int256 x) internal pure returns (int120) {\n        int120 y = int120(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt128(int256 x) internal pure returns (int128) {\n        int128 y = int128(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt136(int256 x) internal pure returns (int136) {\n        int136 y = int136(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt144(int256 x) internal pure returns (int144) {\n        int144 y = int144(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt152(int256 x) internal pure returns (int152) {\n        int152 y = int152(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt160(int256 x) internal pure returns (int160) {\n        int160 y = int160(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt168(int256 x) internal pure returns (int168) {\n        int168 y = int168(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt176(int256 x) internal pure returns (int176) {\n        int176 y = int176(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt184(int256 x) internal pure returns (int184) {\n        int184 y = int184(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt192(int256 x) internal pure returns (int192) {\n        int192 y = int192(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt200(int256 x) internal pure returns (int200) {\n        int200 y = int200(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt208(int256 x) internal pure returns (int208) {\n        int208 y = int208(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt216(int256 x) internal pure returns (int216) {\n        int216 y = int216(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt224(int256 x) internal pure returns (int224) {\n        int224 y = int224(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt232(int256 x) internal pure returns (int232) {\n        int232 y = int232(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt240(int256 x) internal pure returns (int240) {\n        int240 y = int240(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt248(int256 x) internal pure returns (int248) {\n        int248 y = int248(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (x >= 1 << 255) _revertOverflow();\n        return int256(x);\n    }\n\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x < 0) _revertOverflow();\n        return uint256(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n/// responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    ///\n    /// Note: This implementation does NOT protect against gas griefing.\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // To coerce gas estimation to provide enough gas for the `create` above.\n                    if iszero(gt(gas(), 1000000)) { revert(0x00, 0x00) }\n                }\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overridden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, 0x00, 0x00, 0x00, 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // To coerce gas estimation to provide enough gas for the `create` above.\n                    if iszero(gt(gas(), 1000000)) { revert(0x00, 0x00) }\n                }\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x0c, 0x70a08231000000000000000000000000)\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            // The `amount` is already at 0x60. Load it for the function's return value.\n            amount := mload(0x60)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x14, to) // Store the `to` argument.\n            // The `amount` is already at 0x34. Load it for the function's return value.\n            amount := mload(0x34)\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`.\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`.\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // Store the function selector.\n                // We can ignore the result of this call. Just need to check the next call.\n                pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00))\n                mstore(0x34, amount) // Store back the original `amount`.\n\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())),\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    // Store the function selector of `ApproveFailed()`.\n                    mstore(0x00, 0x3e3f8f73)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x00, 0x70a08231000000000000000000000000)\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/SignatureCheckerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note: Unlike ECDSA signatures, contract signatures are revocable.\n///\n/// WARNING! Do NOT use signatures as unique identifiers.\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                let signatureLength := mload(signature)\n                if eq(signatureLength, 65) {\n                    mstore(m, hash)\n                    mstore(add(m, 0x20), byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(add(m, 0x40), mload(add(signature, 0x20))) // `r`.\n                    mstore(add(m, 0x60), mload(add(signature, 0x40))) // `s`.\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            m, // Start of input.\n                            0x80, // Size of input.\n                            m, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if mul(eq(mload(m), signer), returndatasize()) {\n                        isValid := 1\n                        break\n                    }\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, signatureLength)\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    and(\n                        // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                        eq(mload(0x00), f),\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                        eq(returndatasize(), 0x20)\n                    ),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signatureLength, 0x64), // Length of calldata in memory.\n                        0x00, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                if eq(signature.length, 65) {\n                    mstore(m, hash)\n                    mstore(add(m, 0x20), byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(add(m, 0x40), signature.offset, 0x40) // `r`, `s`.\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            m, // Start of input.\n                            0x80, // Size of input.\n                            m, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if mul(eq(mload(m), signer), returndatasize()) {\n                        isValid := 1\n                        break\n                    }\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    and(\n                        // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                        eq(mload(0x00), f),\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                        eq(returndatasize(), 0x20)\n                    ),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        0x00, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        uint8 v;\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        isValid = isValidSignatureNow(signer, hash, v, r, s);\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(m, hash)\n                mstore(add(m, 0x20), and(v, 0xff)) // `v`.\n                mstore(add(m, 0x40), r) // `r`.\n                mstore(add(m, 0x60), s) // `s`.\n                pop(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        m, // Start of input.\n                        0x80, // Size of input.\n                        m, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if mul(eq(mload(m), signer), returndatasize()) {\n                    isValid := 1\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    and(\n                        // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                        eq(mload(0x00), f),\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                        eq(returndatasize(), 0x20)\n                    ),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        0x00, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let signatureLength := mload(signature)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, signatureLength)\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(0x00), f),\n                    // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                    eq(returndatasize(), 0x20)\n                ),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signatureLength, 0x64), // Length of calldata in memory.\n                    0x00, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(0x00), f),\n                    // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                    eq(returndatasize(), 0x20)\n                ),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    0x00, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        uint8 v;\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        isValid = isValidERC1271SignatureNow(signer, hash, v, r, s);\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(0x00), f),\n                    // Whether the returndata is exactly 0x20 bytes (1 word) long.\n                    eq(returndatasize(), 0x20)\n                ),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    0x00, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
    },
    "contracts/core/libraries/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASIZE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"
    },
    "contracts/core/Registry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC20} from \"./libraries/tokens/ERC20.sol\";\n// Interfaces\nimport \"./interfaces/IRegistry.sol\";\n// Internal Libraries\nimport {Anchor} from \"./Anchor.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {Metadata} from \"./libraries/Metadata.sol\";\nimport \"./libraries/Native.sol\";\nimport \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Registry Contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Registry contract for creating and managing profiles\n/// @dev This contract is used to create and manage profiles for the Allo protocol\n///      It is also used to deploy the anchor contract for each profile which acts as a proxy\n///      for the profile and is used to receive funds and execute transactions on behalf of the profile\n///      The Registry is also used to add and remove members from a profile and update the profile 'Metadata'\ncontract Registry is IRegistry, Initializable, Native, AccessControlUpgradeable, Transfer, Errors {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice This maps the anchor address to the profile ID\n    /// @dev anchor -> Profile.id\n    mapping(address => bytes32) public anchorToProfileId;\n\n    /// @notice This maps the profile ID to the profile details\n    /// @dev Profile.id -> Profile\n    mapping(bytes32 => Profile) public profilesById;\n\n    /// @notice This maps the profile ID to the pending owner\n    /// @dev Profile.id -> pending owner\n    mapping(bytes32 => address) public profileIdToPendingOwner;\n\n    /// @notice Allo Owner Role for fund recovery\n    bytes32 public constant ALLO_OWNER = keccak256(\"ALLO_OWNER\");\n\n    /// ====================================\n    /// =========== Modifier ===============\n    /// ====================================\n\n    /// @notice Checks if the caller is the profile owner\n    /// @dev Reverts `UNAUTHORIZED()` if the caller is not the profile owner\n    /// @param _profileId The ID of the profile\n    modifier onlyProfileOwner(bytes32 _profileId) {\n        _checkOnlyProfileOwner(_profileId);\n        _;\n    }\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer. Reverts if the '_owner' is the 'address(0)'\n    /// @param _owner The owner of the contract\n    function initialize(address _owner) external reinitializer(1) {\n        // Make sure the owner is not 'address(0)'\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Grant the role to the owner\n        _grantRole(ALLO_OWNER, _owner);\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Retrieve profile by profileId\n    /// @dev Used when you have the 'profileId' and want to retrieve the profile\n    /// @param _profileId The ID of the profile\n    /// @return The Profile details for the `_profileId`\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory) {\n        return profilesById[_profileId];\n    }\n\n    /// @notice Retrieve profile by anchor\n    /// @dev Used when you have the 'anchor' address and want to retrieve the profile\n    /// @param _anchor The anchor of the profile\n    /// @return Profile details for the `_anchor`\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory) {\n        bytes32 profileId = anchorToProfileId[_anchor];\n        return profilesById[profileId];\n    }\n\n    /// @notice Creates a new profile\n    /// @dev This will also generate the 'profileId' and 'anchor' address, emits a 'ProfileCreated()' event\n    /// Note: The 'nonce' is used to generate the 'profileId' and should be unique for each profile\n    /// Note: The 'name' and 'profileId' are used to generate the 'anchor' address\n    /// @param _nonce Nonce used to generate profileId. Can be any integer, but should be unique\n    ///               for each profile.\n    /// @param _name The name of the profile\n    /// @param _metadata The metadata of the profile\n    /// @param _owner The owner of the profile\n    /// @param _members The members of the profile (can be set only if msg.sender == _owner)\n    /// @return The ID for the created profile\n    function createProfile(\n        uint256 _nonce,\n        string memory _name,\n        Metadata memory _metadata,\n        address _owner,\n        address[] memory _members\n    ) external returns (bytes32) {\n        // Generate a profile ID using a nonce and the msg.sender\n        bytes32 profileId = _generateProfileId(_nonce, _owner);\n\n        // Make sure the nonce is available\n        if (profilesById[profileId].anchor != address(0)) revert NONCE_NOT_AVAILABLE();\n\n        // Make sure the owner is not the zero address\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Create a new Profile instance, also generates the anchor address\n        Profile memory profile = Profile({\n            id: profileId,\n            nonce: _nonce,\n            name: _name,\n            metadata: _metadata,\n            owner: _owner,\n            anchor: _generateAnchor(profileId, _name)\n        });\n\n        profilesById[profileId] = profile;\n        anchorToProfileId[profile.anchor] = profileId;\n\n        // Assign roles for the profile members\n        uint256 memberLength = _members.length;\n\n        // Only profile owner can add members\n        if (memberLength > 0 && _owner != msg.sender) {\n            revert UNAUTHORIZED();\n        }\n\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Emit the event that the profile was created\n        emit ProfileCreated(profileId, profile.nonce, profile.name, profile.metadata, profile.owner, profile.anchor);\n\n        // Return the profile ID\n        return profileId;\n    }\n\n    /// @notice Updates the name of the profile and generates new anchor.\n    ///         Emits a 'ProfileNameUpdated()' event.\n    /// @dev Use caution when updating your profile name as it will generate a new anchor address. You can always update the name\n    ///      back to the original name to get the original anchor address. 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The profileId of the profile\n    /// @param _name The new name of the profile\n    /// @return anchor The new anchor\n    function updateProfileName(bytes32 _profileId, string memory _name)\n        external\n        onlyProfileOwner(_profileId)\n        returns (address anchor)\n    {\n        // Generate a new anchor address\n        anchor = _generateAnchor(_profileId, _name);\n\n        // Get the profile using the profileId from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Set the new name\n        profile.name = _name;\n\n        // Remove old anchor\n        anchorToProfileId[profile.anchor] = bytes32(0);\n\n        // Set the new anchor\n        profile.anchor = anchor;\n        anchorToProfileId[anchor] = _profileId;\n\n        // Emit the event that the name was updated with the new data\n        emit ProfileNameUpdated(_profileId, _name, anchor);\n\n        // Return the new anchor\n        return anchor;\n    }\n\n    /// @notice Update the 'Metadata' of the profile. Emits a 'ProfileMetadataUpdated()' event.\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _metadata The new 'Metadata' of the profile\n    function updateProfileMetadata(bytes32 _profileId, Metadata memory _metadata)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Get the profile using the 'profileId' from the mapping and update the 'Metadata' value\n        profilesById[_profileId].metadata = _metadata;\n\n        // Emit the event that the 'Metadata' was updated\n        emit ProfileMetadataUpdated(_profileId, _metadata);\n    }\n\n    /// @notice Checks if the address is an owner or member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _account The address to check\n    /// @return 'true' if the address is an owner or member of the profile, otherwise 'false'\n    function isOwnerOrMemberOfProfile(bytes32 _profileId, address _account) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _account) || _isMemberOfProfile(_profileId, _account);\n    }\n\n    /// @notice Checks if the given address is an owner of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function isOwnerOfProfile(bytes32 _profileId, address _owner) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _owner);\n    }\n\n    /// @notice Checks if the given address is a member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function isMemberOfProfile(bytes32 _profileId, address _member) external view returns (bool) {\n        return _isMemberOfProfile(_profileId, _member);\n    }\n\n    /// @notice Updates the pending owner of the profile. Emits a 'ProfilePendingOwnership()' event.\n    /// @dev 'msg.sender' must be the owner of the profile. [1]*This is step one of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    /// @param _pendingOwner The new pending owner\n    function updateProfilePendingOwner(bytes32 _profileId, address _pendingOwner)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Set the pending owner to the profile\n        profileIdToPendingOwner[_profileId] = _pendingOwner;\n\n        // Emit the event that the pending owner was updated\n        emit ProfilePendingOwnerUpdated(_profileId, _pendingOwner);\n    }\n\n    /// @notice Transfers the ownership of the profile to the pending owner and Emits a 'ProfileOwnerUdpated()' event.\n    /// @dev 'msg.sender' must be the pending owner of the profile. [2]*This is step two of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    function acceptProfileOwnership(bytes32 _profileId) external {\n        // Get the profile from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Get the pending owner from the mapping that was set when the owner was updated\n        address newOwner = profileIdToPendingOwner[_profileId];\n\n        // Revert if the 'msg.sender' is not the pending owner\n        if (msg.sender != newOwner) revert NOT_PENDING_OWNER();\n\n        // Set the new owner and delete the pending owner from the mapping\n        profile.owner = newOwner;\n        delete profileIdToPendingOwner[_profileId];\n\n        // Emit the event that the owner was accepted and updated\n        emit ProfileOwnerUpdated(_profileId, profile.owner);\n    }\n\n    /// @notice Adds members to the profile\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to add\n    function addMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and add them to the profile by granting the role\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(_profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes members from the profile\n    /// @dev 'msg.sender' must be the pending owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to remove\n    function removeMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and remove them from the profile by revoking the role\n        for (uint256 i; i < memberLength;) {\n            // Revoke the role from the member and emit the event for each member\n            _revokeRole(_profileId, _members[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// ====================================\n    /// ======== Internal Functions ========\n    /// ====================================\n\n    /// @notice Checks if the caller is the owner of the profile\n    /// @dev Internal function used by modifier 'onlyProfileOwner'\n    /// @param _profileId The ID of the profile\n    function _checkOnlyProfileOwner(bytes32 _profileId) internal view {\n        if (!_isOwnerOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Generates and deploys the anchor for the given 'profileId' and name\n    /// @dev Internal function used by 'createProfile()' and 'updateProfileName()' to create and anchor.\n    /// @param _profileId The ID of the profile\n    /// @param _name The name of the profile\n    /// @return anchor The address of the deployed anchor contract\n    function _generateAnchor(bytes32 _profileId, string memory _name) internal returns (address anchor) {\n        bytes memory encodedData = abi.encode(_profileId, _name);\n        bytes memory encodedConstructorArgs = abi.encode(_profileId, address(this));\n\n        bytes memory bytecode = abi.encodePacked(type(Anchor).creationCode, encodedConstructorArgs);\n\n        bytes32 salt = keccak256(encodedData);\n\n        address preComputedAddress = address(\n            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(bytecode)))))\n        );\n\n        // Try to deploy the anchor contract, if it fails then the anchor already exists\n        try new Anchor{salt: salt}(_profileId, address(this)) returns (Anchor _anchor) {\n            anchor = address(_anchor);\n        } catch {\n            if (Anchor(payable(preComputedAddress)).profileId() != _profileId) revert ANCHOR_ERROR();\n            anchor = preComputedAddress;\n        }\n    }\n\n    /// @notice Generates the 'profileId' based on msg.sender and nonce\n    /// @dev Internal function used by 'createProfile()' to generate profileId.\n    /// @param _nonce Nonce provided by the caller to generate 'profileId'\n    /// @param _owner The owner of the profile\n    /// @return 'profileId' The ID of the profile\n    function _generateProfileId(uint256 _nonce, address _owner) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _owner));\n    }\n\n    /// @notice Checks if an address is the owner of the profile\n    /// @dev Internal function used to determine if an address is the profile owner\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function _isOwnerOfProfile(bytes32 _profileId, address _owner) internal view returns (bool) {\n        return profilesById[_profileId].owner == _owner;\n    }\n\n    /// @notice Checks if an address is a member of the profile\n    /// @dev Internal function used to determine if an address is a member of the profile\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function _isMemberOfProfile(bytes32 _profileId, address _member) internal view returns (bool) {\n        return hasRole(_profileId, _member);\n    }\n\n    /// @notice Transfers any fund balance in Allo to the recipient\n    /// @dev 'msg.sender' must be the Allo owner\n    /// @param _token The address of the token to transfer\n    /// @param _recipient The address of the recipient\n    function recoverFunds(address _token, address _recipient) external onlyRole(ALLO_OWNER) {\n        if (_recipient == address(0)) revert ZERO_ADDRESS();\n\n        uint256 amount = _token == NATIVE ? address(this).balance : ERC20(_token).balanceOf(address(this));\n        _transferAmount(_token, _recipient, amount);\n    }\n}\n"
    },
    "contracts/factory/ContractFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External\nimport {CREATE3} from \"../core/libraries/utils/CREATE3.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title ContractFactory\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @dev ContractFactory is used internally to deploy our contracts using CREATE3\ncontract ContractFactory {\n    /// ======================\n    /// ======= Errors =======\n    /// ======================\n\n    /// @notice Thrown when the requested salt has already been used.\n    error SALT_USED();\n\n    /// @notice Thrown when the caller is not authorized to deploy.\n    error UNAUTHORIZED();\n\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a contract is deployed.\n    event Deployed(address indexed deployed, bytes32 indexed salt);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice Collection of used salts.\n    mapping(bytes32 => bool) public usedSalts;\n\n    /// @notice Collection of authorized deployers.\n    mapping(address => bool) public isDeployer;\n\n    /// ======================\n    /// ======= Modifiers ====\n    /// ======================\n\n    /// @notice Modifier to ensure the caller is authorized to deploy and returns if not.\n    modifier onlyDeployer() {\n        _checkIsDeployer();\n        _;\n    }\n\n    /// ======================\n    /// ===== Constructor ====\n    /// ======================\n\n    /// @notice On deployment sets the 'msg.sender' to allowed deployer.\n    constructor() {\n        isDeployer[msg.sender] = true;\n    }\n\n    /// ===============================\n    /// ====== Internal Functions =====\n    /// ===============================\n\n    /// @notice Checks if the caller is authorized to deploy.\n    function _checkIsDeployer() internal view {\n        if (!isDeployer[msg.sender]) revert UNAUTHORIZED();\n    }\n\n    /// ===============================\n    /// ====== External Functions =====\n    /// ===============================\n\n    /// @notice Deploys a contract using CREATE3.\n    /// @dev Used for our deployments.\n    /// @param _contractName Name of the contract to deploy\n    /// @param _version Version of the contract to deploy\n    /// @param creationCode Creation code of the contract to deploy\n    /// @return deployedContract Address of the deployed contract\n    function deploy(string memory _contractName, string memory _version, bytes memory creationCode)\n        external\n        payable\n        onlyDeployer\n        returns (address deployedContract)\n    {\n        // hash salt with the contract name and version\n        bytes32 salt = keccak256(abi.encodePacked(_contractName, _version));\n\n        // ensure salt has not been used\n        if (usedSalts[salt]) revert SALT_USED();\n\n        usedSalts[salt] = true;\n\n        deployedContract = CREATE3.deploy(salt, creationCode, msg.value);\n\n        emit Deployed(deployedContract, salt);\n    }\n\n    /// @notice Set the allowed deployer.\n    /// @dev 'msg.sender' must be a deployer.\n    /// @param _deployer Address of the deployer to set\n    /// @param _allowedToDeploy Boolean to set the deployer to\n    function setDeployer(address _deployer, bool _allowedToDeploy) external onlyDeployer {\n        // Set the deployer to the allowedToDeploy mapping\n        isDeployer[_deployer] = _allowedToDeploy;\n    }\n}\n"
    },
    "contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\n// Interfaces\nimport \"../core/interfaces/IStrategy.sol\";\n\n// Libraries\nimport {Transfer} from \"../core/libraries/Transfer.sol\";\nimport {Errors} from \"../core/libraries/Errors.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title BaseStrategy Contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice This contract is the base contract for all strategies\n/// @dev This contract is implemented by all strategies.\nabstract contract BaseStrategy is IStrategy, Transfer, Errors {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    IAllo internal immutable allo;\n    bytes32 internal immutable strategyId;\n    bool internal poolActive;\n    uint256 internal poolId;\n    uint256 internal poolAmount;\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    /// @notice Constructor to set the Allo contract and \"strategyId'.\n    /// @param _allo Address of the Allo contract.\n    /// @param _name Name of the strategy\n    constructor(address _allo, string memory _name) {\n        allo = IAllo(_allo);\n        strategyId = keccak256(abi.encode(_name));\n    }\n\n    /// ====================================\n    /// =========== Modifiers ==============\n    /// ====================================\n\n    /// @notice Modifier to check if the 'msg.sender' is the Allo contract.\n    /// @dev Reverts if the 'msg.sender' is not the Allo contract.\n    modifier onlyAllo() {\n        _checkOnlyAllo();\n        _;\n    }\n\n    /// @notice Modifier to check if the '_sender' is a pool manager.\n    /// @dev Reverts if the '_sender' is not a pool manager.\n    /// @param _sender The address to check if they are a pool manager\n    modifier onlyPoolManager(address _sender) {\n        _checkOnlyPoolManager(_sender);\n        _;\n    }\n\n    /// @notice Modifier to check if the pool is active.\n    /// @dev Reverts if the pool is not active.\n    modifier onlyActivePool() {\n        _checkOnlyActivePool();\n        _;\n    }\n\n    /// @notice Modifier to check if the pool is inactive.\n    /// @dev Reverts if the pool is active.\n    modifier onlyInactivePool() {\n        _checkInactivePool();\n        _;\n    }\n\n    /// @notice Modifier to check if the pool is initialized.\n    /// @dev Reverts if the pool is not initialized.\n    modifier onlyInitialized() {\n        _checkOnlyInitialized();\n        _;\n    }\n\n    /// ================================\n    /// =========== Views ==============\n    /// ================================\n\n    /// @notice Getter for the 'Allo' contract.\n    /// @return The Allo contract\n    function getAllo() external view override returns (IAllo) {\n        return allo;\n    }\n\n    /// @notice Getter for the 'poolId'.\n    /// @return The ID of the pool\n    function getPoolId() external view override returns (uint256) {\n        return poolId;\n    }\n\n    /// @notice Getter for the 'strategyId'.\n    /// @return The ID of the strategy\n    function getStrategyId() external view override returns (bytes32) {\n        return strategyId;\n    }\n\n    /// @notice Getter for the 'poolAmount'.\n    /// @return The balance of the pool\n    function getPoolAmount() external view virtual override returns (uint256) {\n        return poolAmount;\n    }\n\n    /// @notice Getter for whether or not the pool is active.\n    /// @return 'true' if the pool is active, otherwise 'false'\n    function isPoolActive() external view override returns (bool) {\n        return _isPoolActive();\n    }\n\n    /// @notice Getter for the status of a recipient.\n    /// @param _recipientId The ID of the recipient\n    /// @return The status of the recipient\n    function getRecipientStatus(address _recipientId) external view virtual returns (Status) {\n        return _getRecipientStatus(_recipientId);\n    }\n\n    /// ====================================\n    /// =========== Functions ==============\n    /// ====================================\n\n    /// @notice Initializes the 'Basetrategy'.\n    /// @dev Will revert if the poolId is invalid or already initialized\n    /// @param _poolId ID of the pool\n    function __BaseStrategy_init(uint256 _poolId) internal virtual onlyAllo {\n        // check if pool ID is not initialized already, if it is, revert\n        if (poolId != 0) revert ALREADY_INITIALIZED();\n\n        // check if pool ID is valid and not zero (0), if it is, revert\n        if (_poolId == 0) revert INVALID();\n        poolId = _poolId;\n    }\n\n    /// @notice Increases the pool amount.\n    /// @dev Increases the 'poolAmount' by '_amount'. Only 'Allo' contract can call this.\n    /// @param _amount The amount to increase the pool by\n    function increasePoolAmount(uint256 _amount) external override onlyAllo {\n        _beforeIncreasePoolAmount(_amount);\n        poolAmount += _amount;\n        _afterIncreasePoolAmount(_amount);\n    }\n\n    /// @notice Registers a recipient.\n    /// @dev Registers a recipient and returns the ID of the recipient. The encoded '_data' will be determined by the\n    ///      strategy implementation. Only 'Allo' contract can call this when it is initialized.\n    /// @param _data The data to use to register the recipient\n    /// @param _sender The address of the sender\n    /// @return recipientId The recipientId\n    function registerRecipient(bytes memory _data, address _sender)\n        external\n        payable\n        onlyAllo\n        onlyInitialized\n        returns (address recipientId)\n    {\n        _beforeRegisterRecipient(_data, _sender);\n        recipientId = _registerRecipient(_data, _sender);\n        _afterRegisterRecipient(_data, _sender);\n    }\n\n    /// @notice Allocates to a recipient.\n    /// @dev The encoded '_data' will be determined by the strategy implementation. Only 'Allo' contract can\n    ///      call this when it is initialized.\n    /// @param _data The data to use to allocate to the recipient\n    /// @param _sender The address of the sender\n    function allocate(bytes memory _data, address _sender) external payable onlyAllo onlyInitialized {\n        _beforeAllocate(_data, _sender);\n        _allocate(_data, _sender);\n        _afterAllocate(_data, _sender);\n    }\n\n    /// @notice Distributes funds (tokens) to recipients.\n    /// @dev The encoded '_data' will be determined by the strategy implementation. Only 'Allo' contract can\n    ///      call this when it is initialized.\n    /// @param _recipientIds The IDs of the recipients\n    /// @param _data The data to use to distribute to the recipients\n    /// @param _sender The address of the sender\n    function distribute(address[] memory _recipientIds, bytes memory _data, address _sender)\n        external\n        onlyAllo\n        onlyInitialized\n    {\n        _beforeDistribute(_recipientIds, _data, _sender);\n        _distribute(_recipientIds, _data, _sender);\n        _afterDistribute(_recipientIds, _data, _sender);\n    }\n\n    /// @notice Gets the payout summary for recipients.\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\n    /// @param _recipientIds The IDs of the recipients\n    /// @param _data The data to use to get the payout summary for the recipients\n    /// @return The payout summary for the recipients\n    function getPayouts(address[] memory _recipientIds, bytes[] memory _data)\n        external\n        view\n        virtual\n        override\n        returns (PayoutSummary[] memory)\n    {\n        uint256 recipientLength = _recipientIds.length;\n        // check if the length of the recipient IDs and data arrays are equal, if they are not, revert\n        if (recipientLength != _data.length) revert ARRAY_MISMATCH();\n\n        PayoutSummary[] memory payouts = new PayoutSummary[](recipientLength);\n        for (uint256 i; i < recipientLength;) {\n            payouts[i] = _getPayout(_recipientIds[i], _data[i]);\n            unchecked {\n                i++;\n            }\n        }\n        return payouts;\n    }\n\n    /// @notice Checks if the '_allocator' is a valid allocator.\n    /// @dev How the allocator is determined is up to the strategy implementation.\n    /// @param _allocator The address to check if it is a valid allocator for the strategy.\n    /// @return 'true' if the address is a valid allocator, 'false' otherwise\n    function isValidAllocator(address _allocator) external view virtual override returns (bool) {\n        return _isValidAllocator(_allocator);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Checks if the 'msg.sender' is the Allo contract.\n    /// @dev Reverts if the 'msg.sender' is not the Allo contract.\n    function _checkOnlyAllo() internal view {\n        if (msg.sender != address(allo)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Checks if the '_sender' is a pool manager.\n    /// @dev Reverts if the '_sender' is not a pool manager.\n    /// @param _sender The address to check if they are a pool manager\n    function _checkOnlyPoolManager(address _sender) internal view {\n        if (!allo.isPoolManager(poolId, _sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Checks if the pool is active.\n    /// @dev Reverts if the pool is not active.\n    function _checkOnlyActivePool() internal view {\n        if (!poolActive) revert POOL_INACTIVE();\n    }\n\n    /// @notice Checks if the pool is inactive.\n    /// @dev Reverts if the pool is active.\n    function _checkInactivePool() internal view {\n        if (poolActive) revert POOL_ACTIVE();\n    }\n\n    /// @notice Checks if the pool is initialized.\n    /// @dev Reverts if the pool is not initialized.\n    function _checkOnlyInitialized() internal view {\n        if (poolId == 0) revert NOT_INITIALIZED();\n    }\n\n    /// @notice Set the pool to active or inactive status.\n    /// @dev This will emit a 'PoolActive()' event. Used by the strategy implementation.\n    /// @param _active The status to set, 'true' means active, 'false' means inactive\n    function _setPoolActive(bool _active) internal {\n        poolActive = _active;\n        emit PoolActive(_active);\n    }\n\n    /// @notice Checks if the pool is active.\n    /// @dev Used by the strategy implementation.\n    /// @return 'true' if the pool is active, otherwise 'false'\n    function _isPoolActive() internal view virtual returns (bool) {\n        return poolActive;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return 'true' if the allocator is valid, otherwise 'false'\n    function _isValidAllocator(address _allocator) internal view virtual returns (bool);\n\n    /// @notice This will register a recipient, set their status (and any other strategy specific values), and\n    ///         return the ID of the recipient.\n    /// @dev Able to change status all the way up to Accepted, or to Pending and if there are more steps, additional\n    ///      functions should be added to allow the owner to check this. The owner could also check attestations directly\n    ///      and then Accept for instance.\n    /// @param _data The data to use to register the recipient\n    /// @param _sender The address of the sender\n    /// @return The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender) internal virtual returns (address);\n\n    /// @notice This will allocate to a recipient.\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\n    /// @param _data The data to use to allocate to the recipient\n    /// @param _sender The address of the sender\n    function _allocate(bytes memory _data, address _sender) internal virtual;\n\n    /// @notice This will distribute funds (tokens) to recipients.\n    /// @dev most strategies will track a TOTAL amount per recipient, and a PAID amount, and pay the difference\n    /// this contract will need to track the amount paid already, so that it doesn't double pay.\n    /// @param _recipientIds The ids of the recipients to distribute to\n    /// @param _data Data required will depend on the strategy implementation\n    /// @param _sender The address of the sender\n    function _distribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual;\n\n    /// @notice This will get the payout summary for a recipient.\n    /// @dev The encoded '_data' will be determined by the strategy implementation.\n    /// @param _recipientId The ID of the recipient\n    /// @param _data The data to use to get the payout summary for the recipient\n    /// @return The payout summary for the recipient\n    function _getPayout(address _recipientId, bytes memory _data)\n        internal\n        view\n        virtual\n        returns (PayoutSummary memory);\n\n    /// @notice This will get the status of a recipient.\n    /// @param _recipientId The ID of the recipient\n    /// @return The status of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual returns (Status);\n\n    /// ===================================\n    /// ============== Hooks ==============\n    /// ===================================\n\n    /// @notice Hook called before increasing the pool amount.\n    /// @param _amount The amount to increase the pool by\n    function _beforeIncreasePoolAmount(uint256 _amount) internal virtual {}\n\n    /// @notice Hook called after increasing the pool amount.\n    /// @param _amount The amount to increase the pool by\n    function _afterIncreasePoolAmount(uint256 _amount) internal virtual {}\n\n    /// @notice Hook called before registering a recipient.\n    /// @param _data The data to use to register the recipient\n    /// @param _sender The address of the sender\n    function _beforeRegisterRecipient(bytes memory _data, address _sender) internal virtual {}\n\n    /// @notice Hook called after registering a recipient.\n    /// @param _data The data to use to register the recipient\n    /// @param _sender The address of the sender\n    function _afterRegisterRecipient(bytes memory _data, address _sender) internal virtual {}\n\n    /// @notice Hook called before allocating to a recipient.\n    /// @param _data The data to use to allocate to the recipient\n    /// @param _sender The address of the sender\n    function _beforeAllocate(bytes memory _data, address _sender) internal virtual {}\n\n    /// @notice Hook called after allocating to a recipient.\n    /// @param _data The data to use to allocate to the recipient\n    /// @param _sender The address of the sender\n    function _afterAllocate(bytes memory _data, address _sender) internal virtual {}\n\n    /// @notice Hook called before distributing funds (tokens) to recipients.\n    /// @param _recipientIds The IDs of the recipients\n    /// @param _data The data to use to distribute to the recipients\n    /// @param _sender The address of the sender\n    function _beforeDistribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual {}\n\n    /// @notice Hook called after distributing funds (tokens) to recipients.\n    /// @param _recipientIds The IDs of the recipients\n    /// @param _data The data to use to distribute to the recipients\n    /// @param _sender The address of the sender\n    function _afterDistribute(address[] memory _recipientIds, bytes memory _data, address _sender) internal virtual {}\n}\n"
    },
    "contracts/strategies/qv-base/QVBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(\n        address indexed recipientId, uint256 applicationId, bytes data, address sender, Status status\n    );\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice Whether the distribution started or not\n    bool public distributionStarted;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n        // slot 2\n        uint256 applicationId;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> applicationId -> status -> count\n    mapping(address => mapping(uint256 => mapping(Status => uint256))) public reviewsByStatus;\n\n    // recipientId -> applicationId -> reviewer -> status\n    mapping(address => mapping(uint256 => mapping(address => Status))) public reviewedByManager;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev This will revert if the allocation has ended.\n    modifier onlyBeforeAllocationEnds() {\n        _checkOnlyBeforeAllocationEnds();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view virtual override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyBeforeAllocationEnds\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n            uint256 applicationId = recipient.applicationId;\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            if (reviewedByManager[recipientId][applicationId][msg.sender] > Status.None) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            // track the review cast for the recipient and update status counter\n            reviewedByManager[recipientId][applicationId][msg.sender] = recipientStatus;\n            reviewsByStatus[recipientId][applicationId][recipientStatus]++;\n\n            // update the recipient status if the review threshold has been reached\n            if (reviewsByStatus[recipientId][applicationId][recipientStatus] >= reviewThreshold) {\n                recipient.recipientStatus = recipientStatus;\n\n                // Changes for QVMACIStrategy \n                if (recipientStatus == Status.Accepted) {\n                    \n                }\n\n                emit RecipientStatusUpdated(recipientId, applicationId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, applicationId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// @notice Withdraw the tokens from the pool\n    /// @dev Callable by the pool manager only 30 days after the allocation has ended\n    /// @param _token The token to withdraw\n    function withdraw(address _token) external onlyPoolManager(msg.sender) {\n        if (block.timestamp <= allocationEndTime + 30 days) {\n            revert INVALID();\n        }\n\n        uint256 amount = _getBalance(_token, address(this));\n\n        // Transfer the tokens to the 'msg.sender' (pool manager calling function)\n        _transferAmount(_token, msg.sender, amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view virtual {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp <= allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Checks if the allocation has not ended and reverts if it has.\n    /// @dev This will revert if the allocation has ended.\n    function _checkOnlyBeforeAllocationEnds() internal view {\n        if (block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The '_data' parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n        ++recipient.applicationId;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            // recipient updating rejected/pending/appealed/accepted application\n            if (currentStatus == Status.Rejected) {\n                recipient.recipientStatus = Status.Appealed;\n            } else if (currentStatus == Status.Accepted) {\n                // recipient updating already accepted application\n                recipient.recipientStatus = Status.Pending;\n            }\n\n            // emit the new status with the '_data' that was passed in\n            emit UpdatedRegistration(recipientId, recipient.applicationId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The '_sender' must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n        if (!distributionStarted) {\n            distributionStarted = true;\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the '_sender' is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// @param _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// @param _sender The sender of the transaction\n    function _qv_allocate(\n        Allocator storage _allocator,\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate,\n        address _sender\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // check if the recipient is accepted\n        if (!_isAcceptedRecipient(_recipientId)) revert RECIPIENT_ERROR(_recipientId);\n\n        // update the allocator voice credits\n        _allocator.voiceCredits += _voiceCreditsToAllocate;\n\n        // creditsCastToRecipient is the voice credits used to cast a vote to the recipient\n        // votesCastToRecipient is the actual votes cast to the recipient\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        uint256 votesCastToRecipient = _allocator.votesCastToRecipient[_recipientId];\n\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        // determine actual votes cast\n        uint256 voteResult = _sqrt(totalCredits * 1e18);\n\n        // update the values\n        voteResult -= votesCastToRecipient;\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived += voteResult;\n\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += _voiceCreditsToAllocate;\n        _allocator.votesCastToRecipient[_recipientId] += voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return If the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view virtual returns (bool);\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return If the allocator is valid\n    function _isValidAllocator(address _allocator) internal view virtual override returns (bool);\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return If the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a 'PayoutSummary' struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        virtual\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n\n    function _beforeIncreasePoolAmount(uint256) internal virtual override {\n        if (distributionStarted) {\n            revert INVALID();\n        }\n    }\n\n    /// @notice Contract should be able to receive NATIVE\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/qv-maci/Errors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\n\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\ncontract Errors{\n\n    // Errors\n    error OnlyMaciCanRegisterVoters();\n    error NotCoordinator();\n    error InvalidPoll();\n    error InvalidTally();\n    error InvalidMessageProcessor();\n    error MaciAlreadySet();\n    error ContributionAmountIsZero();\n    error ContributionAmountTooLarge();\n    error AlreadyContributed();\n    error UserNotVerified();\n    error UserHasNotContributed();\n    error UserAlreadyRegistered();\n    error NoVoiceCredits();\n    error NothingToWithdraw();\n    error RoundNotCancelled();\n    error RoundCancelled();\n    error RoundAlreadyFinalized();\n    error RoundNotFinalized();\n    error VotesNotTallied();\n    error EmptyTallyHash();\n    error InvalidBudget();\n    error NoProjectHasMoreThanOneVote();\n    error VoteResultsAlreadyVerified();\n    error IncorrectTallyResult();\n    error IncorrectSpentVoiceCredits();\n    error IncorrectPerVOSpentVoiceCredits();\n    error FundsAlreadyClaimed();\n    error TallyHashNotPublished();\n    error IncompleteTallyResults(uint256 total, uint256 actual);\n    error NoVotes();\n    error MaciNotSet();\n    error PollNotSet();\n    error InvalidMaci();\n    error InvalidNativeToken();\n    error InvalidUserRegistry();\n    error InvalidRecipientRegistry();\n    error InvalidCoordinator();\n    error UnexpectedPollAddress(address expected, address actual);\n\n    // MACI Events\n    event Contribution(address indexed _sender, uint256 _amount);\n    event ContributionWithdrawn(address indexed _contributor);\n    event FundsClaimed(uint256 indexed _voteOptionIndex, address indexed _recipient, uint256 _amount);\n    event TallyPublished(string _tallyHash);\n    event Voted(address indexed _contributor);\n    event TallyResultsAdded(uint256 indexed _voteOptionIndex, uint256 _tally);\n    event PollSet(address indexed _poll);\n    event TallySet(address indexed _tally);\n\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n}"
    },
    "contracts/strategies/qv-maci/FoundingRound2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {DomainObjs} from 'maci-contracts/contracts/utilities/DomainObjs.sol';\nimport {MACI} from 'maci-contracts/contracts/MACI.sol';\nimport {Poll} from 'maci-contracts/contracts/Poll.sol';\nimport {Tally} from 'maci-contracts/contracts/Tally.sol';\nimport {SignUpGatekeeper} from 'maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol';\nimport {InitialVoiceCreditProxy} from 'maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol';\nimport {CommonUtilities} from 'maci-contracts/contracts/utilities/CommonUtilities.sol';\nimport {SnarkCommon} from 'maci-contracts/contracts/crypto/SnarkCommon.sol';\nimport {ITallySubsidyFactory} from 'maci-contracts/contracts/interfaces/ITallySubsidyFactory.sol';\nimport {IMessageProcessorFactory} from 'maci-contracts/contracts/interfaces/IMPFactory.sol';\nimport {IClrFund} from './interfaces/IClrFund.sol';\nimport {IMACIFactory} from './interfaces/IMACIFactory.sol';\nimport {MACICommon} from './MACICommon.sol';\nimport {TopupToken} from './TopupToken.sol';\n\nimport './userRegistry/IUserRegistry.sol';\nimport './recipientRegistry/IRecipientRegistry.sol';\n\ncontract FundingRound is\n  Ownable,\n  SignUpGatekeeper,\n  InitialVoiceCreditProxy,\n  DomainObjs,\n  SnarkCommon,\n  CommonUtilities,\n  MACICommon\n{\n  using SafeERC20 for ERC20;\n\n  // Errors\n  error OnlyMaciCanRegisterVoters();\n  error NotCoordinator();\n  error InvalidPoll();\n  error InvalidTally();\n  error InvalidMessageProcessor();\n  error MaciAlreadySet();\n  error ContributionAmountIsZero();\n  error ContributionAmountTooLarge();\n  error AlreadyContributed();\n  error UserNotVerified();\n  error UserHasNotContributed();\n  error UserAlreadyRegistered();\n  error NoVoiceCredits();\n  error NothingToWithdraw();\n  error RoundNotCancelled();\n  error RoundCancelled();\n  error RoundAlreadyFinalized();\n  error RoundNotFinalized();\n  error VotesNotTallied();\n  error EmptyTallyHash();\n  error InvalidBudget();\n  error NoProjectHasMoreThanOneVote();\n  error VoteResultsAlreadyVerified();\n  error IncorrectTallyResult();\n  error IncorrectSpentVoiceCredits();\n  error IncorrectPerVOSpentVoiceCredits();\n  error FundsAlreadyClaimed();\n  error TallyHashNotPublished();\n  error IncompleteTallyResults(uint256 total, uint256 actual);\n  error NoVotes();\n  error MaciNotSet();\n  error PollNotSet();\n  error InvalidMaci();\n  error InvalidNativeToken();\n  error InvalidUserRegistry();\n  error InvalidRecipientRegistry();\n  error InvalidCoordinator();\n  error UnexpectedPollAddress(address expected, address actual);\n\n\n  // Constants\n  uint256 private constant MAX_VOICE_CREDITS = 10 ** 9;  // MACI allows 2 ** 32 voice credits max\n  uint256 private constant MAX_CONTRIBUTION_AMOUNT = 10 ** 4;  // In tokens\n  uint256 private constant ALPHA_PRECISION = 10 ** 18; // to account for loss of precision in division\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n  // Structs\n  struct ContributorStatus {\n    uint256 voiceCredits;\n    bool isRegistered;\n  }\n\n  struct RecipientStatus {\n    // Has the recipient claimed funds?\n    bool fundsClaimed;\n    // Is the tally result verified\n    bool tallyVerified;\n    // Tally result\n    uint256 tallyResult;\n  }\n\n  // State\n  uint256 public voiceCreditFactor;\n  uint256 public contributorCount;\n  uint256 public matchingPoolSize;\n  uint256 public totalSpent;\n  uint256 public totalVotes;\n  bool public isFinalized = false;\n  bool public isCancelled = false;\n\n  uint256 public pollId;\n  Poll public poll;\n  Tally public tally;\n\n  address public coordinator;\n  MACI public maci;\n  ERC20 public nativeToken;\n  IUserRegistry public userRegistry;\n  IRecipientRegistry public recipientRegistry;\n  TopupToken public topupToken;\n\n  string public tallyHash;\n\n  // The alpha used in quadratic funding formula\n  uint256 public alpha = 0;\n\n  // Total number of tally results verified, should match total recipients before finalize\n  uint256 public totalTallyResults = 0;\n  uint256 public totalVotesSquares = 0;\n  mapping(uint256 => RecipientStatus) public _recipients;\n  mapping(address => ContributorStatus) public _contributors;\n\n  // Events\n  event Contribution(address indexed _sender, uint256 _amount);\n  event ContributionWithdrawn(address indexed _contributor);\n  event FundsClaimed(uint256 indexed _voteOptionIndex, address indexed _recipient, uint256 _amount);\n  event TallyPublished(string _tallyHash);\n  event Voted(address indexed _contributor);\n  event TallyResultsAdded(uint256 indexed _voteOptionIndex, uint256 _tally);\n  event PollSet(address indexed _poll);\n  event TallySet(address indexed _tally);\n\n  modifier onlyCoordinator() {\n    if(msg.sender != coordinator) {\n      revert NotCoordinator();\n    }\n    _;\n  }\n\n\n  /**\n   * @dev Is the given address a zero address\n   */\n  function isAddressZero(address addressValue) public pure returns (bool) {\n    return (addressValue == address(0));\n  }\n\n  /**\n   * @dev Have the votes been tallied\n   */\n  function isTallied() private view returns (bool) {\n    (uint256 numSignUps, ) = poll.numSignUpsAndMessages();\n    (uint8 intStateTreeDepth, , , ) = poll.treeDepths();\n    uint256 tallyBatchSize = TREE_ARITY ** uint256(intStateTreeDepth);\n    uint256 tallyBatchNum = tally.tallyBatchNum();\n    uint256 totalTallied = tallyBatchNum * tallyBatchSize;\n\n    return numSignUps > 0 && totalTallied >= numSignUps;\n  }\n\n  /**\n  * @dev Set the tally contract\n  * @param _tally The tally contract address\n  */\n  function _setTally(address _tally) private\n  {\n    if (isAddressZero(_tally)) {\n      revert InvalidTally();\n    }\n\n    tally = Tally(_tally);\n    emit TallySet(address(tally));\n  }\n\n  /**\n    * @dev Reset tally results. This should only be used if the tally script\n    * failed to proveOnChain due to unexpected error processing MACI logs\n    */\n  function resetTally()\n    external\n    onlyCoordinator\n  {\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    _votingPeriodOver(poll);\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    address verifier = address(tally.verifier());\n    address vkRegistry = address(tally.vkRegistry());\n\n    IMessageProcessorFactory messageProcessorFactory = maci.messageProcessorFactory();\n    ITallySubsidyFactory tallyFactory = maci.tallyFactory();\n\n    address mp = messageProcessorFactory.deploy(verifier, vkRegistry, address(poll), coordinator);\n    address newTally = tallyFactory.deploy(verifier, vkRegistry, address(poll), mp, coordinator);\n    _setTally(newTally);\n  }\n\n  /**\n    * @dev Link MACI related contracts to this funding round.\n    */\n  function setMaci(\n    MACI _maci,\n    MACI.PollContracts memory _pollContracts\n  )\n    external\n    onlyOwner\n  {\n    if (!isAddressZero(address(maci))) revert MaciAlreadySet();\n\n    if (isAddressZero(address(_maci))) revert InvalidMaci();\n    if (isAddressZero(_pollContracts.poll)) revert InvalidPoll();\n    if (isAddressZero(_pollContracts.messageProcessor)) revert InvalidMessageProcessor();\n\n    // we only create 1 poll per maci, make sure MACI use pollId = 0\n    // as the first poll index\n    pollId = 0;\n\n    address expectedPoll = _maci.getPoll(pollId);\n    if( _pollContracts.poll != expectedPoll ) {\n      revert UnexpectedPollAddress(expectedPoll, _pollContracts.poll);\n    }\n\n    maci = _maci;\n    poll = Poll(_pollContracts.poll);\n    _setTally(_pollContracts.tally);\n  }\n\n\n \n\n\n  /**\n    * @dev Publish the IPFS hash of the vote tally. Only coordinator can publish.\n    * @param _tallyHash IPFS hash of the vote tally.\n    */\n  function publishTallyHash(string calldata _tallyHash)\n    external\n    onlyCoordinator\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n    if (bytes(_tallyHash).length == 0) {\n      revert EmptyTallyHash();\n    }\n\n    tallyHash = _tallyHash;\n    emit TallyPublished(_tallyHash);\n  }\n\n  /**\n    * @dev Calculate the alpha for the capital constrained quadratic formula\n    *  in page 17 of https://arxiv.org/pdf/1809.06421.pdf\n    * @param _budget Total budget of the round to be distributed\n    * @param _totalVotesSquares Total of the squares of votes\n    * @param _totalSpent Total amount of spent voice credits\n   */\n  function calcAlpha(\n    uint256 _budget,\n    uint256 _totalVotesSquares,\n    uint256 _totalSpent\n  )\n    public\n    view\n    returns (uint256 _alpha)\n  {\n    // make sure budget = contributions + matching pool\n    uint256 contributions = _totalSpent * voiceCreditFactor;\n\n    if (_budget < contributions) {\n      revert InvalidBudget();\n    }\n\n    // guard against division by zero.\n    // This happens when no project receives more than one vote\n    if (_totalVotesSquares <= _totalSpent) {\n      revert NoProjectHasMoreThanOneVote();\n    }\n\n    return  (_budget - contributions) * ALPHA_PRECISION /\n            (voiceCreditFactor * (_totalVotesSquares - _totalSpent));\n\n  }\n\n  /**\n    * @dev Get the total amount of votes from MACI,\n    * verify the total amount of spent voice credits across all recipients,\n    * calculate the quadratic alpha value,\n    * and allow recipients to claim funds.\n    * @param _totalSpent Total amount of spent voice credits.\n    * @param _totalSpentSalt The salt.\n    */\n  function finalize(\n    uint256 _totalSpent,\n    uint256 _totalSpentSalt,\n    uint256 _newResultCommitment,\n    uint256 _perVOSpentVoiceCreditsHash\n  )\n    external\n    onlyOwner\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    _votingPeriodOver(poll);\n\n    if (!isTallied()) {\n      revert VotesNotTallied();\n    }\n    if (bytes(tallyHash).length == 0) {\n      revert TallyHashNotPublished();\n    }\n\n    // make sure we have received all the tally results\n    (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n    uint256 totalResults = uint256(TREE_ARITY) ** uint256(voteOptionTreeDepth);\n    if ( totalTallyResults != totalResults ) {\n      revert IncompleteTallyResults(totalResults, totalTallyResults);\n    }\n\n    // If nobody voted, the round should be cancelled to avoid locking of matching funds\n    if ( _totalSpent == 0) {\n      revert NoVotes();\n    }\n\n    bool verified = tally.verifySpentVoiceCredits(_totalSpent, _totalSpentSalt, _newResultCommitment, _perVOSpentVoiceCreditsHash);\n    if (!verified) {\n      revert IncorrectSpentVoiceCredits();\n    }\n\n\n    totalSpent = _totalSpent;\n    // Total amount of spent voice credits is the size of the pool of direct rewards.\n    // Everything else, including unspent voice credits and downscaling error,\n    // is considered a part of the matching pool\n    uint256 budget = nativeToken.balanceOf(address(this));\n    matchingPoolSize = budget - totalSpent * voiceCreditFactor;\n\n    alpha = calcAlpha(budget, totalVotesSquares, totalSpent);\n\n    isFinalized = true;\n  }\n\n  /**\n    * @dev Cancel funding round.\n    */\n  function cancel()\n    external\n    onlyOwner\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n    isFinalized = true;\n    isCancelled = true;\n  }\n\n  /**\n    * @dev Get allocated token amount (without verification).\n    * @param _tallyResult The result of vote tally for the recipient.\n    * @param _spent The amount of voice credits spent on the recipient.\n    */\n  function getAllocatedAmount(\n    uint256 _tallyResult,\n    uint256 _spent\n  )\n    public\n    view\n    returns (uint256)\n  {\n    // amount = ( alpha * (quadratic votes)^2 + (precision - alpha) * totalSpent ) / precision\n    uint256 quadratic = alpha * voiceCreditFactor * _tallyResult * _tallyResult;\n    uint256 totalSpentCredits = voiceCreditFactor * _spent;\n    uint256 linearPrecision = ALPHA_PRECISION * totalSpentCredits;\n    uint256 linearAlpha = alpha * totalSpentCredits;\n    return ((quadratic + linearPrecision) - linearAlpha) / ALPHA_PRECISION;\n  }\n\n  /**\n    * @dev Claim allocated tokens.\n    * @param _voteOptionIndex Vote option index.\n    * @param _spent The amount of voice credits spent on the recipients.\n    * @param _spentProof Proof of correctness for the amount of spent credits.\n    */\n  function claimFunds(\n    uint256 _voteOptionIndex,\n    uint256 _spent,\n    uint256[][] calldata _spentProof,\n    uint256 _spentSalt,\n    uint256 _resultsCommitment,\n    uint256 _spentVoiceCreditsCommitment\n  )\n    external\n  {\n    if (!isFinalized) {\n      revert RoundNotFinalized();\n    }\n\n    if (isCancelled) {\n      revert RoundCancelled();\n    }\n\n    if (_recipients[_voteOptionIndex].fundsClaimed) {\n      revert FundsAlreadyClaimed();\n    }\n    _recipients[_voteOptionIndex].fundsClaimed = true;\n\n    {\n      // create scope to avoid 'stack too deep' error\n\n      (, , , uint8 voteOptionTreeDepth) = poll.treeDepths();\n      bool verified = tally.verifyPerVOSpentVoiceCredits(\n        _voteOptionIndex,\n        _spent,\n        _spentProof,\n        _spentSalt,\n        voteOptionTreeDepth,\n        _spentVoiceCreditsCommitment,\n        _resultsCommitment\n      );\n\n      if (!verified) {\n        revert IncorrectPerVOSpentVoiceCredits();\n      }\n    }\n\n    (uint256 startTime, uint256 duration) = poll.getDeployTimeAndDuration();\n    address recipient = recipientRegistry.getRecipientAddress(\n      _voteOptionIndex,\n      startTime,\n      startTime + duration\n    );\n    if (recipient == address(0)) {\n      // Send funds back to the matching pool\n      recipient = owner();\n    }\n\n    uint256 tallyResult = _recipients[_voteOptionIndex].tallyResult;\n    uint256 allocatedAmount = getAllocatedAmount(tallyResult, _spent);\n    nativeToken.safeTransfer(recipient, allocatedAmount);\n    emit FundsClaimed(_voteOptionIndex, recipient, allocatedAmount);\n  }\n\n  /**\n    * @dev Add and verify tally votes and calculate sum of tally squares for alpha calculation.\n    * @param _voteOptionIndex Vote option index.\n    * @param _tallyResult The results of vote tally for the recipients.\n    * @param _tallyResultProof Proofs of correctness of the vote tally results.\n    * @param _tallyResultSalt the respective salt in the results object in the tally.json\n    * @param _spentVoiceCreditsHash hashLeftRight(number of spent voice credits, spent salt)\n    * @param _perVOSpentVoiceCreditsHash hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n    */\n  function _addTallyResult(\n    uint256 _voteOptionIndex,\n    uint256 _tallyResult,\n    uint256[][] memory _tallyResultProof,\n    uint256 _tallyResultSalt,\n    uint256 _spentVoiceCreditsHash,\n    uint256 _perVOSpentVoiceCreditsHash\n  )\n    private\n  {\n    RecipientStatus storage recipient = _recipients[_voteOptionIndex];\n    if (recipient.tallyVerified) {\n      revert VoteResultsAlreadyVerified();\n    }\n\n    (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n    bool resultVerified = tally.verifyTallyResult(\n      _voteOptionIndex,\n      _tallyResult,\n      _tallyResultProof,\n      _tallyResultSalt,\n      voteOptionTreeDepth,\n      _spentVoiceCreditsHash,\n      _perVOSpentVoiceCreditsHash\n    );\n\n    if (!resultVerified) {\n      revert IncorrectTallyResult();\n    }\n\n    recipient.tallyVerified = true;\n    recipient.tallyResult = _tallyResult;\n    totalVotesSquares = totalVotesSquares + (_tallyResult * _tallyResult);\n    totalTallyResults++;\n    emit TallyResultsAdded(_voteOptionIndex, _tallyResult);\n  }\n\n  /**\n    * @dev Add and verify tally results by batch.\n    * @param _voteOptionIndices Vote option index.\n    * @param _tallyResults The results of vote tally for the recipients.\n    * @param _tallyResultProofs Proofs of correctness of the vote tally results.\n    * @param _tallyResultSalt the respective salt in the results object in the tally.json\n    * @param _spentVoiceCreditsHashes hashLeftRight(number of spent voice credits, spent salt)\n    * @param _perVOSpentVoiceCreditsHashes hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n   */\n  function addTallyResultsBatch(\n    uint256[] calldata _voteOptionIndices,\n    uint256[] calldata _tallyResults,\n    uint256[][][] calldata _tallyResultProofs,\n    uint256 _tallyResultSalt,\n    uint256 _spentVoiceCreditsHashes,\n    uint256 _perVOSpentVoiceCreditsHashes\n  )\n    external\n    onlyCoordinator\n  {\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    if (!isTallied()) {\n      revert VotesNotTallied();\n    }\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    for (uint256 i = 0; i < _voteOptionIndices.length; i++) {\n      _addTallyResult(\n        _voteOptionIndices[i],\n        _tallyResults[i],\n        _tallyResultProofs[i],\n        _tallyResultSalt,\n        _spentVoiceCreditsHashes,\n        _perVOSpentVoiceCreditsHashes\n      );\n    }\n  }\n\n}"
    },
    "contracts/strategies/qv-maci/FundingRound.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport {DomainObjs} from 'maci-contracts/contracts/utilities/DomainObjs.sol';\nimport {MACI} from 'maci-contracts/contracts/MACI.sol';\nimport {Poll} from 'maci-contracts/contracts/Poll.sol';\nimport {Tally} from 'maci-contracts/contracts/Tally.sol';\nimport {SignUpGatekeeper} from 'maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol';\nimport {InitialVoiceCreditProxy} from 'maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol';\nimport {CommonUtilities} from 'maci-contracts/contracts/utilities/CommonUtilities.sol';\nimport {SnarkCommon} from 'maci-contracts/contracts/crypto/SnarkCommon.sol';\nimport {ITallySubsidyFactory} from 'maci-contracts/contracts/interfaces/ITallySubsidyFactory.sol';\nimport {IMessageProcessorFactory} from 'maci-contracts/contracts/interfaces/IMPFactory.sol';\nimport {IClrFund} from './interfaces/IClrFund.sol';\nimport {IMACIFactory} from './interfaces/IMACIFactory.sol';\nimport {MACICommon} from './MACICommon.sol';\nimport {TopupToken} from './TopupToken.sol';\n\nimport './userRegistry/IUserRegistry.sol';\nimport './recipientRegistry/IRecipientRegistry.sol';\n\ncontract FundingRound is\n  Ownable,\n  SignUpGatekeeper,\n  InitialVoiceCreditProxy,\n  DomainObjs,\n  SnarkCommon,\n  CommonUtilities,\n  MACICommon\n{\n  using SafeERC20 for ERC20;\n\n  // Errors\n  error OnlyMaciCanRegisterVoters();\n  error NotCoordinator();\n  error InvalidPoll();\n  error InvalidTally();\n  error InvalidMessageProcessor();\n  error MaciAlreadySet();\n  error ContributionAmountIsZero();\n  error ContributionAmountTooLarge();\n  error AlreadyContributed();\n  error UserNotVerified();\n  error UserHasNotContributed();\n  error UserAlreadyRegistered();\n  error NoVoiceCredits();\n  error NothingToWithdraw();\n  error RoundNotCancelled();\n  error RoundCancelled();\n  error RoundAlreadyFinalized();\n  error RoundNotFinalized();\n  error VotesNotTallied();\n  error EmptyTallyHash();\n  error InvalidBudget();\n  error NoProjectHasMoreThanOneVote();\n  error VoteResultsAlreadyVerified();\n  error IncorrectTallyResult();\n  error IncorrectSpentVoiceCredits();\n  error IncorrectPerVOSpentVoiceCredits();\n  error FundsAlreadyClaimed();\n  error TallyHashNotPublished();\n  error IncompleteTallyResults(uint256 total, uint256 actual);\n  error NoVotes();\n  error MaciNotSet();\n  error PollNotSet();\n  error InvalidMaci();\n  error InvalidNativeToken();\n  error InvalidUserRegistry();\n  error InvalidRecipientRegistry();\n  error InvalidCoordinator();\n  error UnexpectedPollAddress(address expected, address actual);\n\n\n  // Constants\n  uint256 private constant MAX_VOICE_CREDITS = 10 ** 9;  // MACI allows 2 ** 32 voice credits max\n  uint256 private constant MAX_CONTRIBUTION_AMOUNT = 10 ** 4;  // In tokens\n  uint256 private constant ALPHA_PRECISION = 10 ** 18; // to account for loss of precision in division\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n  // Structs\n  struct ContributorStatus {\n    uint256 voiceCredits;\n    bool isRegistered;\n  }\n\n  struct RecipientStatus {\n    // Has the recipient claimed funds?\n    bool fundsClaimed;\n    // Is the tally result verified\n    bool tallyVerified;\n    // Tally result\n    uint256 tallyResult;\n  }\n\n  // State\n  uint256 public voiceCreditFactor;\n  uint256 public contributorCount;\n  uint256 public matchingPoolSize;\n  uint256 public totalSpent;\n  uint256 public totalVotes;\n  bool public isFinalized = false;\n  bool public isCancelled = false;\n\n  uint256 public pollId;\n  Poll public poll;\n  Tally public tally;\n\n  address public coordinator;\n  MACI public maci;\n  ERC20 public nativeToken;\n  IUserRegistry public userRegistry;\n  IRecipientRegistry public recipientRegistry;\n  TopupToken public topupToken;\n\n  string public tallyHash;\n\n  // The alpha used in quadratic funding formula\n  uint256 public alpha = 0;\n\n  // Total number of tally results verified, should match total recipients before finalize\n  uint256 public totalTallyResults = 0;\n  uint256 public totalVotesSquares = 0;\n  mapping(uint256 => RecipientStatus) public _recipients;\n  mapping(address => ContributorStatus) public _contributors;\n\n  // Events\n  event Contribution(address indexed _sender, uint256 _amount);\n  event ContributionWithdrawn(address indexed _contributor);\n  event FundsClaimed(uint256 indexed _voteOptionIndex, address indexed _recipient, uint256 _amount);\n  event TallyPublished(string _tallyHash);\n  event Voted(address indexed _contributor);\n  event TallyResultsAdded(uint256 indexed _voteOptionIndex, uint256 _tally);\n  event PollSet(address indexed _poll);\n  event TallySet(address indexed _tally);\n\n  modifier onlyCoordinator() {\n    if(msg.sender != coordinator) {\n      revert NotCoordinator();\n    }\n    _;\n  }\n\n  /**\n    * @dev Set round parameters.\n    */\n  constructor(\n    ERC20 _nativeToken,\n    IUserRegistry _userRegistry,\n    IRecipientRegistry _recipientRegistry,\n    address _coordinator\n  )\n  {\n    if (isAddressZero(address(_nativeToken))) revert InvalidNativeToken();\n    if (isAddressZero(address(_userRegistry))) revert InvalidUserRegistry();\n    if (isAddressZero(address(_recipientRegistry))) revert InvalidRecipientRegistry();\n    if (isAddressZero(_coordinator)) revert InvalidCoordinator();\n\n    nativeToken = _nativeToken;\n    voiceCreditFactor = (MAX_CONTRIBUTION_AMOUNT * uint256(10) ** nativeToken.decimals()) / MAX_VOICE_CREDITS;\n    voiceCreditFactor = voiceCreditFactor > 0 ? voiceCreditFactor : 1;\n\n    userRegistry = _userRegistry;\n    recipientRegistry = _recipientRegistry;\n    coordinator = _coordinator;\n    topupToken = new TopupToken();\n\n  }\n\n  /**\n   * @dev Is the given address a zero address\n   */\n  function isAddressZero(address addressValue) public pure returns (bool) {\n    return (addressValue == address(0));\n  }\n\n  /**\n   * @dev Have the votes been tallied\n   */\n  function isTallied() private view returns (bool) {\n    (uint256 numSignUps, ) = poll.numSignUpsAndMessages();\n    (uint8 intStateTreeDepth, , , ) = poll.treeDepths();\n    uint256 tallyBatchSize = TREE_ARITY ** uint256(intStateTreeDepth);\n    uint256 tallyBatchNum = tally.tallyBatchNum();\n    uint256 totalTallied = tallyBatchNum * tallyBatchSize;\n\n    return numSignUps > 0 && totalTallied >= numSignUps;\n  }\n\n  /**\n  * @dev Set the tally contract\n  * @param _tally The tally contract address\n  */\n  function _setTally(address _tally) private\n  {\n    if (isAddressZero(_tally)) {\n      revert InvalidTally();\n    }\n\n    tally = Tally(_tally);\n    emit TallySet(address(tally));\n  }\n\n  /**\n    * @dev Reset tally results. This should only be used if the tally script\n    *     failed to proveOnChain due to unexpected error processing MACI logs\n    */\n  function resetTally()\n    external\n    onlyCoordinator\n  {\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    _votingPeriodOver(poll);\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    address verifier = address(tally.verifier());\n    address vkRegistry = address(tally.vkRegistry());\n\n    IMessageProcessorFactory messageProcessorFactory = maci.messageProcessorFactory();\n    ITallySubsidyFactory tallyFactory = maci.tallyFactory();\n\n    address mp = messageProcessorFactory.deploy(verifier, vkRegistry, address(poll), coordinator);\n    address newTally = tallyFactory.deploy(verifier, vkRegistry, address(poll), mp, coordinator);\n    _setTally(newTally);\n  }\n\n  /**\n    * @dev Link MACI related contracts to this funding round.\n    */\n  function setMaci(\n    MACI _maci,\n    MACI.PollContracts memory _pollContracts\n  )\n    external\n    onlyOwner\n  {\n    if (!isAddressZero(address(maci))) revert MaciAlreadySet();\n\n    if (isAddressZero(address(_maci))) revert InvalidMaci();\n    if (isAddressZero(_pollContracts.poll)) revert InvalidPoll();\n    if (isAddressZero(_pollContracts.messageProcessor)) revert InvalidMessageProcessor();\n\n    // we only create 1 poll per maci, make sure MACI use pollId = 0\n    // as the first poll index\n    pollId = 0;\n\n    address expectedPoll = _maci.getPoll(pollId);\n    if( _pollContracts.poll != expectedPoll ) {\n      revert UnexpectedPollAddress(expectedPoll, _pollContracts.poll);\n    }\n\n    maci = _maci;\n    poll = Poll(_pollContracts.poll);\n    _setTally(_pollContracts.tally);\n  }\n\n  /**\n    * @dev Signup to this funding round.\n    * @param pubKey Contributor's public key.\n    */\n  function signup(PubKey calldata pubKey ) external\n  {\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n    if (isFinalized) revert RoundAlreadyFinalized();\n\n    // Remove later the contribution amount \n    _contributors[msg.sender] = ContributorStatus(0, false);\n\n    bytes memory signUpGatekeeperData = abi.encode(msg.sender, maxVoiceCreditsPerAllocator);\n    bytes memory initialVoiceCreditProxyData = abi.encode(msg.sender);\n\n    maci.signUp(\n      pubKey,\n      signUpGatekeeperData,\n      initialVoiceCreditProxyData\n    );\n  }\n\n    /**\n    * @dev Register user for voting.\n    * This function is part of SignUpGatekeeper interface.\n    * @param _data Encoded address of a contributor.\n    */\n  function register(\n    address /* _caller */,\n    bytes memory _data\n  )\n    override\n    public\n  {\n    if (msg.sender != address(maci)) {\n      revert OnlyMaciCanRegisterVoters();\n    }\n\n    address user = abi.decode(_data, (address));\n    bool verified = userRegistry.isVerifiedUser(user);\n\n    if (!verified) {\n      revert UserNotVerified();\n    }\n\n    if (_contributors[user].voiceCredits <= 0) {\n      revert UserHasNotContributed();\n    }\n\n    if (_contributors[user].isRegistered) {\n      revert UserAlreadyRegistered();\n    }\n\n    _contributors[user].isRegistered = true;\n  }\n\n  /**\n    * @dev Get the amount of voice credits for a given address.\n    * This function is a part of the InitialVoiceCreditProxy interface.\n    */\n  function getVoiceCredits(\n    address /* _caller */,\n    bytes memory /*_data */\n  )\n    override\n    public\n    view\n    returns (uint256)\n  {\n    return maxVoiceCreditsPerAllocator;\n  }\n\n  /**\n    * @dev Publish the IPFS hash of the vote tally. Only coordinator can publish.\n    * @param _tallyHash IPFS hash of the vote tally.\n    */\n  function publishTallyHash(string calldata _tallyHash)\n    external\n    onlyCoordinator\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n    if (bytes(_tallyHash).length == 0) {\n      revert EmptyTallyHash();\n    }\n\n    tallyHash = _tallyHash;\n    emit TallyPublished(_tallyHash);\n  }\n\n  /**\n    * @dev Calculate the alpha for the capital constrained quadratic formula\n    *  in page 17 of https://arxiv.org/pdf/1809.06421.pdf\n    * @param _budget Total budget of the round to be distributed\n    * @param _totalVotesSquares Total of the squares of votes\n    * @param _totalSpent Total amount of spent voice credits\n   */\n  function calcAlpha(\n    uint256 _budget,\n    uint256 _totalVotesSquares,\n    uint256 _totalSpent\n  )\n    public\n    view\n    returns (uint256 _alpha)\n  {\n    // make sure budget = contributions + matching pool\n    uint256 contributions = _totalSpent * voiceCreditFactor;\n\n    if (_budget < contributions) {\n      revert InvalidBudget();\n    }\n\n    // guard against division by zero.\n    // This happens when no project receives more than one vote\n    if (_totalVotesSquares <= _totalSpent) {\n      revert NoProjectHasMoreThanOneVote();\n    }\n\n    return  (_budget - contributions) * ALPHA_PRECISION /\n            (voiceCreditFactor * (_totalVotesSquares - _totalSpent));\n\n  }\n\n  /**\n    * @dev Get the total amount of votes from MACI,\n    * verify the total amount of spent voice credits across all recipients,\n    * calculate the quadratic alpha value,\n    * and allow recipients to claim funds.\n    * @param _totalSpent Total amount of spent voice credits.\n    * @param _totalSpentSalt The salt.\n    */\n  function finalize(\n    uint256 _totalSpent,\n    uint256 _totalSpentSalt,\n    uint256 _newResultCommitment,\n    uint256 _perVOSpentVoiceCreditsHash\n  )\n    external\n    onlyOwner\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    _votingPeriodOver(poll);\n\n    if (!isTallied()) {\n      revert VotesNotTallied();\n    }\n    if (bytes(tallyHash).length == 0) {\n      revert TallyHashNotPublished();\n    }\n\n    // make sure we have received all the tally results\n    (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n    uint256 totalResults = uint256(TREE_ARITY) ** uint256(voteOptionTreeDepth);\n    if ( totalTallyResults != totalResults ) {\n      revert IncompleteTallyResults(totalResults, totalTallyResults);\n    }\n\n    // If nobody voted, the round should be cancelled to avoid locking of matching funds\n    if ( _totalSpent == 0) {\n      revert NoVotes();\n    }\n\n    bool verified = tally.verifySpentVoiceCredits(_totalSpent, _totalSpentSalt, _newResultCommitment, _perVOSpentVoiceCreditsHash);\n    if (!verified) {\n      revert IncorrectSpentVoiceCredits();\n    }\n\n\n    totalSpent = _totalSpent;\n    // Total amount of spent voice credits is the size of the pool of direct rewards.\n    // Everything else, including unspent voice credits and downscaling error,\n    // is considered a part of the matching pool\n    uint256 budget = nativeToken.balanceOf(address(this));\n    matchingPoolSize = budget - totalSpent * voiceCreditFactor;\n\n    alpha = calcAlpha(budget, totalVotesSquares, totalSpent);\n\n    isFinalized = true;\n  }\n\n  /**\n    * @dev Cancel funding round.\n    */\n  function cancel()\n    external\n    onlyOwner\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n    isFinalized = true;\n    isCancelled = true;\n  }\n\n  /**\n    * @dev Get allocated token amount (without verification).\n    * @param _tallyResult The result of vote tally for the recipient.\n    * @param _spent The amount of voice credits spent on the recipient.\n    */\n  function getAllocatedAmount(\n    uint256 _tallyResult,\n    uint256 _spent\n  )\n    public\n    view\n    returns (uint256)\n  {\n    // amount = ( alpha * (quadratic votes)^2 + (precision - alpha) * totalSpent ) / precision\n    uint256 quadratic = alpha * voiceCreditFactor * _tallyResult * _tallyResult;\n    uint256 totalSpentCredits = voiceCreditFactor * _spent;\n    uint256 linearPrecision = ALPHA_PRECISION * totalSpentCredits;\n    uint256 linearAlpha = alpha * totalSpentCredits;\n    return ((quadratic + linearPrecision) - linearAlpha) / ALPHA_PRECISION;\n  }\n\n  /**\n    * @dev Claim allocated tokens.\n    * @param _voteOptionIndex Vote option index.\n    * @param _spent The amount of voice credits spent on the recipients.\n    * @param _spentProof Proof of correctness for the amount of spent credits.\n    */\n  function claimFunds(\n    uint256 _voteOptionIndex,\n    uint256 _spent,\n    uint256[][] calldata _spentProof,\n    uint256 _spentSalt,\n    uint256 _resultsCommitment,\n    uint256 _spentVoiceCreditsCommitment\n  )\n    external\n  {\n    if (!isFinalized) {\n      revert RoundNotFinalized();\n    }\n\n    if (isCancelled) {\n      revert RoundCancelled();\n    }\n\n    if (_recipients[_voteOptionIndex].fundsClaimed) {\n      revert FundsAlreadyClaimed();\n    }\n    _recipients[_voteOptionIndex].fundsClaimed = true;\n\n    {\n      // create scope to avoid 'stack too deep' error\n\n      (, , , uint8 voteOptionTreeDepth) = poll.treeDepths();\n      bool verified = tally.verifyPerVOSpentVoiceCredits(\n        _voteOptionIndex,\n        _spent,\n        _spentProof,\n        _spentSalt,\n        voteOptionTreeDepth,\n        _spentVoiceCreditsCommitment,\n        _resultsCommitment\n      );\n\n      if (!verified) {\n        revert IncorrectPerVOSpentVoiceCredits();\n      }\n    }\n\n    (uint256 startTime, uint256 duration) = poll.getDeployTimeAndDuration();\n    address recipient = recipientRegistry.getRecipientAddress(\n      _voteOptionIndex,\n      startTime,\n      startTime + duration\n    );\n    if (recipient == address(0)) {\n      // Send funds back to the matching pool\n      recipient = owner();\n    }\n\n    uint256 tallyResult = _recipients[_voteOptionIndex].tallyResult;\n    uint256 allocatedAmount = getAllocatedAmount(tallyResult, _spent);\n    nativeToken.safeTransfer(recipient, allocatedAmount);\n    emit FundsClaimed(_voteOptionIndex, recipient, allocatedAmount);\n  }\n\n  /**\n    * @dev Add and verify tally votes and calculate sum of tally squares for alpha calculation.\n    * @param _voteOptionIndex Vote option index.\n    * @param _tallyResult The results of vote tally for the recipients.\n    * @param _tallyResultProof Proofs of correctness of the vote tally results.\n    * @param _tallyResultSalt the respective salt in the results object in the tally.json\n    * @param _spentVoiceCreditsHash hashLeftRight(number of spent voice credits, spent salt)\n    * @param _perVOSpentVoiceCreditsHash hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n    */\n  function _addTallyResult(\n    uint256 _voteOptionIndex,\n    uint256 _tallyResult,\n    uint256[][] memory _tallyResultProof,\n    uint256 _tallyResultSalt,\n    uint256 _spentVoiceCreditsHash,\n    uint256 _perVOSpentVoiceCreditsHash\n  )\n    private\n  {\n    RecipientStatus storage recipient = _recipients[_voteOptionIndex];\n    if (recipient.tallyVerified) {\n      revert VoteResultsAlreadyVerified();\n    }\n\n    (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n    bool resultVerified = tally.verifyTallyResult(\n      _voteOptionIndex,\n      _tallyResult,\n      _tallyResultProof,\n      _tallyResultSalt,\n      voteOptionTreeDepth,\n      _spentVoiceCreditsHash,\n      _perVOSpentVoiceCreditsHash\n    );\n\n    if (!resultVerified) {\n      revert IncorrectTallyResult();\n    }\n\n    recipient.tallyVerified = true;\n    recipient.tallyResult = _tallyResult;\n    totalVotesSquares = totalVotesSquares + (_tallyResult * _tallyResult);\n    totalTallyResults++;\n    emit TallyResultsAdded(_voteOptionIndex, _tallyResult);\n  }\n\n  /**\n    * @dev Add and verify tally results by batch.\n    * @param _voteOptionIndices Vote option index.\n    * @param _tallyResults The results of vote tally for the recipients.\n    * @param _tallyResultProofs Proofs of correctness of the vote tally results.\n    * @param _tallyResultSalt the respective salt in the results object in the tally.json\n    * @param _spentVoiceCreditsHashes hashLeftRight(number of spent voice credits, spent salt)\n    * @param _perVOSpentVoiceCreditsHashes hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n   */\n  function addTallyResultsBatch(\n    uint256[] calldata _voteOptionIndices,\n    uint256[] calldata _tallyResults,\n    uint256[][][] calldata _tallyResultProofs,\n    uint256 _tallyResultSalt,\n    uint256 _spentVoiceCreditsHashes,\n    uint256 _perVOSpentVoiceCreditsHashes\n  )\n    external\n    onlyCoordinator\n  {\n    if (isAddressZero(address(maci))) revert MaciNotSet();\n\n    if (!isTallied()) {\n      revert VotesNotTallied();\n    }\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n\n    for (uint256 i = 0; i < _voteOptionIndices.length; i++) {\n      _addTallyResult(\n        _voteOptionIndices[i],\n        _tallyResults[i],\n        _tallyResultProofs[i],\n        _tallyResultSalt,\n        _spentVoiceCreditsHashes,\n        _perVOSpentVoiceCreditsHashes\n      );\n    }\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/FundingRoundFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {FundingRound} from './FundingRound.sol';\nimport {IClrFund} from './interfaces/IClrFund.sol';\nimport {IMACIFactory} from './interfaces/IMACIFactory.sol';\nimport {MACICommon} from './MACICommon.sol';\nimport {MACI} from 'maci-contracts/contracts/MACI.sol';\nimport {SignUpGatekeeper} from 'maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol';\nimport {InitialVoiceCreditProxy} from 'maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol';\n\n/**\n* @dev A factory to deploy the funding round contract\n*/\ncontract FundingRoundFactory is MACICommon {\n  /**\n  * @dev Deploy the funding round contract\n  * @param _duration the funding round duration\n  * @param _clrfund the clrfund contract containing information used to\n  *                 deploy a funding round, e.g. nativeToken, coordinator address\n  *                 coordinator public key, etc.\n   */\n  function deploy(\n    uint256 _duration,\n    address _clrfund\n  )\n    external\n    returns (address)\n  {\n    IClrFund clrfund = IClrFund(_clrfund);\n    FundingRound newRound = new FundingRound(\n      clrfund.nativeToken(),\n      clrfund.userRegistry(),\n      clrfund.recipientRegistry(),\n      clrfund.coordinator()\n    );\n\n    IMACIFactory maciFactory = clrfund.maciFactory();\n    (MACI maci, MACI.PollContracts memory pollContracts) = maciFactory.deployMaci(\n      SignUpGatekeeper(newRound),\n      InitialVoiceCreditProxy(newRound),\n      address(newRound.topupToken()),\n      _duration,\n      newRound.coordinator(),\n      clrfund.coordinatorPubKey(),\n      address(this)\n    );\n\n    // link funding round with maci related contracts\n    newRound.setMaci(maci, pollContracts);\n    newRound.transferOwnership(_clrfund);\n    maci.transferOwnership(address(newRound));\n    return address(newRound);\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/interfaces/IClrFund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IUserRegistry} from '../userRegistry/IUserRegistry.sol';\nimport {IRecipientRegistry} from '../recipientRegistry/IRecipientRegistry.sol';\nimport {DomainObjs} from 'maci-contracts/contracts/utilities/DomainObjs.sol';\nimport {IMACIFactory} from './IMACIFactory.sol';\n\n/**\n *  @dev ClrFund interface\n */\ninterface IClrFund {\n  function nativeToken() external view returns (ERC20);\n  function maciFactory() external view returns (IMACIFactory);\n  function userRegistry() external view returns (IUserRegistry);\n  function recipientRegistry() external view returns (IRecipientRegistry);\n  function coordinatorPubKey() external view returns (DomainObjs.PubKey memory);\n  function coordinator() external view returns (address);\n}"
    },
    "contracts/strategies/qv-maci/interfaces/IFundingRound.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/**\n *  @dev FundingRound interface used by the ClrFund contract\n */\ninterface IFundingRound {\n  function nativeToken() external view returns (ERC20);\n  function isFinalized() external view returns (bool);\n  function isCancelled() external view returns (bool);\n  function cancel() external;\n  function finalize(\n    uint256 _totalSpent,\n    uint256 _totalSpentSalt,\n    uint256 _newResultCommitment,\n    uint256 _perVOSpentVoiceCreditsHash\n  ) external;\n}"
    },
    "contracts/strategies/qv-maci/interfaces/IFundingRoundFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/**\n *  @dev FundingRoundFactory interface used by the ClrFund contract\n */\ninterface IFundingRoundFactory {\n  function deploy(uint256 _duration, address _clrfund) external returns (address);\n}"
    },
    "contracts/strategies/qv-maci/interfaces/IMACIFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {IVkRegistry} from 'maci-contracts/contracts/interfaces/IVkRegistry.sol';\nimport {IVerifier} from 'maci-contracts/contracts/interfaces/IVerifier.sol';\nimport {MACI} from 'maci-contracts/contracts/MACI.sol';\nimport {Params} from 'maci-contracts/contracts/utilities/Params.sol';\nimport {DomainObjs} from 'maci-contracts/contracts/utilities/DomainObjs.sol';\nimport {SignUpGatekeeper} from 'maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol';\nimport {InitialVoiceCreditProxy} from 'maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol';\nimport {MACICommon} from '../MACICommon.sol';\n\n/**\n *  @dev MACIFactory interface\n */\ninterface IMACIFactory {\n  // Verifying Key Registry containing zk circuit parameters\n  function vkRegistry() external view returns (IVkRegistry);\n\n  // All the factory contracts used to deploy Poll, Tally, MessageProcessor, Subsidy\n  function factories() external view returns (MACICommon.Factories memory);\n\n  // verifier is used when creating Tally, MessageProcessor, Subsidy\n  function verifier() external view returns (IVerifier);\n\n  // poll parameters\n  function stateTreeDepth() external view returns (uint8);\n  function treeDepths() external view returns (Params.TreeDepths memory);\n\n  function getMessageBatchSize(uint8 _messageTreeSubDepth) external pure\n    returns(uint256 _messageBatchSize);\n\n  function TREE_ARITY() external pure returns (uint256);\n\n  function deployMaci(\n    SignUpGatekeeper signUpGatekeeper,\n    InitialVoiceCreditProxy initialVoiceCreditProxy,\n    address topupCredit,\n    uint256 duration,\n    address coordinator,\n    DomainObjs.PubKey calldata coordinatorPubKey,\n    address maciOwner\n  ) external returns (MACI _maci, MACI.PollContracts memory _pollContracts);\n\n\n  function deployMACI(\n    SignUpGatekeeper signUpGatekeeper,\n    InitialVoiceCreditProxy initialVoiceCreditProxy,\n    address topupCredit,\n    address maciOwner\n  ) external returns (MACI _maci);\n\n  \n}\n"
    },
    "contracts/strategies/qv-maci/MACICommon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/**\n * @dev a contract that holds common MACI structures\n */\ncontract MACICommon {\n  // MACI tree arity\n  uint256 public constant TREE_ARITY = 5;\n\n  /**\n   * @dev These are contract factories used to deploy MACI poll processing contracts\n   * when creating a new ClrFund funding round.\n  */\n  struct Factories {\n    address pollFactory;\n    address tallyFactory;\n    // subsidyFactory is not currently used, it's just a place holder here\n    address subsidyFactory;\n    address messageProcessorFactory;\n  }\n\n}"
    },
    "contracts/strategies/qv-maci/MACIFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {MACI} from 'maci-contracts/contracts/MACI.sol';\nimport {IPollFactory} from 'maci-contracts/contracts/interfaces/IPollFactory.sol';\nimport {ITallySubsidyFactory} from 'maci-contracts/contracts/interfaces/ITallySubsidyFactory.sol';\nimport {IMessageProcessorFactory} from 'maci-contracts/contracts/interfaces/IMPFactory.sol';\nimport {SignUpGatekeeper} from 'maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol';\nimport {InitialVoiceCreditProxy} from 'maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol';\nimport {TopupCredit} from 'maci-contracts/contracts/TopupCredit.sol';\nimport {VkRegistry} from 'maci-contracts/contracts/VkRegistry.sol';\nimport {Verifier} from 'maci-contracts/contracts/crypto/Verifier.sol';\nimport {SnarkCommon} from 'maci-contracts/contracts/crypto/SnarkCommon.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Params} from 'maci-contracts/contracts/utilities/Params.sol';\nimport {DomainObjs} from 'maci-contracts/contracts/utilities/DomainObjs.sol';\nimport {MACICommon} from './MACICommon.sol';\n\ncontract MACIFactory is Ownable, Params, SnarkCommon, DomainObjs, MACICommon {\n\n  // Verifying Key Registry containing circuit parameters\n  VkRegistry public vkRegistry;\n  // All the factory contracts used to deploy Poll, Tally, MessageProcessor, Subsidy\n  Factories public factories;\n  // verifier is used when creating Tally, MessageProcessor, Subsidy\n  Verifier public verifier;\n\n  // circuit parameters\n  uint8 public stateTreeDepth;\n  TreeDepths public treeDepths;\n\n  // Events\n  event MaciParametersChanged();\n  event MaciDeployed(address _maci);\n\n  // errors\n  error NotInitialized();\n  error ProcessVkNotSet();\n  error TallyVkNotSet();\n  error InvalidVkRegistry();\n  error InvalidPollFactory();\n  error InvalidTallyFactory();\n  error InvalidSubsidyFactory();\n  error InvalidMessageProcessorFactory();\n  error InvalidVerifier();\n\n  constructor(\n    address _vkRegistry,\n    Factories memory _factories,\n    address _verifier\n  ) {\n    if (_vkRegistry == address(0)) revert InvalidVkRegistry();\n    if (_factories.pollFactory == address(0)) revert InvalidPollFactory();\n    if (_factories.tallyFactory == address(0)) revert InvalidTallyFactory();\n    if (_factories.messageProcessorFactory == address(0)) revert InvalidMessageProcessorFactory();\n    if (_verifier == address(0)) revert InvalidVerifier();\n\n    vkRegistry = VkRegistry(_vkRegistry);\n    factories = _factories;\n    verifier = Verifier(_verifier);\n    \n  }\n\n  /**\n   * @dev calculate the message batch size\n   */\n  function getMessageBatchSize(uint8 messageTreeSubDepth) public pure\n    returns(uint256 _messageBatchSize) {\n      _messageBatchSize = TREE_ARITY ** messageTreeSubDepth;\n  }\n\n  /**\n   * @dev set vk registry\n   */\n  function setVkRegistry(address _vkRegistry) public onlyOwner {\n    if (_vkRegistry == address(0)) revert InvalidVkRegistry();\n\n    vkRegistry = VkRegistry(_vkRegistry);\n  }\n\n  /**\n   * @dev set poll factory in MACI factory\n   * @param _pollFactory poll factory\n   */\n  function setPollFactory(address _pollFactory) public onlyOwner {\n    if (_pollFactory == address(0)) revert InvalidPollFactory();\n\n    factories.pollFactory = _pollFactory;\n  }\n\n  /**\n   * @dev set tally factory in MACI factory\n   * @param _tallyFactory tally factory\n   */\n  function setTallyFactory(address _tallyFactory) public onlyOwner {\n    if (_tallyFactory == address(0)) revert InvalidTallyFactory();\n\n    factories.tallyFactory = _tallyFactory;\n  }\n\n  /**\n   * @dev set message processor factory in MACI factory\n   * @param _messageProcessorFactory message processor factory\n   */\n  function setMessageProcessorFactory(address _messageProcessorFactory) public onlyOwner {\n    if (_messageProcessorFactory == address(0)) revert InvalidMessageProcessorFactory();\n\n    factories.messageProcessorFactory = _messageProcessorFactory;\n  }\n\n  /**\n   * @dev set verifier in MACI factory\n   * @param _verifier verifier contract\n   */\n  function setVerifier(address _verifier) public onlyOwner {\n    if (_verifier == address(0)) revert InvalidVerifier();\n\n    verifier = Verifier(_verifier);\n  }\n\n  /**\n   * @dev set MACI zkeys parameters\n   */\n  function setMaciParameters(\n    uint8 _stateTreeDepth,\n    TreeDepths calldata _treeDepths\n  )\n    public\n    onlyOwner\n  {\n\n    uint256 messageBatchSize = getMessageBatchSize(_treeDepths.messageTreeSubDepth);\n\n    if (!vkRegistry.hasProcessVk(\n      _stateTreeDepth,\n      _treeDepths.messageTreeDepth,\n      _treeDepths.voteOptionTreeDepth,\n      messageBatchSize)\n    ) {\n      revert ProcessVkNotSet();\n    }\n\n    if (!vkRegistry.hasTallyVk(\n      _stateTreeDepth,\n      _treeDepths.intStateTreeDepth,\n      _treeDepths.voteOptionTreeDepth)\n    ) {\n      revert TallyVkNotSet();\n    }\n\n    stateTreeDepth = _stateTreeDepth;\n    treeDepths = _treeDepths;\n\n    emit MaciParametersChanged();\n  }\n\n  /**\n    * @dev Deploy new MACI instance.\n    */\n  function deployMaci(\n    SignUpGatekeeper signUpGatekeeper,\n    InitialVoiceCreditProxy initialVoiceCreditProxy,\n    address topupCredit,\n    uint256 duration,\n    address coordinator,\n    PubKey calldata coordinatorPubKey,\n    address maciOwner\n  )\n    external\n    returns (MACI _maci, MACI.PollContracts memory _pollContracts)\n  {\n    uint256 messageBatchSize = getMessageBatchSize(treeDepths.messageTreeSubDepth);\n\n    if (!vkRegistry.hasProcessVk(\n      stateTreeDepth,\n      treeDepths.messageTreeDepth,\n      treeDepths.voteOptionTreeDepth,\n      messageBatchSize)\n    ) {\n      revert ProcessVkNotSet();\n    }\n\n    if (!vkRegistry.hasTallyVk(\n      stateTreeDepth,\n      treeDepths.intStateTreeDepth,\n      treeDepths.voteOptionTreeDepth)\n    ) {\n      revert TallyVkNotSet();\n    }\n\n    _maci = new MACI(\n      IPollFactory(factories.pollFactory),\n      IMessageProcessorFactory(factories.messageProcessorFactory),\n      ITallySubsidyFactory(factories.tallyFactory),\n      ITallySubsidyFactory(factories.subsidyFactory),\n      signUpGatekeeper,\n      initialVoiceCreditProxy,\n      TopupCredit(topupCredit),\n      stateTreeDepth\n    );\n\n    _pollContracts = _maci.deployPoll(\n      duration,\n      treeDepths,\n      coordinatorPubKey,\n      address(verifier),\n      address(vkRegistry),\n      // pass false to not deploy the subsidy contract\n      false\n    );\n\n    // transfer ownership to coordinator to run the tally scripts\n    Ownable(_pollContracts.poll).transferOwnership(coordinator);\n    Ownable(_pollContracts.messageProcessor).transferOwnership(coordinator);\n    Ownable(_pollContracts.tally).transferOwnership(coordinator);\n\n    _maci.transferOwnership(maciOwner);\n\n    emit MaciDeployed(address(_maci));\n  }\n\n  /**\n    * @dev Deploy new MACI instance.\n    */\n  function deployMACI(\n    SignUpGatekeeper signUpGatekeeper,\n    InitialVoiceCreditProxy initialVoiceCreditProxy,\n    address topupCredit,\n    address maciOwner\n  )\n    external\n    returns (MACI _maci)\n  {\n    uint256 messageBatchSize = getMessageBatchSize(treeDepths.messageTreeSubDepth);\n\n    if (!vkRegistry.hasProcessVk(\n      stateTreeDepth,\n      treeDepths.messageTreeDepth,\n      treeDepths.voteOptionTreeDepth,\n      messageBatchSize)\n    ) {\n      revert ProcessVkNotSet();\n    }\n\n    if (!vkRegistry.hasTallyVk(\n      stateTreeDepth,\n      treeDepths.intStateTreeDepth,\n      treeDepths.voteOptionTreeDepth)\n    ) {\n      revert TallyVkNotSet();\n    }\n\n    _maci = new MACI(\n      IPollFactory(factories.pollFactory),\n      IMessageProcessorFactory(factories.messageProcessorFactory),\n      ITallySubsidyFactory(factories.tallyFactory),\n      ITallySubsidyFactory(factories.subsidyFactory),\n      signUpGatekeeper,\n      initialVoiceCreditProxy,\n      TopupCredit(topupCredit),\n      stateTreeDepth\n    );\n\n    _maci.transferOwnership(maciOwner);\n\n    emit MaciDeployed(address(_maci));\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/QVMaciStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\n\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ITallySubsidyFactory} from \"maci-contracts/contracts/interfaces/ITallySubsidyFactory.sol\";\n\nimport {IMessageProcessorFactory} from \"maci-contracts/contracts/interfaces/IMPFactory.sol\";\n\nimport {SignUpGatekeeper} from \"maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol\";\n\nimport {InitialVoiceCreditProxy} from \"maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol\";\n\nimport {IMACIFactory} from \"./interfaces/IMACIFactory.sol\";\n\nimport {DomainObjs} from \"maci-contracts/contracts/utilities/DomainObjs.sol\";\n\nimport {CommonUtilities} from \"maci-contracts/contracts/utilities/CommonUtilities.sol\";\n\nimport {TopupToken} from \"./TopupToken.sol\";\n\nimport {MACI} from \"maci-contracts/contracts/MACI.sol\";\n\nimport {Poll} from \"maci-contracts/contracts/Poll.sol\";\n\nimport {Tally} from \"maci-contracts/contracts/Tally.sol\";\n\nimport {MACICommon} from \"./MACICommon.sol\";\n\nimport {Params} from \"maci-contracts/contracts/utilities/Params.sol\";\n\n// External Libraries\nimport {Multicall} from \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport {Errors} from \"./Errors.sol\";\n\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\ncontract QVMaciStrategy is BaseStrategy, MACICommon, Multicall, DomainObjs, Params, CommonUtilities, Errors{\n\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient\"s application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient\"s application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient\"s application\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(\n        address indexed recipientId, uint256 applicationId, bytes data, address sender, Status status\n    );\n\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice Whether the distribution started or not\n    bool public distributionStarted;\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    /// @notice The MACI factory contract\n    IMACIFactory private _maciFactory;\n\n    Factories private _factories;\n\n    MACI public _maci;\n\n    Poll public poll;\n\n    Tally public tally;\n\n    bool public isFinalized;\n\n    string public tallyHash;\n\n    uint256 public totalTallyResults;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n        // slot 3\n        uint256 maxVoiceCreditsPerAllocator;\n        \n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n        // slot 2\n        uint256 applicationId;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> applicationId -> status -> count\n    mapping(address => mapping(uint256 => mapping(Status => uint256))) public reviewsByStatus;\n\n    // recipientId -> applicationId -> reviewer -> status\n    mapping(address => mapping(uint256 => mapping(address => Status))) public reviewedByManager;\n\n    // recipientIndex to recipient address mapping\n    mapping(uint256 => address) public recipientIndexToAddress;\n\n    // mapping of recipientId to index in recipientIds array\n    mapping(address => uint256) public recipientIdToIndex;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev This will revert if the allocation has ended.\n    modifier onlyBeforeAllocationEnds() {\n        _checkOnlyBeforeAllocationEnds();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(\n        address maciFactory,\n        address _vkRegistry,\n        Factories memory __factories,\n        address _verifier,\n        address _allo, \n        string memory _name\n    ) BaseStrategy(_allo, _name) {\n        _maciFactory = IMACIFactory(maciFactory);\n        _factories = __factories;\n    }\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParams memory initializeParamsSimple) = abi.decode(_data, (InitializeParams));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n        emit Initialized(_poolId, _data);\n    }\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n\n        maxVoiceCreditsPerAllocator = _params.maxVoiceCreditsPerAllocator;\n\n        _maci = _maciFactory.deployMACI(\n            SignUpGatekeeper(address(this)),\n            InitialVoiceCreditProxy(address(this)),\n            address(new TopupToken()),\n            address(this)\n        );\n    }\n\n    /// ================================\n    /// ====== External/Public =========\n    /// ================================\n\n    /**\n    * @dev Signup to this funding round.\n    * @param pubKey Contributor\"s public key.\n    */\n    function signup(PubKey calldata pubKey ) external\n    {\n        if (isAddressZero(address(_maci))) revert MaciNotSet(); \n        if (isFinalized) revert RoundAlreadyFinalized();\n\n        bytes memory signUpGatekeeperData = abi.encode(msg.sender, maxVoiceCreditsPerAllocator);\n        bytes memory initialVoiceCreditProxyData = abi.encode(msg.sender);\n\n        _maci.signUp(\n            pubKey,\n            signUpGatekeeperData,\n            initialVoiceCreditProxyData\n        );\n    }\n\n    /**\n    * @dev Register user for voting.\n    * This function is part of SignUpGatekeeper interface.\n    * @param _data Encoded address of a contributor.\n    */\n    function register(\n        address /* _caller */,\n        bytes memory _data\n    )\n        public view\n    {\n        if (msg.sender != address(_maci)) {\n            revert OnlyMaciCanRegisterVoters();\n        }\n\n        address user = abi.decode(_data, (address));\n        bool verified = isVerifiedUser(user);\n\n        if (!verified) {\n            revert UserNotVerified();\n        }\n    }\n\n    function deploy_poll(\n        uint256 duration,\n        TreeDepths memory treeDepths,\n        PubKey calldata coordinatorPubKey,\n        address coordinator,\n        address verifier,\n        address vkRegistry\n    ) public returns (MACI.PollContracts memory _pollContracts) {\n        if (isFinalized) revert RoundAlreadyFinalized(); \n\n        _pollContracts = _maci.deployPoll(\n            duration,\n            treeDepths,\n            coordinatorPubKey,\n            address(verifier),\n            address(vkRegistry),\n            // pass false to not deploy the subsidy contract\n            false\n        );\n        // transfer ownership to coordinator to run the tally scripts\n        Ownable(_pollContracts.poll).transferOwnership(coordinator);\n        Ownable(_pollContracts.messageProcessor).transferOwnership(coordinator);\n        Ownable(_pollContracts.tally).transferOwnership(coordinator);\n\n        poll = Poll(_pollContracts.poll);\n\n        _setTally(_pollContracts.tally);\n    }\n\n    /**\n    * @dev Set the tally contract\n    * @param _tally The tally contract address\n    */\n    function _setTally(address _tally) private\n    {\n        if (isAddressZero(_tally)) {\n        revert InvalidTally(); \n        }\n\n        tally = Tally(_tally);\n        // emit TallySet(address(tally));\n    }\n\n    /**\n    * @dev Have the votes been tallied\n    */\n    function isTallied() private view returns (bool) {\n        (uint256 numSignUps, ) = poll.numSignUpsAndMessages();\n        (uint8 intStateTreeDepth, , , ) = poll.treeDepths();\n        uint256 tallyBatchSize = TREE_ARITY ** uint256(intStateTreeDepth);\n        uint256 tallyBatchNum = tally.tallyBatchNum();\n        uint256 totalTallied = tallyBatchNum * tallyBatchSize;\n\n        return numSignUps > 0 && totalTallied >= numSignUps;\n    }\n\n  /**\n    * @dev Publish the IPFS hash of the vote tally. Only coordinator can publish.\n    * @param _tallyHash IPFS hash of the vote tally.\n    */\n  function publishTallyHash(string calldata _tallyHash)\n    external\n    // onlyCoordinator\n  {\n    if (isFinalized) {\n      revert RoundAlreadyFinalized();\n    }\n    if (bytes(_tallyHash).length == 0) {\n      revert EmptyTallyHash();\n    }\n\n    tallyHash = _tallyHash;\n    emit TallyPublished(_tallyHash);\n  }\n\n  /**\n    * @dev Get the total amount of votes from MACI,\n    * verify the total amount of spent voice credits across all recipients,\n    * calculate the quadratic alpha value,\n    * and allow recipients to claim funds.\n    * @param _totalSpent Total amount of spent voice credits.\n    * @param _totalSpentSalt The salt.\n  */\n  function finalize(\n    uint256 _totalSpent,\n    uint256 _totalSpentSalt,\n    uint256 _newResultCommitment,\n    uint256 _perVOSpentVoiceCreditsHash\n  )\n    external\n    // onlyOwner\n  {\n    if (isFinalized) {\n      revert  RoundAlreadyFinalized();\n    }\n\n    if (isAddressZero(address(_maci))) revert MaciNotSet();\n\n    _votingPeriodOver(poll);\n\n    if (!isTallied()) {\n      revert VotesNotTallied();\n    }\n    if (bytes(tallyHash).length == 0) {\n      revert TallyHashNotPublished();\n    }\n\n    // make sure we have received all the tally results\n    (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n    uint256 totalResults = uint256(TREE_ARITY) ** uint256(voteOptionTreeDepth);\n    if ( totalTallyResults != totalResults ) {\n      revert IncompleteTallyResults(totalResults, totalTallyResults);\n    }\n\n    // If nobody voted, the round should be cancelled to avoid locking of matching funds\n    if ( _totalSpent == 0) {\n      revert NoVotes();\n    }\n\n    bool verified = tally.verifySpentVoiceCredits(_totalSpent, _totalSpentSalt, _newResultCommitment, _perVOSpentVoiceCreditsHash);\n    if (!verified) {\n      revert IncorrectSpentVoiceCredits();\n    }\n\n    // Make sure that is the correct to do into the QV Calculation \n\n    totalRecipientVotes = _totalSpent;\n    // Total amount of spent voice credits is the size of the pool of direct rewards.\n    // Everything else, including unspent voice credits and downscaling error,\n    // is considered a part of the matching pool\n    // uint256 budget = nativeToken.balanceOf(address(this));\n    // matchingPoolSize = budget - totalSpent * voiceCreditFactor;\n\n    // alpha = calcAlpha(budget, totalVotesSquares, totalSpent);\n\n    isFinalized = true;\n  }\n\n    /**\n        * @dev Add and verify tally votes and calculate sum of tally squares for alpha calculation.\n        * @param _voteOptionIndex Vote option index.\n        * @param _tallyResult The results of vote tally for the recipients.\n        * @param _tallyResultProof Proofs of correctness of the vote tally results.\n        * @param _tallyResultSalt the respective salt in the results object in the tally.json\n        * @param _spentVoiceCreditsHash hashLeftRight(number of spent voice credits, spent salt)\n        * @param _perVOSpentVoiceCreditsHash hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n        */\n    function _addTallyResult(\n        uint256 _voteOptionIndex,\n        uint256 _tallyResult,\n        uint256[][] memory _tallyResultProof,\n        uint256 _tallyResultSalt,\n        uint256 _spentVoiceCreditsHash,\n        uint256 _perVOSpentVoiceCreditsHash\n    )\n        private\n    {\n        // RecipientStatus storage recipient = _recipients[_voteOptionIndex];\n        // if (recipient.tallyVerified) {\n        // revert VoteResultsAlreadyVerified();\n        // }\n\n        (,,, uint8 voteOptionTreeDepth) = poll.treeDepths();\n        bool resultVerified = tally.verifyTallyResult(\n            _voteOptionIndex,\n            _tallyResult,\n            _tallyResultProof,\n            _tallyResultSalt,\n            voteOptionTreeDepth,\n            _spentVoiceCreditsHash,\n            _perVOSpentVoiceCreditsHash\n        );\n\n        if (!resultVerified) {\n            revert IncorrectTallyResult(); \n        }\n\n        _allocate(_voteOptionIndex, _tallyResult);\n\n        // recipient.tallyVerified = true;\n        // recipient.tallyResult = _tallyResult;\n        // totalVotesSquares = totalVotesSquares + (_tallyResult * _tallyResult);\n        totalTallyResults++;\n        emit TallyResultsAdded(_voteOptionIndex, _tallyResult);\n    }\n\n    /**\n        * @dev Add and verify tally results by batch.\n        * @param _voteOptionIndices Vote option index.\n        * @param _tallyResults The results of vote tally for the recipients.\n        * @param _tallyResultProofs Proofs of correctness of the vote tally results.\n        * @param _tallyResultSalt the respective salt in the results object in the tally.json\n        * @param _spentVoiceCreditsHashes hashLeftRight(number of spent voice credits, spent salt)\n        * @param _perVOSpentVoiceCreditsHashes hashLeftRight(merkle root of the no spent voice credits per vote option, perVOSpentVoiceCredits salt)\n    */\n    function addTallyResultsBatch(\n        uint256[] calldata _voteOptionIndices,\n        uint256[] calldata _tallyResults,\n        uint256[][][] calldata _tallyResultProofs,\n        uint256 _tallyResultSalt,\n        uint256 _spentVoiceCreditsHashes,\n        uint256 _perVOSpentVoiceCreditsHashes\n    )\n        external\n        // onlyCoordinator\n    {\n        if (isAddressZero(address(_maci))) revert MaciNotSet();\n\n        if (!isTallied()) {\n            revert VotesNotTallied();\n        }\n        if (isFinalized) {\n            revert RoundAlreadyFinalized();\n        }\n\n        for (uint256 i = 0; i < _voteOptionIndices.length; i++) {\n        _addTallyResult(\n            _voteOptionIndices[i],\n            _tallyResults[i],\n            _tallyResultProofs[i],\n            _tallyResultSalt,\n            _spentVoiceCreditsHashes,\n            _perVOSpentVoiceCreditsHashes\n        );\n        }\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    function isAddressZero(address _address) internal pure returns (bool) {\n        return _address == address(0);\n    }\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal override {}\n\n    /// @notice Allocate votes to a recipient\n    /// @param _voteOptionIndex The vote option index\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(\n        uint256 _voteOptionIndex,\n        uint256 _voiceCreditsToAllocate\n    ) internal {\n        address recipientId = recipientIndexToAddress[_voteOptionIndex];\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        // Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        // if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        // if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(recipient, recipientId, _voiceCreditsToAllocate);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /**\n        * @dev Check if the user is verified.\n    */\n    function isVerifiedUser(address _allocator)\n        public\n        view\n        returns (bool)\n    {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n\n  /**\n    * @dev Get the amount of voice credits for a given address.\n    * This function is a part of the InitialVoiceCreditProxy interface.\n    * @param _data Encoded address of a user.\n    */\n  function getVoiceCredits(\n    address /* _caller */,\n    bytes memory _data\n  )\n    public\n    view\n    returns (uint256)\n  {\n    address user = abi.decode(_data, (address));\n    if(!allowedAllocators[user]){\n        return 0;\n    }\n    return maxVoiceCreditsPerAllocator;\n  }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        onlyPoolManager(msg.sender)\n        onlyBeforeAllocationEnds\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n            uint256 applicationId = recipient.applicationId;\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            if (reviewedByManager[recipientId][applicationId][msg.sender] > Status.None) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            // track the review cast for the recipient and update status counter\n            reviewedByManager[recipientId][applicationId][msg.sender] = recipientStatus;\n            reviewsByStatus[recipientId][applicationId][recipientStatus]++;\n\n            // update the recipient status if the review threshold has been reached\n            if (reviewsByStatus[recipientId][applicationId][recipientStatus] >= reviewThreshold) {\n                recipient.recipientStatus = recipientStatus;\n\n                // Changes for QVMACIStrategy \n                if (recipientStatus == Status.Accepted) {\n                    // Adding the recipient to the registry so that we have a voting option on MACI\n                    addRecipient(recipientId);\n                }\n\n                emit RecipientStatusUpdated(recipientId, applicationId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, applicationId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// @notice Withdraw the tokens from the pool\n    /// @dev Callable by the pool manager only 30 days after the allocation has ended\n    /// @param _token The token to withdraw\n    function withdraw(address _token) external onlyPoolManager(msg.sender) {\n        if (block.timestamp <= allocationEndTime + 30 days) {\n            revert INVALID();\n        }\n\n        uint256 amount = _getBalance(_token, address(this));\n\n        // Transfer the tokens to the \"msg.sender\" (pool manager calling function)\n        _transferAmount(_token, msg.sender, amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view  {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view  {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view {\n        if (block.timestamp <= allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Checks if the allocation has not ended and reverts if it has.\n    /// @dev This will revert if the allocation has ended.\n    function _checkOnlyBeforeAllocationEnds() internal view {\n        if (block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The \"_data\" parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n        ++recipient.applicationId;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            // recipient updating rejected/pending/appealed/accepted application\n            if (currentStatus == Status.Rejected) {\n                recipient.recipientStatus = Status.Appealed;\n            } else if (currentStatus == Status.Accepted) {\n                // recipient updating already accepted application\n                recipient.recipientStatus = Status.Pending;\n            }\n\n            // emit the new status with the \"_data\" that was passed in\n            emit UpdatedRegistration(recipientId, recipient.applicationId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The \"_sender\" must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n        if (!distributionStarted) {\n            distributionStarted = true;\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the \"_sender\" is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// _sender The sender of the transaction\n    function _qv_allocate(\n        /*Allocator storage  _allocator */\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate\n       /* address  _sender */\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // check if the recipient is accepted\n        if (!_isAcceptedRecipient(_recipientId)) revert RECIPIENT_ERROR(_recipientId);\n\n        // determine actual votes cast\n        uint256 voteResult = _sqrt(_voiceCreditsToAllocate * 1e18);\n\n        // update the values\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived = voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, address(this));\n    }\n\n    /// @notice Add a recipient to the MACI contract\n    /// @param _recipientId The ID of the recipient\n    function addRecipient(address _recipientId) internal {\n        uint256 recipientIndex = uint256(keccak256(abi.encode(_recipientId)));\n        recipientIdToIndex[_recipientId] = recipientIndex;\n        recipientIndexToAddress[recipientIndex] = _recipientId;\n    }\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a \"PayoutSummary\" struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n\n    function _beforeIncreasePoolAmount(uint256) internal view  override {\n        if (distributionStarted) {\n            revert INVALID();\n        }\n    }\n\n\n    /// @notice Contract should be able to receive NATIVE\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/qv-maci/recipientRegistry/BaseRecipientRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport './IRecipientRegistry.sol';\n\n/**\n * @dev Abstract contract containing common methods for recipient registries.\n */\nabstract contract BaseRecipientRegistry is IRecipientRegistry {\n\n  // Structs\n  struct MACIRecipient {\n    address addr;\n    uint256 index;\n    uint256 addedAt;\n    uint256 removedAt;\n  }\n\n  // State\n  address public controller;\n  uint256 public maxRecipients;\n  mapping(bytes32 => MACIRecipient) internal maci_recipients;\n  bytes32[] private removed;\n  // Slot 0 corresponds to index 1\n  // Each slot contains a history of recipients who occupied it\n  bytes32[][] private slots;\n\n  /**\n    * @dev Set maximum number of recipients.\n    * @param _maxRecipients Maximum number of recipients.\n    * @return True if operation is successful.\n    */\n  function setMaxRecipients(uint256 _maxRecipients)\n    override\n    external\n    returns (bool)\n  {\n    require(\n      _maxRecipients >= maxRecipients,\n      'RecipientRegistry: Max number of recipients can not be decreased'\n    );\n    if (controller != msg.sender) {\n      // This allows other clrfund instances to use the registry\n      // but only controller can actually increase the limit.\n      return false;\n    }\n    maxRecipients = _maxRecipients;\n    return true;\n  }\n\n  /**\n    * @dev Register recipient as eligible for funding allocation.\n    * @param _recipientId The ID of recipient.\n    * @param _recipient The address that receives funds.\n    * @return Recipient index.\n    */\n  function _addRecipient(bytes32 _recipientId, address _recipient)\n    internal\n    returns (uint256)\n  {\n    require(maxRecipients > 0, 'RecipientRegistry: Recipient limit is not set');\n    require(maci_recipients[_recipientId].index == 0, 'RecipientRegistry: Recipient already registered');\n    uint256 recipientIndex = 0;\n    uint256 nextRecipientIndex = slots.length + 1;\n    if (nextRecipientIndex <= maxRecipients) {\n      // Assign next index in sequence\n      recipientIndex = nextRecipientIndex;\n      bytes32[] memory history = new bytes32[](1);\n      history[0] = _recipientId;\n      slots.push(history);\n    } else {\n      // Assign one of the vacant recipient indexes\n      require(removed.length > 0, 'RecipientRegistry: Recipient limit reached');\n      bytes32 removedRecipient = removed[removed.length - 1];\n      removed.pop();\n      recipientIndex = maci_recipients[removedRecipient].index;\n      slots[recipientIndex - 1].push(_recipientId);\n    }\n    maci_recipients[_recipientId] = MACIRecipient(_recipient, recipientIndex, block.timestamp, 0);\n    return recipientIndex;\n  }\n\n  /**\n    * @dev Remove recipient from the registry.\n    * @param _recipientId The ID of recipient.\n    */\n  function _removeRecipient(bytes32 _recipientId)\n    internal\n  {\n    require(maci_recipients[_recipientId].index != 0, 'RecipientRegistry: Recipient is not in the registry');\n    require(maci_recipients[_recipientId].removedAt == 0, 'RecipientRegistry: Recipient already removed');\n    maci_recipients[_recipientId].removedAt = block.timestamp;\n    removed.push(_recipientId);\n  }\n\n  /**\n    * @dev Get recipient address by index.\n    * @param _index Recipient index.\n    * @param _startTime The start time of the funding round.\n    * @param _endTime The end time of the funding round.\n    * @return Recipient address.\n    */\n  function getRecipientAddress(\n    uint256 _index,\n    uint256 _startTime,\n    uint256 _endTime\n  )\n    override\n    external\n    view\n    returns (address)\n  {\n    if (_index == 0 || _index > slots.length) {\n      return address(0);\n    }\n    bytes32[] memory history = slots[_index - 1];\n    if (history.length == 0) {\n      // Slot is not occupied\n      return address(0);\n    }\n    address prevRecipientAddress = address(0);\n    for (uint256 idx = history.length; idx > 0; idx--) {\n      bytes32 recipientId = history[idx - 1];\n      MACIRecipient memory recipient = maci_recipients[recipientId];\n      if (recipient.addedAt > _endTime) {\n        // Recipient added after the end of the funding round, skip\n        continue;\n      }\n      else if (recipient.removedAt != 0 && recipient.removedAt <= _startTime) {\n        // Recipient had been already removed when the round started\n        // Stop search because subsequent items were removed even earlier\n        return prevRecipientAddress;\n      }\n      // This recipient is valid, but the recipient who occupied\n      // this slot before also needs to be checked.\n      prevRecipientAddress = recipient.addr;\n    }\n    return prevRecipientAddress;\n  }\n\n  /**\n    * @dev Get recipient count.\n    * @return count of active recipients in the registry.\n    */\n  function getRecipientCount() public view returns(uint256) {\n      return slots.length - removed.length;\n  }\n\n  /**\n   * @dev Make a unique recipient id for different registries\n   * @param _registry Recipient registry address\n   * @param _recipient Recipient address\n   * @param _metadata Recipient metadata\n   * @return recipient id\n   */\n   function makeRecipientId(address _registry, address _recipient, string memory _metadata)\n    internal\n    pure\n    returns(bytes32)\n  {\n    return keccak256(abi.encodePacked(_registry, _recipient, _metadata));\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/recipientRegistry/IRecipientRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the recipient registry.\n *\n * This contract must do the following:\n *\n * - Add recipients to the registry.\n * - Allow only legitimate recipients into the registry.\n * - Assign an unique index to each recipient.\n * - Limit the maximum number of entries according to a parameter set by the funding round factory.\n * - Remove invalid entries.\n * - Prevent indices from changing during the funding round.\n * - Find address of a recipient by their unique index.\n */\ninterface IRecipientRegistry {\n\n  function setMaxRecipients(uint256 _maxRecipients) external returns (bool);\n\n  function getRecipientAddress(uint256 _index, uint256 _startBlock, uint256 _endBlock) external view returns (address);\n\n}\n"
    },
    "contracts/strategies/qv-maci/recipientRegistry/SimpleRecipientRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport './BaseRecipientRegistry.sol';\n\n/**\n * @dev A simple recipient registry managed by a trusted entity.\n */\nabstract contract SimpleRecipientRegistry is Ownable, BaseRecipientRegistry {\n\n  // Events\n  event RecipientAdded(\n    bytes32 indexed _recipientId,\n    address _recipient,\n    string _metadata,\n    uint256 _index,\n    uint256 _timestamp\n  );\n  event RecipientRemoved(\n    bytes32 indexed _recipientId,\n    uint256 _timestamp\n  );\n\n  /**\n    * @dev Deploy the registry.\n    * @param _controller Controller address. Normally it's a funding round factory contract.\n    */\n  constructor(\n    address _controller\n  )\n  {\n    controller = _controller;\n  }\n\n  /**\n    * @dev Register recipient as eligible for funding allocation.\n    * @param _recipient The address that receives funds.\n    * @param _metadata The metadata info of the recipient.\n    */\n  function addRecipient(address _recipient, string memory _metadata)\n    internal\n  {\n    require(_recipient != address(0), 'RecipientRegistry: Recipient address is zero');\n    require(bytes(_metadata).length != 0, 'RecipientRegistry: Metadata info is empty string');\n    bytes32 recipientId = makeRecipientId(address(this), _recipient, _metadata);\n    uint256 recipientIndex = _addRecipient(recipientId, _recipient);\n    emit RecipientAdded(recipientId, _recipient, _metadata, recipientIndex, block.timestamp);\n  }\n\n  /**\n    * @dev Remove recipient from the registry.\n    * @param _recipientId The ID of recipient.\n    */\n  function removeRecipient(bytes32 _recipientId)\n    internal\n    onlyOwner\n  {\n    _removeRecipient(_recipientId);\n    emit RecipientRemoved(_recipientId, block.timestamp);\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/TopupToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * TopupToken is used by MACI Poll contract to validate the topup credits of a user\n * In clrfund, this is only used as gateway to pass the topup amount to the Poll contract\n */\ncontract TopupToken is ERC20, Ownable {\n  constructor() ERC20(\"TopupCredit\", \"TopupCredit\") {}\n\n  function airdrop(uint256 amount) public onlyOwner {\n    _mint(msg.sender, amount);\n  }\n}\n"
    },
    "contracts/strategies/qv-maci/userRegistry/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Interface of the registry of verified users.\n */\ninterface IUserRegistry {\n\n  function isVerifiedUser(address _user) external view returns (bool);\n\n}\n"
    },
    "contracts/strategies/qv-maci/userRegistry/SimpleUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport './IUserRegistry.sol';\n\n/**\n * @dev A simple user registry managed by a trusted entity.\n */\ncontract SimpleUserRegistry is Ownable, IUserRegistry {\n\n  mapping(address => bool) private users;\n\n  // Events\n  event UserAdded(address indexed _user);\n  event UserRemoved(address indexed _user);\n\n  /**\n    * @dev Add verified unique user to the registry.\n    */\n  function addUser(address _user)\n    external\n    onlyOwner\n  {\n    require(_user != address(0), 'UserRegistry: User address is zero');\n    require(!users[_user], 'UserRegistry: User already verified');\n    users[_user] = true;\n    emit UserAdded(_user);\n  }\n\n  /**\n    * @dev Remove user from the registry.\n    */\n  function removeUser(address _user)\n    external\n    onlyOwner\n  {\n    require(users[_user], 'UserRegistry: User is not in the registry');\n    delete users[_user];\n    emit UserRemoved(_user);\n  }\n\n  /**\n    * @dev Check if the user is verified.\n    */\n  function isVerifiedUser(address _user)\n    override\n    external\n    view\n    returns (bool)\n  {\n    return users[_user];\n  }\n\n}\n"
    },
    "contracts/strategies/qv-simple/QVSimpleStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {Multicall} from \"@openzeppelin/contracts/utils/Multicall.sol\";\n// Strategy Contracts\nimport {QVBaseStrategy} from \"../qv-base/QVBaseStrategy.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\ncontract QVSimpleStrategy is QVBaseStrategy, Multicall {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// ======================\n    /// ======= Struct =======\n    /// ======================\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParamsSimple {\n        // slot 0\n        uint256 maxVoiceCreditsPerAllocator;\n        // slot 1..n\n        InitializeParams params;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n    constructor(address _allo, string memory _name) QVBaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParamsSimple memory initializeParamsSimple) = abi.decode(_data, (InitializeParamsSimple));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple.params);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n        emit Initialized(_poolId, _data);\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        (address recipientId, uint256 voiceCreditsToAllocate) = abi.decode(_data, (address, uint256));\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view override returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /**\n    * @dev Check if the user is verified.\n    */\n    function isVerifiedUser(address _allocator)\n        external\n        view\n        returns (bool)\n    {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n}\n"
    },
    "maci-contracts/contracts/crypto/Hasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { SnarkConstants } from \"./SnarkConstants.sol\";\nimport { PoseidonT3 } from \"./PoseidonT3.sol\";\nimport { PoseidonT4 } from \"./PoseidonT4.sol\";\nimport { PoseidonT5 } from \"./PoseidonT5.sol\";\nimport { PoseidonT6 } from \"./PoseidonT6.sol\";\n\n/// @notice A SHA256 hash function for any number of input elements, and Poseidon hash\n/// functions for 2, 3, 4, 5, and 12 input elements.\ncontract Hasher is SnarkConstants {\n  /// @notice Computes the SHA256 hash of an array of uint256 elements.\n  /// @param array The array of uint256 elements.\n  /// @return result The SHA256 hash of the array.\n  function sha256Hash(uint256[] memory array) public pure returns (uint256 result) {\n    result = uint256(sha256(abi.encodePacked(array))) % SNARK_SCALAR_FIELD;\n  }\n\n  /// @notice Computes the Poseidon hash of two uint256 elements.\n  /// @param array An array of two uint256 elements.\n  /// @return result The Poseidon hash of the two elements.\n  function hash2(uint256[2] memory array) public pure returns (uint256 result) {\n    result = PoseidonT3.poseidon(array);\n  }\n\n  /// @notice Computes the Poseidon hash of three uint256 elements.\n  /// @param array An array of three uint256 elements.\n  /// @return result The Poseidon hash of the three elements.\n  function hash3(uint256[3] memory array) public pure returns (uint256 result) {\n    result = PoseidonT4.poseidon(array);\n  }\n\n  /// @notice Computes the Poseidon hash of four uint256 elements.\n  /// @param array An array of four uint256 elements.\n  /// @return result The Poseidon hash of the four elements.\n  function hash4(uint256[4] memory array) public pure returns (uint256 result) {\n    result = PoseidonT5.poseidon(array);\n  }\n\n  /// @notice Computes the Poseidon hash of five uint256 elements.\n  /// @param array An array of five uint256 elements.\n  /// @return result The Poseidon hash of the five elements.\n  function hash5(uint256[5] memory array) public pure returns (uint256 result) {\n    result = PoseidonT6.poseidon(array);\n  }\n\n  /// @notice Computes the Poseidon hash of two uint256 elements.\n  /// @param left the first element to hash.\n  /// @param right the second element to hash.\n  /// @return result The Poseidon hash of the two elements.\n  function hashLeftRight(uint256 left, uint256 right) public pure returns (uint256 result) {\n    uint256[2] memory input;\n    input[0] = left;\n    input[1] = right;\n    result = hash2(input);\n  }\n}\n"
    },
    "maci-contracts/contracts/crypto/Pairing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.10;\n\n/// @title Pairing\n/// @notice A library implementing the alt_bn128 elliptic curve operations.\nlibrary Pairing {\n  uint256 public constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  struct G1Point {\n    uint256 x;\n    uint256 y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n  }\n\n  /// @notice custom errors\n  error PairingAddFailed();\n  error PairingMulFailed();\n  error PairingOpcodeFailed();\n\n  /// @notice The negation of p, i.e. p.plus(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory) {\n    // The prime q in the base field F_q for G1\n    if (p.x == 0 && p.y == 0) {\n      return G1Point(0, 0);\n    } else {\n      return G1Point(p.x, PRIME_Q - (p.y % PRIME_Q));\n    }\n  }\n\n  /// @notice r Returns the sum of two points of G1.\n  function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    uint256[4] memory input;\n    input[0] = p1.x;\n    input[1] = p1.y;\n    input[2] = p2.x;\n    input[3] = p2.y;\n    bool success;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n      // Use \"invalid\" to make gas estimation work\n      switch success\n      case 0 {\n        invalid()\n      }\n    }\n\n    if (!success) {\n      revert PairingAddFailed();\n    }\n  }\n\n  /// @notice r Return the product of a point on G1 and a scalar, i.e.\n  ///         p == p.scalarMul(1) and p.plus(p) == p.scalarMul(2) for all\n  ///         points p.\n  function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    uint256[3] memory input;\n    input[0] = p.x;\n    input[1] = p.y;\n    input[2] = s;\n    bool success;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n      // Use \"invalid\" to make gas estimation work\n      switch success\n      case 0 {\n        invalid()\n      }\n    }\n\n    if (!success) {\n      revert PairingMulFailed();\n    }\n  }\n\n  /// @return isValid The result of computing the pairing check\n  ///         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  ///        For example,\n  ///        pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n  function pairing(\n    G1Point memory a1,\n    G2Point memory a2,\n    G1Point memory b1,\n    G2Point memory b2,\n    G1Point memory c1,\n    G2Point memory c2,\n    G1Point memory d1,\n    G2Point memory d2\n  ) internal view returns (bool isValid) {\n    G1Point[4] memory p1 = [a1, b1, c1, d1];\n    G2Point[4] memory p2 = [a2, b2, c2, d2];\n\n    uint256 inputSize = 24;\n    uint256[] memory input = new uint256[](inputSize);\n\n    for (uint256 i = 0; i < 4; i++) {\n      uint256 j = i * 6;\n      input[j + 0] = p1[i].x;\n      input[j + 1] = p1[i].y;\n      input[j + 2] = p2[i].x[0];\n      input[j + 3] = p2[i].x[1];\n      input[j + 4] = p2[i].y[0];\n      input[j + 5] = p2[i].y[1];\n    }\n\n    uint256[1] memory out;\n    bool success;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n      // Use \"invalid\" to make gas estimation work\n      switch success\n      case 0 {\n        invalid()\n      }\n    }\n\n    if (!success) {\n      revert PairingOpcodeFailed();\n    }\n\n    isValid = out[0] != 0;\n  }\n}\n"
    },
    "maci-contracts/contracts/crypto/PoseidonT3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @notice A library which provides functions for computing Pedersen hashes.\nlibrary PoseidonT3 {\n  // solhint-disable-next-line no-empty-blocks\n  function poseidon(uint256[2] memory input) public pure returns (uint256) {}\n}\n"
    },
    "maci-contracts/contracts/crypto/PoseidonT4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @notice A library which provides functions for computing Pedersen hashes.\nlibrary PoseidonT4 {\n  // solhint-disable-next-line no-empty-blocks\n  function poseidon(uint256[3] memory input) public pure returns (uint256) {}\n}\n"
    },
    "maci-contracts/contracts/crypto/PoseidonT5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @notice A library which provides functions for computing Pedersen hashes.\nlibrary PoseidonT5 {\n  // solhint-disable-next-line no-empty-blocks\n  function poseidon(uint256[4] memory input) public pure returns (uint256) {}\n}\n"
    },
    "maci-contracts/contracts/crypto/PoseidonT6.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @notice A library which provides functions for computing Pedersen hashes.\nlibrary PoseidonT6 {\n  // solhint-disable-next-line no-empty-blocks\n  function poseidon(uint256[5] memory input) public pure returns (uint256) {}\n}\n"
    },
    "maci-contracts/contracts/crypto/SnarkCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport { Pairing } from \"./Pairing.sol\";\n\n/// @title SnarkCommon\n/// @notice a Contract which holds a struct\n/// representing a Groth16 verifying key\ncontract SnarkCommon {\n  /// @notice a struct representing a Groth16 verifying key\n  struct VerifyingKey {\n    Pairing.G1Point alpha1;\n    Pairing.G2Point beta2;\n    Pairing.G2Point gamma2;\n    Pairing.G2Point delta2;\n    Pairing.G1Point[] ic;\n  }\n}\n"
    },
    "maci-contracts/contracts/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title SnarkConstants\n/// @notice This contract contains constants related to the SNARK\n/// components of MACI.\ncontract SnarkConstants {\n  /// @notice The scalar field\n  uint256 internal constant SNARK_SCALAR_FIELD =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  /// @notice The public key here is the first Pedersen base\n  /// point from iden3's circomlib implementation of the Pedersen hash.\n  /// Since it is generated using a hash-to-curve function, we are\n  /// confident that no-one knows the private key associated with this\n  /// public key. See:\n  /// https://github.com/iden3/circomlib/blob/d5ed1c3ce4ca137a6b3ca48bec4ac12c1b38957a/src/pedersen_printbases.js\n  /// Its hash should equal\n  /// 6769006970205099520508948723718471724660867171122235270773600567925038008762.\n  uint256 internal constant PAD_PUBKEY_X =\n    10457101036533406547632367118273992217979173478358440826365724437999023779287;\n  uint256 internal constant PAD_PUBKEY_Y =\n    19824078218392094440610104313265183977899662750282163392862422243483260492317;\n\n  /// @notice The Keccack256 hash of 'Maci'\n  uint256 internal constant NOTHING_UP_MY_SLEEVE =\n    8370432830353022751713833565135785980866757267633941821328460903436894336785;\n}\n"
    },
    "maci-contracts/contracts/crypto/Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Pairing } from \"./Pairing.sol\";\nimport { SnarkConstants } from \"./SnarkConstants.sol\";\nimport { SnarkCommon } from \"./SnarkCommon.sol\";\nimport { IVerifier } from \"../interfaces/IVerifier.sol\";\n\n/// @title Verifier\n/// @notice a Groth16 verifier contract\ncontract Verifier is IVerifier, SnarkConstants, SnarkCommon {\n  struct Proof {\n    Pairing.G1Point a;\n    Pairing.G2Point b;\n    Pairing.G1Point c;\n  }\n\n  using Pairing for *;\n\n  uint256 public constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  /// @notice custom errors\n  error InvalidProofQ();\n  error InvalidInputVal();\n\n  /// @notice Verify a zk-SNARK proof\n  /// @param _proof The proof\n  /// @param vk The verifying key\n  /// @param input The public inputs to the circuit\n  /// @return isValid Whether the proof is valid given the verifying key and public\n  ///          input. Note that this function only supports one public input.\n  ///          Refer to the Semaphore source code for a verifier that supports\n  ///          multiple public inputs.\n  function verify(\n    uint256[8] memory _proof,\n    VerifyingKey memory vk,\n    uint256 input\n  ) public view override returns (bool isValid) {\n    Proof memory proof;\n    proof.a = Pairing.G1Point(_proof[0], _proof[1]);\n    proof.b = Pairing.G2Point([_proof[2], _proof[3]], [_proof[4], _proof[5]]);\n    proof.c = Pairing.G1Point(_proof[6], _proof[7]);\n\n    // Make sure that proof.A, B, and C are each less than the prime q\n    checkPoint(proof.a.x);\n    checkPoint(proof.a.y);\n    checkPoint(proof.b.x[0]);\n    checkPoint(proof.b.y[0]);\n    checkPoint(proof.b.x[1]);\n    checkPoint(proof.b.y[1]);\n    checkPoint(proof.c.x);\n    checkPoint(proof.c.y);\n\n    // Make sure that the input is less than the snark scalar field\n    if (input >= SNARK_SCALAR_FIELD) {\n      revert InvalidInputVal();\n    }\n\n    // Compute the linear combination vk_x\n    Pairing.G1Point memory vkX = Pairing.G1Point(0, 0);\n\n    vkX = Pairing.plus(vkX, Pairing.scalarMul(vk.ic[1], input));\n\n    vkX = Pairing.plus(vkX, vk.ic[0]);\n\n    isValid = Pairing.pairing(\n      Pairing.negate(proof.a),\n      proof.b,\n      vk.alpha1,\n      vk.beta2,\n      vkX,\n      vk.gamma2,\n      proof.c,\n      vk.delta2\n    );\n  }\n\n  function checkPoint(uint256 point) internal pure {\n    if (point >= PRIME_Q) {\n      revert InvalidProofQ();\n    }\n  }\n}\n"
    },
    "maci-contracts/contracts/gatekeepers/SignUpGatekeeper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title SignUpGatekeeper\n/// @notice A gatekeeper contract which allows users to sign up for a poll.\nabstract contract SignUpGatekeeper {\n  /// @notice Allows to set the MACI contract\n  // solhint-disable-next-line no-empty-blocks\n  function setMaciInstance(address _maci) public virtual {}\n\n  /// @notice Registers the user\n  /// @param _user The address of the user\n  /// @param _data additional data\n  // solhint-disable-next-line no-empty-blocks\n  function register(address _user, bytes memory _data) public virtual {}\n}\n"
    },
    "maci-contracts/contracts/initialVoiceCreditProxy/InitialVoiceCreditProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title InitialVoiceCreditProxy\n/// @notice This contract is the base contract for\n/// InitialVoiceCreditProxy contracts. It allows to set a custom initial voice\n/// credit balance for MACI's voters.\nabstract contract InitialVoiceCreditProxy {\n  /// @notice Returns the initial voice credit balance for a new MACI's voter\n  /// @param _user the address of the voter\n  /// @param _data additional data\n  /// @return the balance\n  // solhint-disable-next-line no-empty-blocks\n  function getVoiceCredits(address _user, bytes memory _data) public view virtual returns (uint256) {}\n}\n"
    },
    "maci-contracts/contracts/interfaces/IMACI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { AccQueue } from \"../trees/AccQueue.sol\";\n\n/// @title IMACI\n/// @notice MACI interface\ninterface IMACI {\n  /// @notice Get the depth of the state tree\n  /// @return The depth of the state tree\n  function stateTreeDepth() external view returns (uint8);\n\n  /// @notice Return the main root of the StateAq contract\n  /// @return The Merkle root\n  function getStateAqRoot() external view returns (uint256);\n\n  /// @notice Allow Poll contracts to merge the state subroots\n  /// @param _numSrQueueOps Number of operations\n  /// @param _pollId The ID of the active Poll\n  function mergeStateAqSubRoots(uint256 _numSrQueueOps, uint256 _pollId) external;\n\n  /// @notice Allow Poll contracts to merge the state root\n  /// @param _pollId The active Poll ID\n  /// @return The calculated Merkle root\n  function mergeStateAq(uint256 _pollId) external returns (uint256);\n\n  /// @notice Get the number of signups\n  /// @return numsignUps The number of signups\n  function numSignUps() external view returns (uint256);\n\n  /// @notice Get the state AccQueue\n  /// @return The state AccQueue\n  function stateAq() external view returns (AccQueue);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title IMessageProcessor\n/// @notice MessageProcessor interface\ninterface IMessageProcessor {\n  /// @notice Get the result of whether there are unprocessed messages left\n  /// @return Whether there are unprocessed messages left\n  function processingComplete() external view returns (bool);\n\n  /// @notice Get the commitment to the state and ballot roots\n  /// @return The commitment to the state and ballot roots\n  function sbCommitment() external view returns (uint256);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IMPFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title IMessageProcessorFactory\n/// @notice MessageProcessorFactory interface\ninterface IMessageProcessorFactory {\n  /// @notice Deploy a new MessageProcessor contract and return the address.\n  /// @param _verifier Verifier contract\n  /// @param _vkRegistry VkRegistry contract\n  /// @param _poll Poll contract\n  /// @param _owner Owner of the MessageProcessor contract\n  /// @return The deployed MessageProcessor contract\n  function deploy(address _verifier, address _vkRegistry, address _poll, address _owner) external returns (address);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IPoll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { DomainObjs } from \"../utilities/DomainObjs.sol\";\nimport { IMACI } from \"./IMACI.sol\";\nimport { AccQueue } from \"../trees/AccQueue.sol\";\nimport { TopupCredit } from \"../TopupCredit.sol\";\n\n/// @title IPoll\n/// @notice Poll interface\ninterface IPoll {\n  /// @notice The number of messages which have been processed and the number of signups\n  /// @return numSignups The number of signups\n  /// @return numMsgs The number of messages sent by voters\n  function numSignUpsAndMessages() external view returns (uint256 numSignups, uint256 numMsgs);\n\n  /// @notice Allows to publish a Topup message\n  /// @param stateIndex The index of user in the state queue\n  /// @param amount The amount of credits to topup\n  function topup(uint256 stateIndex, uint256 amount) external;\n\n  /// @notice Allows anyone to publish a message (an encrypted command and signature).\n  /// This function also enqueues the message.\n  /// @param _message The message to publish\n  /// @param _encPubKey An epheremal public key which can be combined with the\n  /// coordinator's private key to generate an ECDH shared key with which\n  /// to encrypt the message.\n  function publishMessage(DomainObjs.Message memory _message, DomainObjs.PubKey calldata _encPubKey) external;\n\n  /// @notice The first step of merging the MACI state AccQueue. This allows the\n  /// ProcessMessages circuit to access the latest state tree and ballots via\n  /// currentSbCommitment.\n  /// @param _numSrQueueOps Number of operations\n  /// @param _pollId The ID of the active Poll\n  function mergeMaciStateAqSubRoots(uint256 _numSrQueueOps, uint256 _pollId) external;\n\n  /// @notice The second step of merging the MACI state AccQueue. This allows the\n  /// ProcessMessages circuit to access the latest state tree and ballots via\n  /// currentSbCommitment.\n  /// @param _pollId The ID of the active Poll\n  function mergeMaciStateAq(uint256 _pollId) external;\n\n  /// @notice The first step in merging the message AccQueue so that the\n  /// ProcessMessages circuit can access the message root.\n  /// @param _numSrQueueOps The number of subroot queue operations to perform\n  function mergeMessageAqSubRoots(uint256 _numSrQueueOps) external;\n\n  /// @notice The second step in merging the message AccQueue so that the\n  /// ProcessMessages circuit can access the message root.\n  function mergeMessageAq() external;\n\n  /// @notice Returns the Poll's deploy time and duration\n  /// @return _deployTime The deployment timestamp\n  /// @return _duration The duration of the poll\n  function getDeployTimeAndDuration() external view returns (uint256 _deployTime, uint256 _duration);\n\n  /// @notice Get the result of whether the MACI contract's stateAq has been merged by this contract\n  /// @return Whether the MACI contract's stateAq has been merged by this contract\n  function stateAqMerged() external view returns (bool);\n\n  /// @notice Get the depths of the merkle trees\n  /// @return intStateTreeDepth The depth of the state tree\n  /// @return messageTreeSubDepth The subdepth of the message tree\n  /// @return messageTreeDepth The depth of the message tree\n  /// @return voteOptionTreeDepth The subdepth of the vote option tree\n  function treeDepths()\n    external\n    view\n    returns (uint8 intStateTreeDepth, uint8 messageTreeSubDepth, uint8 messageTreeDepth, uint8 voteOptionTreeDepth);\n\n  /// @notice Get the max values for the poll\n  /// @return maxMessages The maximum number of messages\n  /// @return maxVoteOptions The maximum number of vote options\n  function maxValues() external view returns (uint256 maxMessages, uint256 maxVoteOptions);\n\n  /// @notice Get the external contracts\n  /// @return maci The IMACI contract\n  /// @return messageAq The AccQueue contract\n  /// @return topupCredit The TopupCredit contract\n  function extContracts() external view returns (IMACI maci, AccQueue messageAq, TopupCredit topupCredit);\n\n  /// @notice Get the hash of coordinator's public key\n  /// @return _coordinatorPubKeyHash the hash of coordinator's public key\n  function coordinatorPubKeyHash() external view returns (uint256 _coordinatorPubKeyHash);\n\n  /// @notice Get the commitment to the state leaves and the ballots. This is\n  /// hash3(stateRoot, ballotRoot, salt).\n  /// Its initial value should be\n  /// hash(maciStateRootSnapshot, emptyBallotRoot, 0)\n  /// Each successful invocation of processMessages() should use a different\n  /// salt to update this value, so that an external observer cannot tell in\n  /// the case that none of the messages are valid.\n  /// @return The commitment to the state leaves and the ballots\n  function currentSbCommitment() external view returns (uint256);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IPollFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { TopupCredit } from \"../TopupCredit.sol\";\nimport { Params } from \"../utilities/Params.sol\";\nimport { DomainObjs } from \"../utilities/DomainObjs.sol\";\n\n/// @title IPollFactory\n/// @notice PollFactory interface\ninterface IPollFactory {\n  /// @notice Deploy a new Poll contract and AccQueue contract for messages.\n  /// @param _duration The duration of the poll\n  /// @param _maxValues The max values for the poll\n  /// @param _treeDepths The depths of the merkle trees\n  /// @param _coordinatorPubKey The coordinator's public key\n  /// @param _maci The MACI contract interface reference\n  /// @param _topupCredit The TopupCredit contract\n  /// @param _pollOwner The owner of the poll\n  /// @return The deployed Poll contract\n  function deploy(\n    uint256 _duration,\n    Params.MaxValues memory _maxValues,\n    Params.TreeDepths memory _treeDepths,\n    DomainObjs.PubKey memory _coordinatorPubKey,\n    address _maci,\n    TopupCredit _topupCredit,\n    address _pollOwner\n  ) external returns (address);\n}\n"
    },
    "maci-contracts/contracts/interfaces/ITallySubsidyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title ITallySubsidyFactory\n/// @notice TallySubsidyFactory interface\ninterface ITallySubsidyFactory {\n  /// @notice Deploy a new Tally or Subsidy contract and return the address.\n  /// @param _verifier Verifier contract\n  /// @param _vkRegistry VkRegistry contract\n  /// @param _poll Poll contract\n  /// @param _messageProcessor MessageProcessor contract\n  /// @param _owner Owner of the contract\n  /// @return The deployed contract\n  function deploy(\n    address _verifier,\n    address _vkRegistry,\n    address _poll,\n    address _messageProcessor,\n    address _owner\n  ) external returns (address);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { SnarkCommon } from \"../crypto/SnarkCommon.sol\";\n\n/// @title IVerifier\n/// @notice an interface for a Groth16 verifier contract\ninterface IVerifier {\n  /// @notice Verify a zk-SNARK proof\n  /// @param _proof The proof\n  /// @param vk The verifying key\n  /// @param input The public inputs to the circuit\n  /// @return Whether the proof is valid given the verifying key and public\n  ///          input. Note that this function only supports one public input.\n  ///          Refer to the Semaphore source code for a verifier that supports\n  ///          multiple public inputs.\n  function verify(\n    uint256[8] memory _proof,\n    SnarkCommon.VerifyingKey memory vk,\n    uint256 input\n  ) external view returns (bool);\n}\n"
    },
    "maci-contracts/contracts/interfaces/IVkRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { SnarkCommon } from \"../crypto/SnarkCommon.sol\";\n\n/// @title IVkRegistry\n/// @notice VkRegistry interface\ninterface IVkRegistry {\n  /// @notice Get the tally verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return The verifying key\n  function getTallyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) external view returns (SnarkCommon.VerifyingKey memory);\n\n  /// @notice Get the process verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _messageTreeDepth The message tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @param _messageBatchSize The message batch size\n  /// @return The verifying key\n  function getProcessVk(\n    uint256 _stateTreeDepth,\n    uint256 _messageTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    uint256 _messageBatchSize\n  ) external view returns (SnarkCommon.VerifyingKey memory);\n\n  /// @notice Get the subsidy verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return The verifying key\n  function getSubsidyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) external view returns (SnarkCommon.VerifyingKey memory);\n}\n"
    },
    "maci-contracts/contracts/MACI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IPollFactory } from \"./interfaces/IPollFactory.sol\";\nimport { IMessageProcessorFactory } from \"./interfaces/IMPFactory.sol\";\nimport { ITallySubsidyFactory } from \"./interfaces/ITallySubsidyFactory.sol\";\nimport { InitialVoiceCreditProxy } from \"./initialVoiceCreditProxy/InitialVoiceCreditProxy.sol\";\nimport { SignUpGatekeeper } from \"./gatekeepers/SignUpGatekeeper.sol\";\nimport { AccQueue } from \"./trees/AccQueue.sol\";\nimport { AccQueueQuinaryBlankSl } from \"./trees/AccQueueQuinaryBlankSl.sol\";\nimport { IMACI } from \"./interfaces/IMACI.sol\";\nimport { Params } from \"./utilities/Params.sol\";\nimport { TopupCredit } from \"./TopupCredit.sol\";\nimport { Utilities } from \"./utilities/Utilities.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title MACI - Minimum Anti-Collusion Infrastructure Version 1\n/// @notice A contract which allows users to sign up, and deploy new polls\ncontract MACI is IMACI, Params, Utilities, Ownable {\n  /// @notice The state tree depth is fixed. As such it should be as large as feasible\n  /// so that there can be as many users as possible.  i.e. 5 ** 10 = 9765625\n  /// this should also match the parameter of the circom circuits.\n  uint8 public immutable stateTreeDepth;\n\n  /// @notice IMPORTANT: remember to change the ballot tree depth\n  /// in contracts/ts/genEmptyBallotRootsContract.ts file\n  /// if we change the state tree depth!\n  uint8 internal constant STATE_TREE_SUBDEPTH = 2;\n  uint8 internal constant TREE_ARITY = 5;\n\n  /// @notice The hash of a blank state leaf\n  uint256 internal constant BLANK_STATE_LEAF_HASH =\n    uint256(6769006970205099520508948723718471724660867171122235270773600567925038008762);\n\n  /// @notice Each poll has an incrementing ID\n  uint256 public nextPollId;\n\n  /// @notice A mapping of poll IDs to Poll contracts.\n  mapping(uint256 => address) public polls;\n\n  /// @notice Whether the subtrees have been merged (can merge root before new signup)\n  bool public subtreesMerged;\n\n  /// @notice The number of signups\n  uint256 public numSignUps;\n\n  /// @notice ERC20 contract that hold topup credits\n  TopupCredit public immutable topupCredit;\n\n  /// @notice Factory contract that deploy a Poll contract\n  IPollFactory public immutable pollFactory;\n\n  /// @notice Factory contract that deploy a MessageProcessor contract\n  IMessageProcessorFactory public immutable messageProcessorFactory;\n\n  /// @notice Factory contract that deploy a Tally contract\n  ITallySubsidyFactory public immutable tallyFactory;\n\n  /// @notice Factory contract that deploy a Subsidy contract\n  ITallySubsidyFactory public immutable subsidyFactory;\n\n  /// @notice The state AccQueue. Represents a mapping between each user's public key\n  /// and their voice credit balance.\n  AccQueue public immutable stateAq;\n\n  /// @notice Address of the SignUpGatekeeper, a contract which determines whether a\n  /// user may sign up to vote\n  SignUpGatekeeper public immutable signUpGatekeeper;\n\n  /// @notice The contract which provides the values of the initial voice credit\n  /// balance per user\n  InitialVoiceCreditProxy public immutable initialVoiceCreditProxy;\n\n  /// @notice A struct holding the addresses of poll, mp and tally\n  struct PollContracts {\n    address poll;\n    address messageProcessor;\n    address tally;\n    address subsidy;\n  }\n\n  // Events\n  event SignUp(\n    uint256 _stateIndex,\n    uint256 indexed _userPubKeyX,\n    uint256 indexed _userPubKeyY,\n    uint256 _voiceCreditBalance,\n    uint256 _timestamp\n  );\n  event DeployPoll(\n    uint256 _pollId,\n    uint256 indexed _coordinatorPubKeyX,\n    uint256 indexed _coordinatorPubKeyY,\n    PollContracts pollAddr\n  );\n\n  /// @notice Only allow a Poll contract to call the modified function.\n  modifier onlyPoll(uint256 _pollId) {\n    if (msg.sender != address(polls[_pollId])) revert CallerMustBePoll(msg.sender);\n    _;\n  }\n\n  /// @notice custom errors\n  error CallerMustBePoll(address _caller);\n  error PoseidonHashLibrariesNotLinked();\n  error TooManySignups();\n  error MaciPubKeyLargerThanSnarkFieldSize();\n  error PreviousPollNotCompleted(uint256 pollId);\n  error PollDoesNotExist(uint256 pollId);\n  error SignupTemporaryBlocked();\n\n  /// @notice Create a new instance of the MACI contract.\n  /// @param _pollFactory The PollFactory contract\n  /// @param _messageProcessorFactory The MessageProcessorFactory contract\n  /// @param _tallyFactory The TallyFactory contract\n  /// @param _subsidyFactory The SubsidyFactory contract\n  /// @param _signUpGatekeeper The SignUpGatekeeper contract\n  /// @param _initialVoiceCreditProxy The InitialVoiceCreditProxy contract\n  /// @param _topupCredit The TopupCredit contract\n  /// @param _stateTreeDepth The depth of the state tree\n  constructor(\n    IPollFactory _pollFactory,\n    IMessageProcessorFactory _messageProcessorFactory,\n    ITallySubsidyFactory _tallyFactory,\n    ITallySubsidyFactory _subsidyFactory,\n    SignUpGatekeeper _signUpGatekeeper,\n    InitialVoiceCreditProxy _initialVoiceCreditProxy,\n    TopupCredit _topupCredit,\n    uint8 _stateTreeDepth\n  ) payable {\n    // Deploy the state AccQueue\n    stateAq = new AccQueueQuinaryBlankSl(STATE_TREE_SUBDEPTH);\n    stateAq.enqueue(BLANK_STATE_LEAF_HASH);\n\n    // because we add a blank leaf we need to count one signup\n    // so we don't allow max + 1\n    unchecked {\n      numSignUps++;\n    }\n\n    pollFactory = _pollFactory;\n    messageProcessorFactory = _messageProcessorFactory;\n    tallyFactory = _tallyFactory;\n    subsidyFactory = _subsidyFactory;\n    topupCredit = _topupCredit;\n    signUpGatekeeper = _signUpGatekeeper;\n    initialVoiceCreditProxy = _initialVoiceCreditProxy;\n    stateTreeDepth = _stateTreeDepth;\n\n    // Verify linked poseidon libraries\n    if (hash2([uint256(1), uint256(1)]) == 0) revert PoseidonHashLibrariesNotLinked();\n  }\n\n  /// @notice Allows any eligible user sign up. The sign-up gatekeeper should prevent\n  /// double sign-ups or ineligible users from doing so.  This function will\n  /// only succeed if the sign-up deadline has not passed. It also enqueues a\n  /// fresh state leaf into the state AccQueue.\n  /// @param _pubKey The user's desired public key.\n  /// @param _signUpGatekeeperData Data to pass to the sign-up gatekeeper's\n  ///     register() function. For instance, the POAPGatekeeper or\n  ///     SignUpTokenGatekeeper requires this value to be the ABI-encoded\n  ///     token ID.\n  /// @param _initialVoiceCreditProxyData Data to pass to the\n  ///     InitialVoiceCreditProxy, which allows it to determine how many voice\n  ///     credits this user should have.\n  function signUp(\n    PubKey memory _pubKey,\n    bytes memory _signUpGatekeeperData,\n    bytes memory _initialVoiceCreditProxyData\n  ) public virtual {\n    // prevent new signups until we merge the roots (possible DoS)\n    if (subtreesMerged) revert SignupTemporaryBlocked();\n\n    // ensure we do not have more signups than what the circuits support\n    if (numSignUps >= uint256(TREE_ARITY) ** uint256(stateTreeDepth)) revert TooManySignups();\n\n    if (_pubKey.x >= SNARK_SCALAR_FIELD || _pubKey.y >= SNARK_SCALAR_FIELD) {\n      revert MaciPubKeyLargerThanSnarkFieldSize();\n    }\n\n    // Increment the number of signups\n    // cannot overflow with realistic STATE_TREE_DEPTH\n    // values as numSignUps < 5 ** STATE_TREE_DEPTH -1\n    unchecked {\n      numSignUps++;\n    }\n\n    // Register the user via the sign-up gatekeeper. This function should\n    // throw if the user has already registered or if ineligible to do so.\n    signUpGatekeeper.register(msg.sender, _signUpGatekeeperData);\n\n    // Get the user's voice credit balance.\n    uint256 voiceCreditBalance = initialVoiceCreditProxy.getVoiceCredits(msg.sender, _initialVoiceCreditProxyData);\n\n    uint256 timestamp = block.timestamp;\n    // Create a state leaf and enqueue it.\n    uint256 stateLeaf = hashStateLeaf(StateLeaf(_pubKey, voiceCreditBalance, timestamp));\n    uint256 stateIndex = stateAq.enqueue(stateLeaf);\n\n    emit SignUp(stateIndex, _pubKey.x, _pubKey.y, voiceCreditBalance, timestamp);\n  }\n\n  /// @notice Deploy a new Poll contract.\n  /// @param _duration How long should the Poll last for\n  /// @param _treeDepths The depth of the Merkle trees\n  /// @param _coordinatorPubKey The coordinator's public key\n  /// @param _verifier The Verifier Contract\n  /// @param _vkRegistry The VkRegistry Contract\n  /// @param useSubsidy If true, the Poll will use the Subsidy contract\n  /// @return pollAddr a new Poll contract address\n  function deployPoll(\n    uint256 _duration,\n    TreeDepths memory _treeDepths,\n    PubKey memory _coordinatorPubKey,\n    address _verifier,\n    address _vkRegistry,\n    bool useSubsidy\n  ) public virtual onlyOwner returns (PollContracts memory pollAddr) {\n    // cache the poll to a local variable so we can increment it\n    uint256 pollId = nextPollId;\n\n    // Increment the poll ID for the next poll\n    // 2 ** 256 polls available\n    unchecked {\n      nextPollId++;\n    }\n\n    if (pollId > 0) {\n      if (!stateAq.treeMerged()) revert PreviousPollNotCompleted(pollId);\n    }\n\n    MaxValues memory maxValues = MaxValues({\n      maxMessages: uint256(TREE_ARITY) ** _treeDepths.messageTreeDepth,\n      maxVoteOptions: uint256(TREE_ARITY) ** _treeDepths.voteOptionTreeDepth\n    });\n\n    address _owner = owner();\n\n    address p = pollFactory.deploy(\n      _duration,\n      maxValues,\n      _treeDepths,\n      _coordinatorPubKey,\n      address(this),\n      topupCredit,\n      _owner\n    );\n\n    address mp = messageProcessorFactory.deploy(_verifier, _vkRegistry, p, _owner);\n    address tally = tallyFactory.deploy(_verifier, _vkRegistry, p, mp, _owner);\n\n    address subsidy;\n    if (useSubsidy) {\n      subsidy = subsidyFactory.deploy(_verifier, _vkRegistry, p, mp, _owner);\n    }\n\n    polls[pollId] = p;\n\n    // store the addresses in a struct so they can be returned\n    pollAddr = PollContracts({ poll: p, messageProcessor: mp, tally: tally, subsidy: subsidy });\n\n    emit DeployPoll(pollId, _coordinatorPubKey.x, _coordinatorPubKey.y, pollAddr);\n  }\n\n  /// @inheritdoc IMACI\n  function mergeStateAqSubRoots(uint256 _numSrQueueOps, uint256 _pollId) public onlyPoll(_pollId) {\n    stateAq.mergeSubRoots(_numSrQueueOps);\n\n    // if we have merged all subtrees then put a block\n    if (stateAq.subTreesMerged()) {\n      subtreesMerged = true;\n    }\n  }\n\n  /// @inheritdoc IMACI\n  function mergeStateAq(uint256 _pollId) public onlyPoll(_pollId) returns (uint256 root) {\n    // remove block\n    subtreesMerged = false;\n\n    root = stateAq.merge(stateTreeDepth);\n  }\n\n  /// @inheritdoc IMACI\n  function getStateAqRoot() public view returns (uint256 root) {\n    root = stateAq.getMainRoot(stateTreeDepth);\n  }\n\n  /// @notice Get the Poll details\n  /// @param _pollId The identifier of the Poll to retrieve\n  /// @return poll The Poll contract object\n  function getPoll(uint256 _pollId) public view returns (address poll) {\n    if (_pollId >= nextPollId) revert PollDoesNotExist(_pollId);\n    poll = polls[_pollId];\n  }\n}\n"
    },
    "maci-contracts/contracts/Poll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Params } from \"./utilities/Params.sol\";\nimport { SnarkCommon } from \"./crypto/SnarkCommon.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { EmptyBallotRoots } from \"./trees/EmptyBallotRoots.sol\";\nimport { IPoll } from \"./interfaces/IPoll.sol\";\nimport { Utilities } from \"./utilities/Utilities.sol\";\n\n/// @title Poll\n/// @notice A Poll contract allows voters to submit encrypted messages\n/// which can be either votes, key change messages or topup messages.\n/// @dev Do not deploy this directly. Use PollFactory.deploy() which performs some\n/// checks on the Poll constructor arguments.\ncontract Poll is Params, Utilities, SnarkCommon, Ownable, EmptyBallotRoots, IPoll {\n  using SafeERC20 for ERC20;\n\n  /// @notice Whether the Poll has been initialized\n  bool internal isInit;\n\n  /// @notice The coordinator's public key\n  PubKey public coordinatorPubKey;\n\n  /// @notice Hash of the coordinator's public key\n  uint256 public immutable coordinatorPubKeyHash;\n\n  /// @notice the state root of the state merkle tree\n  uint256 public mergedStateRoot;\n\n  // The timestamp of the block at which the Poll was deployed\n  uint256 internal immutable deployTime;\n\n  // The duration of the polling period, in seconds\n  uint256 internal immutable duration;\n\n  /// @notice Whether the MACI contract's stateAq has been merged by this contract\n  bool public stateAqMerged;\n\n  /// @notice Get the commitment to the state leaves and the ballots. This is\n  /// hash3(stateRoot, ballotRoot, salt).\n  /// Its initial value should be\n  /// hash(maciStateRootSnapshot, emptyBallotRoot, 0)\n  /// Each successful invocation of processMessages() should use a different\n  /// salt to update this value, so that an external observer cannot tell in\n  /// the case that none of the messages are valid.\n  uint256 public currentSbCommitment;\n\n  /// @notice The number of messages that have been published\n  uint256 public numMessages;\n\n  /// @notice The number of signups that have been processed\n  /// before the Poll ended (stateAq merged)\n  uint256 public numSignups;\n\n  /// @notice Max values for the poll\n  MaxValues public maxValues;\n\n  /// @notice Depths of the merkle trees\n  TreeDepths public treeDepths;\n\n  /// @notice The contracts used by the Poll\n  ExtContracts public extContracts;\n\n  error VotingPeriodOver();\n  error VotingPeriodNotOver();\n  error PollAlreadyInit();\n  error TooManyMessages();\n  error MaciPubKeyLargerThanSnarkFieldSize();\n  error StateAqAlreadyMerged();\n  error StateAqSubtreesNeedMerge();\n  error InvalidBatchLength();\n\n  event PublishMessage(Message _message, PubKey _encPubKey);\n  event TopupMessage(Message _message);\n  event MergeMaciStateAqSubRoots(uint256 _numSrQueueOps);\n  event MergeMaciStateAq(uint256 _stateRoot, uint256 _numSignups);\n  event MergeMessageAqSubRoots(uint256 _numSrQueueOps);\n  event MergeMessageAq(uint256 _messageRoot);\n\n  /// @notice Each MACI instance can have multiple Polls.\n  /// When a Poll is deployed, its voting period starts immediately.\n  /// @param _duration The duration of the voting period, in seconds\n  /// @param _maxValues The maximum number of messages and vote options\n  /// @param _treeDepths The depths of the merkle trees\n  /// @param _coordinatorPubKey The coordinator's public key\n  /// @param _extContracts The external contracts\n  constructor(\n    uint256 _duration,\n    MaxValues memory _maxValues,\n    TreeDepths memory _treeDepths,\n    PubKey memory _coordinatorPubKey,\n    ExtContracts memory _extContracts\n  ) payable {\n    // check that the coordinator public key is valid\n    if (_coordinatorPubKey.x >= SNARK_SCALAR_FIELD || _coordinatorPubKey.y >= SNARK_SCALAR_FIELD) {\n      revert MaciPubKeyLargerThanSnarkFieldSize();\n    }\n\n    // store the pub key as object then calculate the hash\n    coordinatorPubKey = _coordinatorPubKey;\n    // we hash it ourselves to ensure we store the correct value\n    coordinatorPubKeyHash = hashLeftRight(_coordinatorPubKey.x, _coordinatorPubKey.y);\n    // store the external contracts to interact with\n    extContracts = _extContracts;\n    // store duration of the poll\n    duration = _duration;\n    // store max values\n    maxValues = _maxValues;\n    // store tree depth\n    treeDepths = _treeDepths;\n    // Record the current timestamp\n    deployTime = block.timestamp;\n  }\n\n  /// @notice A modifier that causes the function to revert if the voting period is\n  /// not over.\n  modifier isAfterVotingDeadline() {\n    uint256 secondsPassed = block.timestamp - deployTime;\n    if (secondsPassed <= duration) revert VotingPeriodNotOver();\n    _;\n  }\n\n  /// @notice A modifier that causes the function to revert if the voting period is\n  /// over\n  modifier isWithinVotingDeadline() {\n    uint256 secondsPassed = block.timestamp - deployTime;\n    if (secondsPassed >= duration) revert VotingPeriodOver();\n    _;\n  }\n\n  /// @notice The initialization function.\n  /// @dev Should be called immediately after Poll creation\n  /// and messageAq ownership transferred\n  function init() public {\n    if (isInit) revert PollAlreadyInit();\n    // set to true so it cannot be called again\n    isInit = true;\n\n    unchecked {\n      numMessages++;\n    }\n\n    // init messageAq here by inserting placeholderLeaf\n    uint256[2] memory dat = [NOTHING_UP_MY_SLEEVE, 0];\n\n    (Message memory _message, PubKey memory _padKey, uint256 placeholderLeaf) = padAndHashMessage(dat, 1);\n    extContracts.messageAq.enqueue(placeholderLeaf);\n\n    emit PublishMessage(_message, _padKey);\n  }\n\n  /// @inheritdoc IPoll\n  function topup(uint256 stateIndex, uint256 amount) public virtual isWithinVotingDeadline {\n    // we check that we do not exceed the max number of messages\n    if (numMessages >= maxValues.maxMessages) revert TooManyMessages();\n\n    // cannot realistically overflow\n    unchecked {\n      numMessages++;\n    }\n\n    /// @notice topupCredit is a trusted token contract which reverts if the transfer fails\n    extContracts.topupCredit.transferFrom(msg.sender, address(this), amount);\n\n    uint256[2] memory dat = [stateIndex, amount];\n    (Message memory _message, , uint256 messageLeaf) = padAndHashMessage(dat, 2);\n\n    extContracts.messageAq.enqueue(messageLeaf);\n\n    emit TopupMessage(_message);\n  }\n\n  /// @inheritdoc IPoll\n  function publishMessage(Message memory _message, PubKey calldata _encPubKey) public virtual isWithinVotingDeadline {\n    // we check that we do not exceed the max number of messages\n    if (numMessages >= maxValues.maxMessages) revert TooManyMessages();\n\n    // validate that the public key is valid\n    if (_encPubKey.x >= SNARK_SCALAR_FIELD || _encPubKey.y >= SNARK_SCALAR_FIELD) {\n      revert MaciPubKeyLargerThanSnarkFieldSize();\n    }\n\n    // cannot realistically overflow\n    unchecked {\n      numMessages++;\n    }\n\n    // we enforce that msgType here is 1 so we don't need checks\n    // at the circuit level\n    _message.msgType = 1;\n\n    uint256 messageLeaf = hashMessageAndEncPubKey(_message, _encPubKey);\n    extContracts.messageAq.enqueue(messageLeaf);\n\n    emit PublishMessage(_message, _encPubKey);\n  }\n\n  /// @notice submit a message batch\n  /// @dev Can only be submitted before the voting deadline\n  /// @param _messages the messages\n  /// @param _encPubKeys the encrypted public keys\n  function publishMessageBatch(Message[] calldata _messages, PubKey[] calldata _encPubKeys) external {\n    if (_messages.length != _encPubKeys.length) {\n      revert InvalidBatchLength();\n    }\n\n    uint256 len = _messages.length;\n    for (uint256 i = 0; i < len; ) {\n      // an event will be published by this function already\n      publishMessage(_messages[i], _encPubKeys[i]);\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IPoll\n  function mergeMaciStateAqSubRoots(uint256 _numSrQueueOps, uint256 _pollId) public onlyOwner isAfterVotingDeadline {\n    // This function cannot be called after the stateAq was merged\n    if (stateAqMerged) revert StateAqAlreadyMerged();\n\n    // merge subroots\n    extContracts.maci.mergeStateAqSubRoots(_numSrQueueOps, _pollId);\n\n    emit MergeMaciStateAqSubRoots(_numSrQueueOps);\n  }\n\n  /// @inheritdoc IPoll\n  function mergeMaciStateAq(uint256 _pollId) public onlyOwner isAfterVotingDeadline {\n    // This function can only be called once per Poll after the voting\n    // deadline\n    if (stateAqMerged) revert StateAqAlreadyMerged();\n\n    // set merged to true so it cannot be called again\n    stateAqMerged = true;\n\n    // the subtrees must have been merged first\n    if (!extContracts.maci.stateAq().subTreesMerged()) revert StateAqSubtreesNeedMerge();\n\n    mergedStateRoot = extContracts.maci.mergeStateAq(_pollId);\n\n    // Set currentSbCommitment\n    uint256[3] memory sb;\n    sb[0] = mergedStateRoot;\n    sb[1] = emptyBallotRoots[treeDepths.voteOptionTreeDepth - 1];\n    sb[2] = uint256(0);\n\n    currentSbCommitment = hash3(sb);\n\n    numSignups = extContracts.maci.numSignUps();\n    emit MergeMaciStateAq(mergedStateRoot, numSignups);\n  }\n\n  /// @inheritdoc IPoll\n  function mergeMessageAqSubRoots(uint256 _numSrQueueOps) public onlyOwner isAfterVotingDeadline {\n    extContracts.messageAq.mergeSubRoots(_numSrQueueOps);\n    emit MergeMessageAqSubRoots(_numSrQueueOps);\n  }\n\n  /// @inheritdoc IPoll\n  function mergeMessageAq() public onlyOwner isAfterVotingDeadline {\n    uint256 root = extContracts.messageAq.merge(treeDepths.messageTreeDepth);\n    emit MergeMessageAq(root);\n  }\n\n  /// @inheritdoc IPoll\n  function getDeployTimeAndDuration() public view returns (uint256 pollDeployTime, uint256 pollDuration) {\n    pollDeployTime = deployTime;\n    pollDuration = duration;\n  }\n\n  /// @inheritdoc IPoll\n  function numSignUpsAndMessages() public view returns (uint256 numSUps, uint256 numMsgs) {\n    numSUps = numSignups;\n    numMsgs = numMessages;\n  }\n}\n"
    },
    "maci-contracts/contracts/Tally.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IMACI } from \"./interfaces/IMACI.sol\";\nimport { Hasher } from \"./crypto/Hasher.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPoll } from \"./interfaces/IPoll.sol\";\nimport { IMessageProcessor } from \"./interfaces/IMessageProcessor.sol\";\nimport { SnarkCommon } from \"./crypto/SnarkCommon.sol\";\nimport { IVerifier } from \"./interfaces/IVerifier.sol\";\nimport { IVkRegistry } from \"./interfaces/IVkRegistry.sol\";\nimport { CommonUtilities } from \"./utilities/CommonUtilities.sol\";\n\n/// @title Tally\n/// @notice The Tally contract is used during votes tallying\n/// and by users to verify the tally results.\ncontract Tally is Ownable, SnarkCommon, CommonUtilities, Hasher {\n  uint256 internal constant TREE_ARITY = 5;\n\n  /// @notice The commitment to the tally results. Its initial value is 0, but after\n  /// the tally of each batch is proven on-chain via a zk-SNARK, it should be\n  /// updated to:\n  ///\n  /// hash3(\n  ///   hashLeftRight(merkle root of current results, salt0)\n  ///   hashLeftRight(number of spent voice credits, salt1),\n  ///   hashLeftRight(merkle root of the no. of spent voice credits per vote option, salt2)\n  /// )\n  ///\n  /// Where each salt is unique and the merkle roots are of arrays of leaves\n  /// TREE_ARITY ** voteOptionTreeDepth long.\n  uint256 public tallyCommitment;\n\n  uint256 public tallyBatchNum;\n\n  // The final commitment to the state and ballot roots\n  uint256 public sbCommitment;\n\n  IVerifier public immutable verifier;\n  IVkRegistry public immutable vkRegistry;\n  IPoll public immutable poll;\n  IMessageProcessor public immutable messageProcessor;\n\n  /// @notice custom errors\n  error ProcessingNotComplete();\n  error InvalidTallyVotesProof();\n  error AllBallotsTallied();\n  error NumSignUpsTooLarge();\n  error BatchStartIndexTooLarge();\n  error TallyBatchSizeTooLarge();\n\n  /// @notice Create a new Tally contract\n  /// @param _verifier The Verifier contract\n  /// @param _vkRegistry The VkRegistry contract\n  /// @param _poll The Poll contract\n  /// @param _mp The MessageProcessor contract\n  constructor(address _verifier, address _vkRegistry, address _poll, address _mp) payable {\n    verifier = IVerifier(_verifier);\n    vkRegistry = IVkRegistry(_vkRegistry);\n    poll = IPoll(_poll);\n    messageProcessor = IMessageProcessor(_mp);\n  }\n\n  /// @notice Pack the batch start index and number of signups into a 100-bit value.\n  /// @param _numSignUps: number of signups\n  /// @param _batchStartIndex: the start index of given batch\n  /// @param _tallyBatchSize: size of batch\n  /// @return result an uint256 representing the 3 inputs packed together\n  function genTallyVotesPackedVals(\n    uint256 _numSignUps,\n    uint256 _batchStartIndex,\n    uint256 _tallyBatchSize\n  ) public pure returns (uint256 result) {\n    if (_numSignUps >= 2 ** 50) revert NumSignUpsTooLarge();\n    if (_batchStartIndex >= 2 ** 50) revert BatchStartIndexTooLarge();\n    if (_tallyBatchSize >= 2 ** 50) revert TallyBatchSizeTooLarge();\n\n    result = (_batchStartIndex / _tallyBatchSize) + (_numSignUps << uint256(50));\n  }\n\n  /// @notice Check if all ballots are tallied\n  /// @return tallied whether all ballots are tallied\n  function isTallied() public view returns (bool tallied) {\n    (uint8 intStateTreeDepth, , , ) = poll.treeDepths();\n    (uint256 numSignUps, ) = poll.numSignUpsAndMessages();\n\n    // Require that there are untallied ballots left\n    tallied = tallyBatchNum * (TREE_ARITY ** intStateTreeDepth) >= numSignUps;\n  }\n\n  /// @notice generate hash of public inputs for tally circuit\n  /// @param _numSignUps: number of signups\n  /// @param _batchStartIndex: the start index of given batch\n  /// @param _tallyBatchSize: size of batch\n  /// @param _newTallyCommitment: the new tally commitment to be updated\n  /// @return inputHash hash of public inputs\n  function genTallyVotesPublicInputHash(\n    uint256 _numSignUps,\n    uint256 _batchStartIndex,\n    uint256 _tallyBatchSize,\n    uint256 _newTallyCommitment\n  ) public view returns (uint256 inputHash) {\n    uint256 packedVals = genTallyVotesPackedVals(_numSignUps, _batchStartIndex, _tallyBatchSize);\n    uint256[] memory input = new uint256[](4);\n    input[0] = packedVals;\n    input[1] = sbCommitment;\n    input[2] = tallyCommitment;\n    input[3] = _newTallyCommitment;\n    inputHash = sha256Hash(input);\n  }\n\n  /// @notice Update the state and ballot root commitment\n  function updateSbCommitment() public onlyOwner {\n    // Require that all messages have been processed\n    if (!messageProcessor.processingComplete()) {\n      revert ProcessingNotComplete();\n    }\n\n    if (sbCommitment == 0) {\n      sbCommitment = messageProcessor.sbCommitment();\n    }\n  }\n\n  /// @notice Verify the result of a tally batch\n  /// @param _newTallyCommitment the new tally commitment to be verified\n  /// @param _proof the proof generated after tallying this batch\n  function tallyVotes(uint256 _newTallyCommitment, uint256[8] calldata _proof) public onlyOwner {\n    _votingPeriodOver(poll);\n    updateSbCommitment();\n\n    // get the batch size and start index\n    (uint8 intStateTreeDepth, , , ) = poll.treeDepths();\n    uint256 tallyBatchSize = TREE_ARITY ** intStateTreeDepth;\n    uint256 batchStartIndex = tallyBatchNum * tallyBatchSize;\n\n    // save some gas because we won't overflow uint256\n    unchecked {\n      tallyBatchNum++;\n    }\n\n    (uint256 numSignUps, ) = poll.numSignUpsAndMessages();\n\n    // Require that there are untallied ballots left\n    if (batchStartIndex >= numSignUps) {\n      revert AllBallotsTallied();\n    }\n\n    bool isValid = verifyTallyProof(_proof, numSignUps, batchStartIndex, tallyBatchSize, _newTallyCommitment);\n\n    if (!isValid) {\n      revert InvalidTallyVotesProof();\n    }\n\n    // Update the tally commitment and the tally batch num\n    tallyCommitment = _newTallyCommitment;\n  }\n\n  /// @notice Verify the tally proof using the verifying key\n  /// @param _proof the proof generated after processing all messages\n  /// @param _numSignUps number of signups for a given poll\n  /// @param _batchStartIndex the number of batches multiplied by the size of the batch\n  /// @param _tallyBatchSize batch size for the tally\n  /// @param _newTallyCommitment the tally commitment to be verified at a given batch index\n  /// @return isValid whether the proof is valid\n  function verifyTallyProof(\n    uint256[8] calldata _proof,\n    uint256 _numSignUps,\n    uint256 _batchStartIndex,\n    uint256 _tallyBatchSize,\n    uint256 _newTallyCommitment\n  ) public view returns (bool isValid) {\n    (uint8 intStateTreeDepth, , , uint8 voteOptionTreeDepth) = poll.treeDepths();\n\n    (IMACI maci, , ) = poll.extContracts();\n\n    // Get the verifying key\n    VerifyingKey memory vk = vkRegistry.getTallyVk(maci.stateTreeDepth(), intStateTreeDepth, voteOptionTreeDepth);\n\n    // Get the public inputs\n    uint256 publicInputHash = genTallyVotesPublicInputHash(\n      _numSignUps,\n      _batchStartIndex,\n      _tallyBatchSize,\n      _newTallyCommitment\n    );\n\n    // Verify the proof\n    isValid = verifier.verify(_proof, vk, publicInputHash);\n  }\n\n  /// @notice Compute the merkle root from the path elements\n  /// and a leaf\n  /// @param _depth the depth of the merkle tree\n  /// @param _index the index of the leaf\n  /// @param _leaf the leaf\n  /// @param _pathElements the path elements to reconstruct the merkle root\n  /// @return current The merkle root\n  function computeMerkleRootFromPath(\n    uint8 _depth,\n    uint256 _index,\n    uint256 _leaf,\n    uint256[][] calldata _pathElements\n  ) internal pure returns (uint256 current) {\n    uint256 pos = _index % TREE_ARITY;\n    current = _leaf;\n    uint8 k;\n\n    uint256[TREE_ARITY] memory level;\n\n    for (uint8 i = 0; i < _depth; ++i) {\n      for (uint8 j = 0; j < TREE_ARITY; ++j) {\n        if (j == pos) {\n          level[j] = current;\n        } else {\n          if (j > pos) {\n            k = j - 1;\n          } else {\n            k = j;\n          }\n          level[j] = _pathElements[i][k];\n        }\n      }\n\n      _index /= TREE_ARITY;\n      pos = _index % TREE_ARITY;\n      current = hash5(level);\n    }\n  }\n\n  /// @notice Verify the number of spent voice credits from the tally.json\n  /// @param _totalSpent spent field retrieved in the totalSpentVoiceCredits object\n  /// @param _totalSpentSalt the corresponding salt in the totalSpentVoiceCredit object\n  /// @param _resultCommitment hashLeftRight(merkle root of the results.tally, results.salt) in tally.json file\n  /// @param _perVOSpentVoiceCreditsHash hashLeftRight(merkle root of the no spent voice credits per vote option, salt)\n  /// @return isValid Whether the provided values are valid\n  function verifySpentVoiceCredits(\n    uint256 _totalSpent,\n    uint256 _totalSpentSalt,\n    uint256 _resultCommitment,\n    uint256 _perVOSpentVoiceCreditsHash\n  ) public view returns (bool isValid) {\n    uint256[3] memory tally;\n    tally[0] = _resultCommitment;\n    tally[1] = hashLeftRight(_totalSpent, _totalSpentSalt);\n    tally[2] = _perVOSpentVoiceCreditsHash;\n\n    isValid = hash3(tally) == tallyCommitment;\n  }\n\n  /// @notice Verify the number of spent voice credits per vote option from the tally.json\n  /// @param _voteOptionIndex the index of the vote option where credits were spent\n  /// @param _spent the spent voice credits for a given vote option index\n  /// @param _spentProof proof generated for the perVOSpentVoiceCredits\n  /// @param _spentSalt the corresponding salt given in the tally perVOSpentVoiceCredits object\n  /// @param _voteOptionTreeDepth depth of the vote option tree\n  /// @param _spentVoiceCreditsHash hashLeftRight(number of spent voice credits, spent salt)\n  /// @param _resultCommitment hashLeftRight(merkle root of the results.tally, results.salt)\n  // in the tally.json file\n  /// @return isValid Whether the provided proof is valid\n  function verifyPerVOSpentVoiceCredits(\n    uint256 _voteOptionIndex,\n    uint256 _spent,\n    uint256[][] calldata _spentProof,\n    uint256 _spentSalt,\n    uint8 _voteOptionTreeDepth,\n    uint256 _spentVoiceCreditsHash,\n    uint256 _resultCommitment\n  ) public view returns (bool isValid) {\n    uint256 computedRoot = computeMerkleRootFromPath(_voteOptionTreeDepth, _voteOptionIndex, _spent, _spentProof);\n\n    uint256[3] memory tally;\n    tally[0] = _resultCommitment;\n    tally[1] = _spentVoiceCreditsHash;\n    tally[2] = hashLeftRight(computedRoot, _spentSalt);\n\n    isValid = hash3(tally) == tallyCommitment;\n  }\n\n  /// @notice Verify the result generated from the tally.json\n  /// @param _voteOptionIndex the index of the vote option to verify the correctness of the tally\n  /// @param _tallyResult Flattened array of the tally\n  /// @param _tallyResultProof Corresponding proof of the tally result\n  /// @param _tallyResultSalt the respective salt in the results object in the tally.json\n  /// @param _voteOptionTreeDepth depth of the vote option tree\n  /// @param _spentVoiceCreditsHash hashLeftRight(number of spent voice credits, spent salt)\n  /// @param _perVOSpentVoiceCreditsHash hashLeftRight(merkle root of the no spent voice\n  /// credits per vote option, perVOSpentVoiceCredits salt)\n  /// @return isValid Whether the provided proof is valid\n  function verifyTallyResult(\n    uint256 _voteOptionIndex,\n    uint256 _tallyResult,\n    uint256[][] calldata _tallyResultProof,\n    uint256 _tallyResultSalt,\n    uint8 _voteOptionTreeDepth,\n    uint256 _spentVoiceCreditsHash,\n    uint256 _perVOSpentVoiceCreditsHash\n  ) public view returns (bool isValid) {\n    uint256 computedRoot = computeMerkleRootFromPath(\n      _voteOptionTreeDepth,\n      _voteOptionIndex,\n      _tallyResult,\n      _tallyResultProof\n    );\n\n    uint256[3] memory tally;\n    tally[0] = hashLeftRight(computedRoot, _tallyResultSalt);\n    tally[1] = _spentVoiceCreditsHash;\n    tally[2] = _perVOSpentVoiceCreditsHash;\n\n    isValid = hash3(tally) == tallyCommitment;\n  }\n}\n"
    },
    "maci-contracts/contracts/TopupCredit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title TopupCredit\n/// @notice A contract representing a token used to topup a MACI's voter\n/// credits\ncontract TopupCredit is ERC20, Ownable {\n  uint8 public constant DECIMALS = 1;\n  uint256 public constant MAXIMUM_AIRDROP_AMOUNT = 100000 * 10 ** DECIMALS;\n\n  /// @notice custom errors\n  error ExceedLimit();\n\n  /// @notice create  a new TopupCredit token\n  constructor() payable ERC20(\"TopupCredit\", \"TopupCredit\") {}\n\n  /// @notice mint tokens to an account\n  /// @param account the account to mint tokens to\n  /// @param amount the amount of tokens to mint\n  function airdropTo(address account, uint256 amount) public onlyOwner {\n    if (amount >= MAXIMUM_AIRDROP_AMOUNT) {\n      revert ExceedLimit();\n    }\n\n    _mint(account, amount);\n  }\n\n  /// @notice mint tokens to the contract owner\n  /// @param amount the amount of tokens to mint\n  function airdrop(uint256 amount) public onlyOwner {\n    if (amount >= MAXIMUM_AIRDROP_AMOUNT) {\n      revert ExceedLimit();\n    }\n\n    _mint(msg.sender, amount);\n  }\n}\n"
    },
    "maci-contracts/contracts/trees/AccQueue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Hasher } from \"../crypto/Hasher.sol\";\n\n/// @title AccQueue\n/// @notice This contract defines a Merkle tree where each leaf insertion only updates a\n/// subtree. To obtain the main tree root, the contract owner must merge the\n/// subtrees together. Merging subtrees requires at least 2 operations:\n/// mergeSubRoots(), and merge(). To get around the gas limit,\n/// the mergeSubRoots() can be performed in multiple transactions.\nabstract contract AccQueue is Ownable, Hasher {\n  // The maximum tree depth\n  uint256 public constant MAX_DEPTH = 32;\n\n  /// @notice A Queue is a 2D array of Merkle roots and indices which represents nodes\n  /// in a Merkle tree while it is progressively updated.\n  struct Queue {\n    /// @notice IMPORTANT: the following declares an array of b elements of type T: T[b]\n    /// And the following declares an array of b elements of type T[a]: T[a][b]\n    /// As such, the following declares an array of MAX_DEPTH+1 arrays of\n    /// uint256[4] arrays, **not the other way round**:\n    uint256[4][MAX_DEPTH + 1] levels;\n    uint256[MAX_DEPTH + 1] indices;\n  }\n\n  // The depth of each subtree\n  uint256 internal immutable subDepth;\n\n  // The number of elements per hash operation. Should be either 2 (for\n  // binary trees) or 5 (quinary trees). The limit is 5 because that is the\n  // maximum supported number of inputs for the EVM implementation of the\n  // Poseidon hash function\n  uint256 internal immutable hashLength;\n\n  // hashLength ** subDepth\n  uint256 internal immutable subTreeCapacity;\n\n  // True hashLength == 2, false if hashLength == 5\n  bool internal isBinary;\n\n  // The index of the current subtree. e.g. the first subtree has index 0, the\n  // second has 1, and so on\n  uint256 internal currentSubtreeIndex;\n\n  // Tracks the current subtree.\n  Queue internal leafQueue;\n\n  // Tracks the smallest tree of subroots\n  Queue internal subRootQueue;\n\n  // Subtree roots\n  mapping(uint256 => uint256) internal subRoots;\n\n  // Merged roots\n  uint256[MAX_DEPTH + 1] internal mainRoots;\n\n  // Whether the subtrees have been merged\n  bool public subTreesMerged;\n\n  // Whether entire merkle tree has been merged\n  bool public treeMerged;\n\n  // The root of the shortest possible tree which fits all current subtree\n  // roots\n  uint256 internal smallSRTroot;\n\n  // Tracks the next subroot to queue\n  uint256 internal nextSubRootIndex;\n\n  // The number of leaves inserted across all subtrees so far\n  uint256 public numLeaves;\n\n  /// @notice custom errors\n  error SubDepthCannotBeZero();\n  error SubdepthTooLarge(uint256 _subDepth, uint256 max);\n  error InvalidHashLength();\n  error DepthCannotBeZero();\n  error SubTreesAlreadyMerged();\n  error NothingToMerge();\n  error SubTreesNotMerged();\n  error DepthTooLarge(uint256 _depth, uint256 max);\n  error DepthTooSmall(uint256 _depth, uint256 min);\n  error InvalidIndex(uint256 _index);\n  error InvalidLevel();\n\n  /// @notice Create a new AccQueue\n  /// @param _subDepth The depth of each subtree.\n  /// @param _hashLength The number of leaves per node (2 or 5).\n  constructor(uint256 _subDepth, uint256 _hashLength) payable {\n    /// validation\n    if (_subDepth == 0) revert SubDepthCannotBeZero();\n    if (_subDepth > MAX_DEPTH) revert SubdepthTooLarge(_subDepth, MAX_DEPTH);\n    if (_hashLength != 2 && _hashLength != 5) revert InvalidHashLength();\n\n    isBinary = _hashLength == 2;\n    subDepth = _subDepth;\n    hashLength = _hashLength;\n    subTreeCapacity = _hashLength ** _subDepth;\n  }\n\n  /// @notice Hash the contents of the specified level and the specified leaf.\n  /// This is a virtual function as the hash function which the overriding\n  /// contract uses will be either hashLeftRight or hash5, which require\n  /// different input array lengths.\n  /// @param _level The level to hash.\n  /// @param _leaf The leaf include with the level.\n  /// @return _hash The hash of the level and leaf.\n  // solhint-disable-next-line no-empty-blocks\n  function hashLevel(uint256 _level, uint256 _leaf) internal virtual returns (uint256 _hash) {}\n\n  /// @notice Hash the contents of the specified level and the specified leaf.\n  /// This is a virtual function as the hash function which the overriding\n  /// contract uses will be either hashLeftRight or hash5, which require\n  /// different input array lengths.\n  /// @param _level The level to hash.\n  /// @param _leaf The leaf include with the level.\n  /// @return _hash The hash of the level and leaf.\n  // solhint-disable-next-line no-empty-blocks\n  function hashLevelLeaf(uint256 _level, uint256 _leaf) public view virtual returns (uint256 _hash) {}\n\n  /// @notice Returns the zero leaf at a specified level.\n  /// This is a virtual function as the hash function which the overriding\n  /// contract uses will be either hashLeftRight or hash5, which will produce\n  /// different zero values (e.g. hashLeftRight(0, 0) vs\n  /// hash5([0, 0, 0, 0, 0]). Moreover, the zero value may be a\n  /// nothing-up-my-sleeve value.\n  /// @param _level The level at which to return the zero leaf.\n  /// @return zero The zero leaf at the specified level.\n  // solhint-disable-next-line no-empty-blocks\n  function getZero(uint256 _level) internal virtual returns (uint256 zero) {}\n\n  /// @notice Add a leaf to the queue for the current subtree.\n  /// @param _leaf The leaf to add.\n  /// @return leafIndex The index of the leaf in the queue.\n  function enqueue(uint256 _leaf) public onlyOwner returns (uint256 leafIndex) {\n    leafIndex = numLeaves;\n    // Recursively queue the leaf\n    _enqueue(_leaf, 0);\n\n    // Update the leaf counter\n    numLeaves = leafIndex + 1;\n\n    // Now that a new leaf has been added, mainRoots and smallSRTroot are\n    // obsolete\n    delete mainRoots;\n    delete smallSRTroot;\n    subTreesMerged = false;\n\n    // If a subtree is full\n    if (numLeaves % subTreeCapacity == 0) {\n      // Store the subroot\n      subRoots[currentSubtreeIndex] = leafQueue.levels[subDepth][0];\n\n      // Increment the index\n      currentSubtreeIndex++;\n\n      // Delete ancillary data\n      delete leafQueue.levels[subDepth][0];\n      delete leafQueue.indices;\n    }\n  }\n\n  /// @notice Updates the queue at a given level and hashes any subroots\n  /// that need to be hashed.\n  /// @param _leaf The leaf to add.\n  /// @param _level The level at which to queue the leaf.\n  function _enqueue(uint256 _leaf, uint256 _level) internal {\n    if (_level > subDepth) {\n      revert InvalidLevel();\n    }\n\n    while (true) {\n      uint256 n = leafQueue.indices[_level];\n\n      if (n != hashLength - 1) {\n        // Just store the leaf\n        leafQueue.levels[_level][n] = _leaf;\n\n        if (_level != subDepth) {\n          // Update the index\n          leafQueue.indices[_level]++;\n        }\n\n        return;\n      }\n\n      // Hash the leaves to next level\n      _leaf = hashLevel(_level, _leaf);\n\n      // Reset the index for this level\n      delete leafQueue.indices[_level];\n\n      // Queue the hash of the leaves into to the next level\n      _level++;\n    }\n  }\n\n  /// @notice Fill any empty leaves of the current subtree with zeros and store the\n  /// resulting subroot.\n  function fill() public onlyOwner {\n    if (numLeaves % subTreeCapacity == 0) {\n      // If the subtree is completely empty, then the subroot is a\n      // precalculated zero value\n      subRoots[currentSubtreeIndex] = getZero(subDepth);\n    } else {\n      // Otherwise, fill the rest of the subtree with zeros\n      _fill(0);\n\n      // Store the subroot\n      subRoots[currentSubtreeIndex] = leafQueue.levels[subDepth][0];\n\n      // Reset the subtree data\n      delete leafQueue.levels;\n\n      // Reset the merged roots\n      delete mainRoots;\n    }\n\n    // Increment the subtree index\n    uint256 curr = currentSubtreeIndex + 1;\n    currentSubtreeIndex = curr;\n\n    // Update the number of leaves\n    numLeaves = curr * subTreeCapacity;\n\n    // Reset the subroot tree root now that it is obsolete\n    delete smallSRTroot;\n\n    subTreesMerged = false;\n  }\n\n  /// @notice A function that queues zeros to the specified level, hashes,\n  /// the level, and enqueues the hash to the next level.\n  /// @param _level The level at which to queue zeros.\n  // solhint-disable-next-line no-empty-blocks\n  function _fill(uint256 _level) internal virtual {}\n\n  /// Insert a subtree. Used for batch enqueues.\n  function insertSubTree(uint256 _subRoot) public onlyOwner {\n    subRoots[currentSubtreeIndex] = _subRoot;\n\n    // Increment the subtree index\n    currentSubtreeIndex++;\n\n    // Update the number of leaves\n    numLeaves += subTreeCapacity;\n\n    // Reset the subroot tree root now that it is obsolete\n    delete smallSRTroot;\n\n    subTreesMerged = false;\n  }\n\n  /// @notice Calculate the lowest possible height of a tree with\n  /// all the subroots merged together.\n  /// @return depth The lowest possible height of a tree with all the\n  function calcMinHeight() public view returns (uint256 depth) {\n    depth = 1;\n    while (true) {\n      if (hashLength ** depth >= currentSubtreeIndex) {\n        break;\n      }\n      depth++;\n    }\n  }\n\n  /// @notice Merge all subtrees to form the shortest possible tree.\n  /// This function can be called either once to merge all subtrees in a\n  /// single transaction, or multiple times to do the same in multiple\n  /// transactions.\n  /// @param _numSrQueueOps The number of times this function will call\n  ///                       queueSubRoot(), up to the maximum number of times\n  ///                       necessary. If it is set to 0, it will call\n  ///                       queueSubRoot() as many times as is necessary. Set\n  ///                       this to a low number and call this function\n  ///                       multiple times if there are many subroots to\n  ///                       merge, or a single transaction could run out of\n  ///                       gas.\n  function mergeSubRoots(uint256 _numSrQueueOps) public onlyOwner {\n    // This function can only be called once unless a new subtree is created\n    if (subTreesMerged) revert SubTreesAlreadyMerged();\n\n    // There must be subtrees to merge\n    if (numLeaves == 0) revert NothingToMerge();\n\n    // Fill any empty leaves in the current subtree with zeros only if the\n    // current subtree is not full\n    if (numLeaves % subTreeCapacity != 0) {\n      fill();\n    }\n\n    // If there is only 1 subtree, use its root\n    if (currentSubtreeIndex == 1) {\n      smallSRTroot = getSubRoot(0);\n      subTreesMerged = true;\n      return;\n    }\n\n    uint256 depth = calcMinHeight();\n\n    uint256 queueOpsPerformed = 0;\n    for (uint256 i = nextSubRootIndex; i < currentSubtreeIndex; i++) {\n      if (_numSrQueueOps != 0 && queueOpsPerformed == _numSrQueueOps) {\n        // If the limit is not 0, stop if the limit has been reached\n        return;\n      }\n\n      // Queue the next subroot\n      queueSubRoot(getSubRoot(nextSubRootIndex), 0, depth);\n\n      // Increment the next subroot counter\n      nextSubRootIndex++;\n\n      // Increment the ops counter\n      queueOpsPerformed++;\n    }\n\n    // The height of the tree of subroots\n    uint256 m = hashLength ** depth;\n\n    // Queue zeroes to fill out the SRT\n    if (nextSubRootIndex == currentSubtreeIndex) {\n      uint256 z = getZero(subDepth);\n      for (uint256 i = currentSubtreeIndex; i < m; i++) {\n        queueSubRoot(z, 0, depth);\n      }\n    }\n\n    // Store the smallest main root\n    smallSRTroot = subRootQueue.levels[depth][0];\n    subTreesMerged = true;\n  }\n\n  /// @notice Queues a subroot into the subroot tree.\n  /// @param _leaf The value to queue.\n  /// @param _level The level at which to queue _leaf.\n  /// @param _maxDepth The depth of the tree.\n  function queueSubRoot(uint256 _leaf, uint256 _level, uint256 _maxDepth) internal {\n    if (_level > _maxDepth) {\n      return;\n    }\n\n    uint256 n = subRootQueue.indices[_level];\n\n    if (n != hashLength - 1) {\n      // Just store the leaf\n      subRootQueue.levels[_level][n] = _leaf;\n      subRootQueue.indices[_level]++;\n    } else {\n      // Hash the elements in this level and queue it in the next level\n      uint256 hashed;\n      if (isBinary) {\n        uint256[2] memory inputs;\n        inputs[0] = subRootQueue.levels[_level][0];\n        inputs[1] = _leaf;\n        hashed = hash2(inputs);\n      } else {\n        uint256[5] memory inputs;\n        for (uint8 i = 0; i < n; i++) {\n          inputs[i] = subRootQueue.levels[_level][i];\n        }\n        inputs[n] = _leaf;\n        hashed = hash5(inputs);\n      }\n\n      // TODO: change recursion to a while loop\n      // Recurse\n      delete subRootQueue.indices[_level];\n      queueSubRoot(hashed, _level + 1, _maxDepth);\n    }\n  }\n\n  /// @notice Merge all subtrees to form a main tree with a desired depth.\n  /// @param _depth The depth of the main tree. It must fit all the leaves or\n  ///               this function will revert.\n  /// @return root The root of the main tree.\n  function merge(uint256 _depth) public onlyOwner returns (uint256 root) {\n    // The tree depth must be more than 0\n    if (_depth == 0) revert DepthCannotBeZero();\n\n    // Ensure that the subtrees have been merged\n    if (!subTreesMerged) revert SubTreesNotMerged();\n\n    // Check the depth\n    if (_depth > MAX_DEPTH) revert DepthTooLarge(_depth, MAX_DEPTH);\n\n    // Calculate the SRT depth\n    uint256 srtDepth = subDepth;\n    while (true) {\n      if (hashLength ** srtDepth >= numLeaves) {\n        break;\n      }\n      srtDepth++;\n    }\n\n    if (_depth < srtDepth) revert DepthTooSmall(_depth, srtDepth);\n\n    // If the depth is the same as the SRT depth, just use the SRT root\n    if (_depth == srtDepth) {\n      mainRoots[_depth] = smallSRTroot;\n      treeMerged = true;\n      return smallSRTroot;\n    } else {\n      root = smallSRTroot;\n\n      // Calculate the main root\n\n      for (uint256 i = srtDepth; i < _depth; i++) {\n        uint256 z = getZero(i);\n\n        if (isBinary) {\n          uint256[2] memory inputs;\n          inputs[0] = root;\n          inputs[1] = z;\n          root = hash2(inputs);\n        } else {\n          uint256[5] memory inputs;\n          inputs[0] = root;\n          inputs[1] = z;\n          inputs[2] = z;\n          inputs[3] = z;\n          inputs[4] = z;\n          root = hash5(inputs);\n        }\n      }\n\n      mainRoots[_depth] = root;\n      treeMerged = true;\n    }\n  }\n\n  /// @notice Returns the subroot at the specified index. Reverts if the index refers\n  /// to a subtree which has not been filled yet.\n  /// @param _index The subroot index.\n  /// @return subRoot The subroot at the specified index.\n  function getSubRoot(uint256 _index) public view returns (uint256 subRoot) {\n    if (currentSubtreeIndex <= _index) revert InvalidIndex(_index);\n    subRoot = subRoots[_index];\n  }\n\n  /// @notice Returns the subroot tree (SRT) root. Its value must first be computed\n  /// using mergeSubRoots.\n  /// @return smallSubTreeRoot The SRT root.\n  function getSmallSRTroot() public view returns (uint256 smallSubTreeRoot) {\n    if (!subTreesMerged) revert SubTreesNotMerged();\n    smallSubTreeRoot = smallSRTroot;\n  }\n\n  /// @notice Return the merged Merkle root of all the leaves at a desired depth.\n  /// @dev merge() or merged(_depth) must be called first.\n  /// @param _depth The depth of the main tree. It must first be computed\n  ///               using mergeSubRoots() and merge().\n  /// @return mainRoot The root of the main tree.\n  function getMainRoot(uint256 _depth) public view returns (uint256 mainRoot) {\n    if (hashLength ** _depth < numLeaves) revert DepthTooSmall(_depth, numLeaves);\n\n    mainRoot = mainRoots[_depth];\n  }\n\n  /// @notice Get the next subroot index and the current subtree index.\n  function getSrIndices() public view returns (uint256 next, uint256 current) {\n    next = nextSubRootIndex;\n    current = currentSubtreeIndex;\n  }\n}\n"
    },
    "maci-contracts/contracts/trees/AccQueueQuinary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { AccQueue } from \"./AccQueue.sol\";\n\n/// @title AccQueueQuinary\n/// @notice This contract defines a Merkle tree where each leaf insertion only updates a\n/// subtree. To obtain the main tree root, the contract owner must merge the\n/// subtrees together. Merging subtrees requires at least 2 operations:\n/// mergeSubRoots(), and merge(). To get around the gas limit,\n/// the mergeSubRoots() can be performed in multiple transactions.\n/// @dev This contract is for a quinary tree (5 leaves per node)\nabstract contract AccQueueQuinary is AccQueue {\n  /// @notice Create a new AccQueueQuinary instance\n  constructor(uint256 _subDepth) AccQueue(_subDepth, 5) {}\n\n  /// @notice Hash the contents of the specified level and the specified leaf.\n  /// @dev it also frees up storage slots to refund gas.\n  /// @param _level The level to hash.\n  /// @param _leaf The leaf include with the level.\n  /// @return hashed The hash of the level and leaf.\n  function hashLevel(uint256 _level, uint256 _leaf) internal override returns (uint256 hashed) {\n    uint256[5] memory inputs;\n    inputs[0] = leafQueue.levels[_level][0];\n    inputs[1] = leafQueue.levels[_level][1];\n    inputs[2] = leafQueue.levels[_level][2];\n    inputs[3] = leafQueue.levels[_level][3];\n    inputs[4] = _leaf;\n    hashed = hash5(inputs);\n\n    // Free up storage slots to refund gas. Note that using a loop here\n    // would result in lower gas savings.\n    delete leafQueue.levels[_level];\n  }\n\n  /// @notice Hash the contents of the specified level and the specified leaf.\n  /// @param _level The level to hash.\n  /// @param _leaf The leaf include with the level.\n  /// @return hashed The hash of the level and leaf.\n  function hashLevelLeaf(uint256 _level, uint256 _leaf) public view override returns (uint256 hashed) {\n    uint256[5] memory inputs;\n    inputs[0] = leafQueue.levels[_level][0];\n    inputs[1] = leafQueue.levels[_level][1];\n    inputs[2] = leafQueue.levels[_level][2];\n    inputs[3] = leafQueue.levels[_level][3];\n    inputs[4] = _leaf;\n    hashed = hash5(inputs);\n  }\n\n  /// @notice An internal function which fills a subtree\n  /// @param _level The level at which to fill the subtree\n  function _fill(uint256 _level) internal override {\n    while (_level < subDepth) {\n      uint256 n = leafQueue.indices[_level];\n\n      if (n != 0) {\n        // Fill the subtree level with zeros and hash the level\n        uint256 hashed;\n\n        uint256[5] memory inputs;\n        uint256 z = getZero(_level);\n        uint8 i = 0;\n        for (; i < n; i++) {\n          inputs[i] = leafQueue.levels[_level][i];\n        }\n\n        for (; i < hashLength; i++) {\n          inputs[i] = z;\n        }\n        hashed = hash5(inputs);\n\n        // Update the subtree from the next level onwards with the new leaf\n        _enqueue(hashed, _level + 1);\n      }\n\n      // Reset the current level\n      delete leafQueue.indices[_level];\n\n      _level++;\n    }\n  }\n}\n"
    },
    "maci-contracts/contracts/trees/AccQueueQuinaryBlankSl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { MerkleZeros as MerkleQuinaryBlankSl } from \"./zeros/MerkleQuinaryBlankSl.sol\";\nimport { AccQueueQuinary } from \"./AccQueueQuinary.sol\";\n\n/// @title AccQueueQuinaryBlankSl\n/// @notice This contract extends AccQueueQuinary and MerkleQuinaryBlankSl\n/// @dev This contract is used for creating a\n/// Merkle tree with quinary (5 leaves per node) structure\ncontract AccQueueQuinaryBlankSl is AccQueueQuinary, MerkleQuinaryBlankSl {\n  /// @notice Constructor for creating AccQueueQuinaryBlankSl contract\n  /// @param _subDepth The depth of each subtree\n  constructor(uint256 _subDepth) AccQueueQuinary(_subDepth) {}\n\n  /// @notice Returns the zero leaf at a specified level\n  /// @param _level The level at which to return the zero leaf\n  /// @return zero The zero leaf at the specified level\n  function getZero(uint256 _level) internal view override returns (uint256 zero) {\n    zero = zeros[_level];\n  }\n}\n"
    },
    "maci-contracts/contracts/trees/EmptyBallotRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nabstract contract EmptyBallotRoots {\n  // emptyBallotRoots contains the roots of Ballot trees of five leaf\n  // configurations.\n  // Each tree has a depth of 10, which is the hardcoded state tree depth.\n  // Each leaf is an empty ballot. A configuration refers to the depth of the\n  // voice option tree for that ballot.\n\n  // The leaf for the root at index 0 contains hash(0, root of a VO tree with\n  // depth 1 and zero-value 0)\n\n  // The leaf for the root at index 1 contains hash(0, root of a VO tree with\n  // depth 2 and zero-value 0)\n\n  // ... and so on.\n\n  // The first parameter to the hash function is the nonce, which is 0.\n\n  uint256[5] internal emptyBallotRoots;\n\n  constructor() {\n    emptyBallotRoots[0] = uint256(4904028317433377177773123885584230878115556059208431880161186712332781831975);\n    emptyBallotRoots[1] = uint256(344732312350052944041104345325295111408747975338908491763817872057138864163);\n    emptyBallotRoots[2] = uint256(19445814455012978799483892811950396383084183210860279923207176682490489907069);\n    emptyBallotRoots[3] = uint256(10621810780690303482827422143389858049829670222244900617652404672125492013328);\n    emptyBallotRoots[4] = uint256(17077690379337026179438044602068085690662043464643511544329656140997390498741);\n  }\n}\n"
    },
    "maci-contracts/contracts/trees/zeros/MerkleQuinaryBlankSl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nabstract contract MerkleZeros {\n  uint256[33] internal zeros;\n\n  // Quinary tree zeros (hash of a blank state leaf)\n  constructor() {\n    zeros[0] = uint256(6769006970205099520508948723718471724660867171122235270773600567925038008762);\n    zeros[1] = uint256(1817443256073160983037956906834195537015546107754139333779374752610409243040);\n    zeros[2] = uint256(5025334324706345710800763986625066818722194863275454698142520938431664775139);\n    zeros[3] = uint256(14192954438167108345302805021925904074255585459982294518284934685870159779036);\n    zeros[4] = uint256(20187882570958996766847085412101405873580281668670041750401431925441526137696);\n    zeros[5] = uint256(19003337309269317766726592380821628773167513668895143249995308839385810331053);\n    zeros[6] = uint256(8492845964288036916491732908697290386617362835683911619537012952509890847451);\n    zeros[7] = uint256(21317322053785868903775560086424946986124609731059541056518805391492871868814);\n    zeros[8] = uint256(4256218134522031233385262696416028085306220785615095518146227774336224649500);\n    zeros[9] = uint256(20901832483812704342876390942522900825096860186886589193649848721504734341597);\n    zeros[10] = uint256(9267454486648593048583319961333207622177969074484816717792204743506543655505);\n    zeros[11] = uint256(7650747654726613674993974917452464536868175649563857452207429547024788245109);\n    zeros[12] = uint256(12795449162487060618571749226308575208199045387848354123797521555997299022426);\n    zeros[13] = uint256(2618557044910497521493457299926978327841926538380467450910611798747947773417);\n    zeros[14] = uint256(4921285654960018268026585535199462620025474147042548993648101553653712920841);\n    zeros[15] = uint256(3955171118947393404895230582611078362154691627898437205118006583966987624963);\n    zeros[16] = uint256(14699122743207261418107167543163571550551347592030521489185842204376855027947);\n    zeros[17] = uint256(19194001556311522650950142975587831061973644651464593103195262630226529549573);\n    zeros[18] = uint256(6797319293744791648201295415173228627305696583566554220235084234134847845566);\n    zeros[19] = uint256(1267384159070923114421683251804507954363252272096341442482679590950570779538);\n    zeros[20] = uint256(3856223245980092789300785214737986268213218594679123772901587106666007826613);\n    zeros[21] = uint256(18676489457897260843888223351978541467312325190019940958023830749320128516742);\n    zeros[22] = uint256(1264182110328471160091364892521750324454825019784514769029658712768604765832);\n    zeros[23] = uint256(2656996430278859489720531694992812241970377217691981498421470018287262214836);\n    zeros[24] = uint256(18383091906017498328025573868990834275527351249551450291689105976789994000945);\n    zeros[25] = uint256(13529005048172217954112431586843818755284974925259175262114689118374272942448);\n    zeros[26] = uint256(12992932230018177961399273443546858115054107741258772159002781102941121463198);\n    zeros[27] = uint256(2863122912185356538647249583178796893334871904920344676880115119793539219810);\n    zeros[28] = uint256(21225940722224750787686036600289689346822264717843340643526494987845938066724);\n    zeros[29] = uint256(10287710058152238258370855601473179390407624438853416678054122418589867334291);\n    zeros[30] = uint256(19473882726731003241332772446613588021823731071450664115530121948154136765165);\n    zeros[31] = uint256(5317840242664832852914696563734700089268851122527105938301831862363938018455);\n    zeros[32] = uint256(16560004488485252485490851383643926099553282582813695748927880827248594395952);\n  }\n}\n"
    },
    "maci-contracts/contracts/utilities/CommonUtilities.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IPoll } from \"../interfaces/IPoll.sol\";\n\n/// @title CommonUtilities\n/// @notice A contract that holds common utilities\n/// which are to be used by multiple contracts\n/// namely Subsidy, Tally and MessageProcessor\ncontract CommonUtilities {\n  error VotingPeriodNotPassed();\n\n  /// @notice common function for MessageProcessor, Tally and Subsidy\n  /// @param _poll the poll to be checked\n  function _votingPeriodOver(IPoll _poll) internal view {\n    (uint256 deployTime, uint256 duration) = _poll.getDeployTimeAndDuration();\n    // Require that the voting period is over\n    uint256 secondsPassed = block.timestamp - deployTime;\n    if (secondsPassed <= duration) {\n      revert VotingPeriodNotPassed();\n    }\n  }\n}\n"
    },
    "maci-contracts/contracts/utilities/DomainObjs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/// @title DomainObjs\n/// @notice An utility contract that holds\n/// a number of domain objects and functions\ncontract DomainObjs {\n  /// @notice the length of a MACI message\n  uint8 public constant MESSAGE_DATA_LENGTH = 10;\n\n  /// @title Message\n  /// @notice this struct represents a MACI message\n  /// @dev msgType: 1 for vote message, 2 for topup message (size 2)\n  struct Message {\n    uint256 msgType;\n    uint256[MESSAGE_DATA_LENGTH] data;\n  }\n\n  /// @title PubKey\n  /// @notice A MACI public key\n  struct PubKey {\n    uint256 x;\n    uint256 y;\n  }\n\n  /// @title StateLeaf\n  /// @notice A MACI state leaf\n  /// @dev used to represent a user's state\n  /// in the state Merkle tree\n  struct StateLeaf {\n    PubKey pubKey;\n    uint256 voiceCreditBalance;\n    uint256 timestamp;\n  }\n}\n"
    },
    "maci-contracts/contracts/utilities/Params.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IMACI } from \"../interfaces/IMACI.sol\";\nimport { AccQueue } from \"../trees/AccQueue.sol\";\nimport { TopupCredit } from \"../TopupCredit.sol\";\n\n/// @title Params\n/// @notice This contracts contains a number of structures\n/// which are to be passed as parameters to Poll contracts.\n/// This way we can reduce the number of parameters\n/// and avoid a stack too deep error during compilation.\ncontract Params {\n  /// @notice A struct holding the depths of the merkle trees\n  struct TreeDepths {\n    uint8 intStateTreeDepth;\n    uint8 messageTreeSubDepth;\n    uint8 messageTreeDepth;\n    uint8 voteOptionTreeDepth;\n  }\n\n  /// @notice A struct holding the max values for the poll\n  struct MaxValues {\n    uint256 maxMessages;\n    uint256 maxVoteOptions;\n  }\n\n  /// @notice A struct holding the external contracts\n  /// that are to be passed to a Poll contract on\n  /// deployment\n  struct ExtContracts {\n    IMACI maci;\n    AccQueue messageAq;\n    TopupCredit topupCredit;\n  }\n}\n"
    },
    "maci-contracts/contracts/utilities/Utilities.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport { DomainObjs } from \"./DomainObjs.sol\";\nimport { Hasher } from \"../crypto/Hasher.sol\";\nimport { SnarkConstants } from \"../crypto/SnarkConstants.sol\";\n\n/// @title Utilities\n/// @notice An utility contract that can be used to:\n/// * hash a state leaf\n/// * pad and hash a MACI message\n/// * hash a MACI message and an encryption public key\ncontract Utilities is SnarkConstants, DomainObjs, Hasher {\n  /// @notice custom errors\n  error InvalidMessage();\n\n  /// @notice An utility function used to hash a state leaf\n  /// @param _stateLeaf the state leaf to be hashed\n  /// @return ciphertext The hash of the state leaf\n  function hashStateLeaf(StateLeaf memory _stateLeaf) public pure returns (uint256 ciphertext) {\n    uint256[4] memory plaintext;\n    plaintext[0] = _stateLeaf.pubKey.x;\n    plaintext[1] = _stateLeaf.pubKey.y;\n    plaintext[2] = _stateLeaf.voiceCreditBalance;\n    plaintext[3] = _stateLeaf.timestamp;\n\n    ciphertext = hash4(plaintext);\n  }\n\n  /// @notice An utility function used to pad and hash a MACI message\n  /// @param dataToPad the data to be padded\n  /// @param msgType the type of the message\n  /// @return message The padded message\n  /// @return padKey The padding public key\n  /// @return msgHash The hash of the padded message and encryption key\n  function padAndHashMessage(\n    uint256[2] memory dataToPad,\n    uint256 msgType\n  ) public pure returns (Message memory message, PubKey memory padKey, uint256 msgHash) {\n    // add data and pad it to 10 elements (automatically cause it's the default value)\n    uint256[10] memory dat;\n    dat[0] = dataToPad[0];\n    dat[1] = dataToPad[1];\n\n    padKey = PubKey(PAD_PUBKEY_X, PAD_PUBKEY_Y);\n    message = Message({ msgType: msgType, data: dat });\n    msgHash = hashMessageAndEncPubKey(message, padKey);\n  }\n\n  /// @notice An utility function used to hash a MACI message and an encryption public key\n  /// @param _message the message to be hashed\n  /// @param _encPubKey the encryption public key to be hashed\n  /// @return msgHash The hash of the message and the encryption public key\n  function hashMessageAndEncPubKey(\n    Message memory _message,\n    PubKey memory _encPubKey\n  ) public pure returns (uint256 msgHash) {\n    if (_message.data.length != 10) {\n      revert InvalidMessage();\n    }\n\n    uint256[5] memory n;\n    n[0] = _message.data[0];\n    n[1] = _message.data[1];\n    n[2] = _message.data[2];\n    n[3] = _message.data[3];\n    n[4] = _message.data[4];\n\n    uint256[5] memory m;\n    m[0] = _message.data[5];\n    m[1] = _message.data[6];\n    m[2] = _message.data[7];\n    m[3] = _message.data[8];\n    m[4] = _message.data[9];\n\n    msgHash = hash5([_message.msgType, hash5(n), hash5(m), _encPubKey.x, _encPubKey.y]);\n  }\n}\n"
    },
    "maci-contracts/contracts/VkRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { SnarkCommon } from \"./crypto/SnarkCommon.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IVkRegistry } from \"./interfaces/IVkRegistry.sol\";\n\n/// @title VkRegistry\n/// @notice Stores verifying keys for the circuits.\n/// Each circuit has a signature which is its compile-time constants represented\n/// as a uint256.\ncontract VkRegistry is Ownable, SnarkCommon, IVkRegistry {\n  mapping(uint256 => VerifyingKey) internal processVks;\n  mapping(uint256 => bool) internal processVkSet;\n\n  mapping(uint256 => VerifyingKey) internal tallyVks;\n  mapping(uint256 => bool) internal tallyVkSet;\n\n  mapping(uint256 => VerifyingKey) internal subsidyVks;\n  mapping(uint256 => bool) internal subsidyVkSet;\n\n  event ProcessVkSet(uint256 _sig);\n  event TallyVkSet(uint256 _sig);\n  event SubsidyVkSet(uint256 _sig);\n\n  error ProcessVkAlreadySet();\n  error TallyVkAlreadySet();\n  error SubsidyVkAlreadySet();\n  error ProcessVkNotSet();\n  error TallyVkNotSet();\n  error SubsidyVkNotSet();\n\n  /// @notice Create a new instance of the VkRegistry contract\n  // solhint-disable-next-line no-empty-blocks\n  constructor() payable {}\n\n  /// @notice Check if the process verifying key is set\n  /// @param _sig The signature\n  /// @return isSet whether the verifying key is set\n  function isProcessVkSet(uint256 _sig) public view returns (bool isSet) {\n    isSet = processVkSet[_sig];\n  }\n\n  /// @notice Check if the tally verifying key is set\n  /// @param _sig The signature\n  /// @return isSet whether the verifying key is set\n  function isTallyVkSet(uint256 _sig) public view returns (bool isSet) {\n    isSet = tallyVkSet[_sig];\n  }\n\n  /// @notice Check if the subsidy verifying key is set\n  /// @param _sig The signature\n  /// @return isSet whether the verifying key is set\n  function isSubsidyVkSet(uint256 _sig) public view returns (bool isSet) {\n    isSet = subsidyVkSet[_sig];\n  }\n\n  /// @notice generate the signature for the process verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _messageTreeDepth The message tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @param _messageBatchSize The message batch size\n  function genProcessVkSig(\n    uint256 _stateTreeDepth,\n    uint256 _messageTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    uint256 _messageBatchSize\n  ) public pure returns (uint256 sig) {\n    sig = (_messageBatchSize << 192) + (_stateTreeDepth << 128) + (_messageTreeDepth << 64) + _voteOptionTreeDepth;\n  }\n\n  /// @notice generate the signature for the tally verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return sig The signature\n  function genTallyVkSig(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public pure returns (uint256 sig) {\n    sig = (_stateTreeDepth << 128) + (_intStateTreeDepth << 64) + _voteOptionTreeDepth;\n  }\n\n  /// @notice generate the signature for the subsidy verifying key\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return sig The signature\n  function genSubsidyVkSig(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public pure returns (uint256 sig) {\n    sig = (_stateTreeDepth << 128) + (_intStateTreeDepth << 64) + _voteOptionTreeDepth;\n  }\n\n  /// @notice Set the process and tally verifying keys for a certain combination\n  /// of parameters\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _messageTreeDepth The message tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @param _messageBatchSize The message batch size\n  /// @param _processVk The process verifying key\n  /// @param _tallyVk The tally verifying key\n  function setVerifyingKeys(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _messageTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    uint256 _messageBatchSize,\n    VerifyingKey calldata _processVk,\n    VerifyingKey calldata _tallyVk\n  ) public onlyOwner {\n    uint256 processVkSig = genProcessVkSig(_stateTreeDepth, _messageTreeDepth, _voteOptionTreeDepth, _messageBatchSize);\n\n    if (processVkSet[processVkSig]) revert ProcessVkAlreadySet();\n\n    uint256 tallyVkSig = genTallyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    if (tallyVkSet[tallyVkSig]) revert TallyVkAlreadySet();\n\n    VerifyingKey storage processVk = processVks[processVkSig];\n    processVk.alpha1 = _processVk.alpha1;\n    processVk.beta2 = _processVk.beta2;\n    processVk.gamma2 = _processVk.gamma2;\n    processVk.delta2 = _processVk.delta2;\n    for (uint8 i = 0; i < _processVk.ic.length; i++) {\n      processVk.ic.push(_processVk.ic[i]);\n    }\n\n    processVkSet[processVkSig] = true;\n\n    VerifyingKey storage tallyVk = tallyVks[tallyVkSig];\n    tallyVk.alpha1 = _tallyVk.alpha1;\n    tallyVk.beta2 = _tallyVk.beta2;\n    tallyVk.gamma2 = _tallyVk.gamma2;\n    tallyVk.delta2 = _tallyVk.delta2;\n    for (uint8 i = 0; i < _tallyVk.ic.length; i++) {\n      tallyVk.ic.push(_tallyVk.ic[i]);\n    }\n    tallyVkSet[tallyVkSig] = true;\n\n    emit TallyVkSet(tallyVkSig);\n    emit ProcessVkSet(processVkSig);\n  }\n\n  /// @notice Set the process verifying key for a certain combination\n  /// of parameters\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @param _subsidyVk The verifying key\n  function setSubsidyKeys(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    VerifyingKey calldata _subsidyVk\n  ) public onlyOwner {\n    uint256 subsidyVkSig = genSubsidyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    if (subsidyVkSet[subsidyVkSig]) revert SubsidyVkAlreadySet();\n\n    VerifyingKey storage subsidyVk = subsidyVks[subsidyVkSig];\n    subsidyVk.alpha1 = _subsidyVk.alpha1;\n    subsidyVk.beta2 = _subsidyVk.beta2;\n    subsidyVk.gamma2 = _subsidyVk.gamma2;\n    subsidyVk.delta2 = _subsidyVk.delta2;\n    for (uint8 i = 0; i < _subsidyVk.ic.length; i++) {\n      subsidyVk.ic.push(_subsidyVk.ic[i]);\n    }\n    subsidyVkSet[subsidyVkSig] = true;\n\n    emit SubsidyVkSet(subsidyVkSig);\n  }\n\n  /// @notice Check if the process verifying key is set\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _messageTreeDepth The message tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @param _messageBatchSize The message batch size\n  /// @return isSet whether the verifying key is set\n  function hasProcessVk(\n    uint256 _stateTreeDepth,\n    uint256 _messageTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    uint256 _messageBatchSize\n  ) public view returns (bool isSet) {\n    uint256 sig = genProcessVkSig(_stateTreeDepth, _messageTreeDepth, _voteOptionTreeDepth, _messageBatchSize);\n    isSet = processVkSet[sig];\n  }\n\n  /// @notice Get the process verifying key by signature\n  /// @param _sig The signature\n  /// @return vk The verifying key\n  function getProcessVkBySig(uint256 _sig) public view returns (VerifyingKey memory vk) {\n    if (!processVkSet[_sig]) revert ProcessVkNotSet();\n\n    vk = processVks[_sig];\n  }\n\n  /// @inheritdoc IVkRegistry\n  function getProcessVk(\n    uint256 _stateTreeDepth,\n    uint256 _messageTreeDepth,\n    uint256 _voteOptionTreeDepth,\n    uint256 _messageBatchSize\n  ) public view returns (VerifyingKey memory vk) {\n    uint256 sig = genProcessVkSig(_stateTreeDepth, _messageTreeDepth, _voteOptionTreeDepth, _messageBatchSize);\n\n    vk = getProcessVkBySig(sig);\n  }\n\n  /// @notice Check if the tally verifying key is set\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return isSet whether the verifying key is set\n  function hasTallyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public view returns (bool isSet) {\n    uint256 sig = genTallyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    isSet = tallyVkSet[sig];\n  }\n\n  /// @notice Get the tally verifying key by signature\n  /// @param _sig The signature\n  /// @return vk The verifying key\n  function getTallyVkBySig(uint256 _sig) public view returns (VerifyingKey memory vk) {\n    if (!tallyVkSet[_sig]) revert TallyVkNotSet();\n\n    vk = tallyVks[_sig];\n  }\n\n  /// @inheritdoc IVkRegistry\n  function getTallyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public view returns (VerifyingKey memory vk) {\n    uint256 sig = genTallyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    vk = getTallyVkBySig(sig);\n  }\n\n  /// @notice Check if the subsidy verifying key is set\n  /// @param _stateTreeDepth The state tree depth\n  /// @param _intStateTreeDepth The intermediate state tree depth\n  /// @param _voteOptionTreeDepth The vote option tree depth\n  /// @return isSet whether the verifying key is set\n  function hasSubsidyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public view returns (bool isSet) {\n    uint256 sig = genSubsidyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    isSet = subsidyVkSet[sig];\n  }\n\n  /// @notice Get the subsidy verifying key by signature\n  /// @param _sig The signature\n  /// @return vk The verifying key\n  function getSubsidyVkBySig(uint256 _sig) public view returns (VerifyingKey memory vk) {\n    if (!subsidyVkSet[_sig]) revert SubsidyVkNotSet();\n\n    vk = subsidyVks[_sig];\n  }\n\n  /// @inheritdoc IVkRegistry\n  function getSubsidyVk(\n    uint256 _stateTreeDepth,\n    uint256 _intStateTreeDepth,\n    uint256 _voteOptionTreeDepth\n  ) public view returns (VerifyingKey memory vk) {\n    uint256 sig = genSubsidyVkSig(_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth);\n\n    vk = getSubsidyVkBySig(sig);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}